<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Michelson interferometer · BeamletOptics.jl</title><meta name="title" content="Michelson interferometer · BeamletOptics.jl"/><meta property="og:title" content="Michelson interferometer · BeamletOptics.jl"/><meta property="twitter:title" content="Michelson interferometer · BeamletOptics.jl"/><meta name="description" content="Documentation for BeamletOptics.jl."/><meta property="og:description" content="Documentation for BeamletOptics.jl."/><meta property="twitter:description" content="Documentation for BeamletOptics.jl."/><meta property="og:url" content="https://StackEnjoyer.github.io/BeamletOptics.jl/tutorials/michelson/"/><meta property="twitter:url" content="https://StackEnjoyer.github.io/BeamletOptics.jl/tutorials/michelson/"/><link rel="canonical" href="https://StackEnjoyer.github.io/BeamletOptics.jl/tutorials/michelson/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="BeamletOptics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="BeamletOptics.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../expander/">Beam expander</a></li><li><a class="tocitem" href="../microscope/">Miniature microscope</a></li><li class="is-active"><a class="tocitem" href>Michelson interferometer</a><ul class="internal"><li><a class="tocitem" href="#How-to-follow-this-tutorial"><span>How to follow this tutorial</span></a></li><li><a class="tocitem" href="#Building-the-optical-system"><span>Building the optical system</span></a></li><li><a class="tocitem" href="#HeNe-laser-source"><span>HeNe laser source</span></a></li><li><a class="tocitem" href="#Calculating-beam-parameters"><span>Calculating beam parameters</span></a></li><li><a class="tocitem" href="#Setting-up-a-mirror"><span>Setting up a mirror</span></a></li><li><a class="tocitem" href="#Placing-the-beamsplitter"><span>Placing the beamsplitter</span></a></li><li><a class="tocitem" href="#Adding-the-detector"><span>Adding the detector</span></a></li><li><a class="tocitem" href="#Visualizing-the-fringes"><span>Visualizing the fringes</span></a></li><li><a class="tocitem" href="#Running-successive-simulations"><span>Running successive simulations</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/spherical_lenses/">Spherical lenses</a></li><li><a class="tocitem" href="../../examples/aspherical_lenses/">Aspherical lenses</a></li><li><a class="tocitem" href="../../examples/double_gauss/">Double Gauss lens</a></li><li><a class="tocitem" href="../../examples/lens_groups/">Lens groups</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/intro/">Introduction</a></li><li><a class="tocitem" href="../../basics/rays/">Rays</a></li><li><a class="tocitem" href="../../basics/beams/">Beams</a></li><li><a class="tocitem" href="../../basics/elements/">Optical elements</a></li><li><a class="tocitem" href="../../basics/systems/">Optical systems</a></li><li><a class="tocitem" href="../../basics/render/">Visualization</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../../components/components/">Overview</a></li><li><a class="tocitem" href="../../components/mirrors/">Mirrors</a></li><li><a class="tocitem" href="../../components/lenses/">Lenses</a></li><li><a class="tocitem" href="../../components/beamsplitters/">Beamsplitters</a></li><li><a class="tocitem" href="../../components/detectors/">Detectors</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../guide/">Dev. guide</a></li><li><a class="tocitem" href="../../design/">API design</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Michelson interferometer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Michelson interferometer</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/StackEnjoyer/BeamletOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/master/docs/src/tutorials/michelson.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Michelson-interferometer"><a class="docs-heading-anchor" href="#Michelson-interferometer">Michelson interferometer</a><a id="Michelson-interferometer-1"></a><a class="docs-heading-anchor-permalink" href="#Michelson-interferometer" title="Permalink"></a></h1><p>In this tutorial, a simple <a href="https://www.rp-photonics.com/michelson_interferometers.html">Michelson Interferometer</a> will be built step by step, using some core functions and components of this package. You will learn how to:</p><ol><li>Define a simple laser source representation (i.e. a <a href="../../reference/#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a>).</li><li>Create and position optical elements (splitter, mirrors).</li><li>Add a <a href="../../reference/#BeamletOptics.Photodetector"><code>Photodetector</code></a> to capture interference patterns.</li><li>Run a simple simulation featuring moving components</li></ol><p><img src="../mi_intro_fig.png" alt="Intro figure"/></p><div class="admonition is-info" id="Makie-5a393e1baf94730f"><header class="admonition-header">Makie<a class="admonition-anchor" href="#Makie-5a393e1baf94730f" title="Permalink"></a></header><div class="admonition-body"><p>This package uses <a href="https://github.com/MakieOrg/Makie.jl">Makie</a> for visualization purposes. However, it is not imported directly as part of this package. You must install it manually e.g. via <code>] add GLMakie</code> into your current project environment. When both Makie and this package are loaded – that is via <code>using GLMakie, BeamletOptics</code> – the Makie extension of this package will become available.</p></div></div><h2 id="How-to-follow-this-tutorial"><a class="docs-heading-anchor" href="#How-to-follow-this-tutorial">How to follow this tutorial</a><a id="How-to-follow-this-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-follow-this-tutorial" title="Permalink"></a></h2><p>All figures you will see below are pregenerated. The full code and all 3D assets are available in the following files:</p><pre><code class="language-julia hljs">using GLMakie, BeamletOptics

const BMO = BeamletOptics

GLMakie.activate!()

file_dir = joinpath(@__DIR__, &quot;..&quot;, &quot;assets&quot;, &quot;mi_assets&quot;)

include(joinpath(file_dir, &quot;michelson_showcase.jl&quot;))
include(joinpath(file_dir, &quot;michelson_plots.jl&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">┌ Info: </span></span>Files located at:
<span class="sgr36"><span class="sgr1">└ </span></span>  path = &quot;/home/runner/work/BeamletOptics.jl/BeamletOptics.jl/docs/build/assets/mi_assets&quot;</code></pre><p>If you want to reproduce the tutorial by yourself, it is recommend that you use the following plotting code:</p><pre><code class="language-julia hljs">using GLMakie, BeamletOptics

# assume that there is a defined &quot;system&quot; and solved &quot;beam&quot;

fig = Figure()
ax = LScene(fig[1,1])
render!(ax, system)
render!(ax, beam, flen=1e-2)</code></pre><p>The <code>flen</code> keyword sets the plotted length of &quot;infinite&quot; beams to 10 cm. Using the <code>LScene</code> environment will allow for easy viewing of the optical system and beam path. When the <code>system</code> or <code>beam</code> change, the plot will not update automatically. Rerunning the plot code above is necessary in this case.</p><h3 id="Specific-constants-and-functions"><a class="docs-heading-anchor" href="#Specific-constants-and-functions">Specific constants and functions</a><a id="Specific-constants-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-constants-and-functions" title="Permalink"></a></h3><p>For the context of this tutorial, the following constants and helper functions have been defined in the <code>michelson_showcase.jl</code> file</p><ul><li><code>cm</code>: corresponds to 1e-2 m</li><li><code>mm</code>: corresponds to 1e-3 m</li><li><code>reset_beamlet</code>: a helper function that resets an already solved <code>GaussianBeamlet</code> beam path to its initial position and direction</li></ul><h2 id="Building-the-optical-system"><a class="docs-heading-anchor" href="#Building-the-optical-system">Building the optical system</a><a id="Building-the-optical-system-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-optical-system" title="Permalink"></a></h2><p>The optomechanical interferometer setup that will be shown below has been created in a CAD program using components from the <a href="https://www.thorlabs.com/">Thorlabs</a> product catalog. The parts were then exported in the <code>.stl</code> format in order to render them with Makie. It is important to note that they are for illustrations purposes only. The code used to load the optomechanical parts and position them in order to form the full interferometer setup can be found in the <code>michelson_showcase.jl</code> file. A step by step explanation for each component group can be found in the following sections.</p><h2 id="HeNe-laser-source"><a class="docs-heading-anchor" href="#HeNe-laser-source">HeNe laser source</a><a id="HeNe-laser-source-1"></a><a class="docs-heading-anchor-permalink" href="#HeNe-laser-source" title="Permalink"></a></h2><p>The laser source for this interferometer will be a HeNe laser, e.g. the <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=HRS015B">HRS015B</a>. The manufacturer data specifies the following parameters:</p><ul><li>wavelength <code>λ ≈ 632.8 nm</code></li><li>waist diameter <code>d0 ≈ 0.65 mm</code></li><li>beam divergence angle <code>θ ≈ 1.4 mrad</code></li></ul><p>To represent the HeNe beam in code, we use the <a href="../../reference/#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> with parameters derived from the manufacturer data. The snippet below demonstrates how to initialize the beam. We can calculate the ideal divergence angle of the beam for the given wavelength and waist diameter and derive the <a href="https://www.rp-photonics.com/beam_quality.html">beam quality factor M²</a> from there.</p><pre><code class="language-julia hljs">λ = 632.8e-9
w0 = 0.65e-3 / 2

θ_ideal = BeamletOptics.divergence_angle(λ, w0, 1) * 1e3

M2 = 1.4 / θ_ideal

beam = GaussianBeamlet(
    [0.0, 0.0, 0.0],   # Beam origin
    [0.0, 1.0, 0.0],   # Propagation direction (y-axis in this example)
    λ,
    w0;
    M2
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">┌ Info: </span></span>Beam quality factor is:
<span class="sgr36"><span class="sgr1">└ </span></span>  M2 = 2.258888523045758</code></pre><p>Below you can find a rendering of the <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=HRS015B">HRS015B</a> laser in a <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=HCM2A/M">HCM2A/M</a> cage mount, illustrating how the laser tube and output beam might appear in your optical setup. For the purpose of this tutorial the beam spawn point is set at the center of the laser mount and aligned with its central axis. This might not be the case in practice. </p><p><img src="../mi_laser_assembly.png" alt="HeNe laser"/></p><div class="admonition is-info" id="Simulation-constraints-d6e9a2257dd0c7f1"><header class="admonition-header">Simulation constraints<a class="admonition-anchor" href="#Simulation-constraints-d6e9a2257dd0c7f1" title="Permalink"></a></header><div class="admonition-body"><p>It is important to note that the use of a single <a href="../../reference/#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> for the interferometer model places some constraints on the fidelity of the simulation. That is, the effects of spherical abberations, polarization abberations and astigmatism can not be fully or correctly captured. Refer to the <a href="../../basics/beams/#Gaussian-beamlet">Gaussian beamlet</a> section for more information. </p></div></div><h2 id="Calculating-beam-parameters"><a class="docs-heading-anchor" href="#Calculating-beam-parameters">Calculating beam parameters</a><a id="Calculating-beam-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-beam-parameters" title="Permalink"></a></h2><p>To gain deeper insight into the evolution of the Gaussian beam as it propagates, you can use the <a href="../../reference/#BeamletOptics.gauss_parameters-Tuple{GaussianBeamlet, Real}"><code>BeamletOptics.gauss_parameters</code></a> function. This function computes several key metrics at a series of positions along the beam optical axis:</p><pre><code class="language-julia hljs">zs = 0:1e-3:50cm
w, R, ψ, ~ = BeamletOptics.gauss_parameters(beam, zs)</code></pre><p>The returned values are</p><ul><li><code>w</code>: Beam radius (1/e² intensity radius) at each position z.</li><li><code>R</code>: Wavefront curvature</li><li><code>ψ</code>: Gouy phase, which quantifies the phase shift relative to a plane wave.</li></ul><p>The figure below shows a plot of the beam radius as a function of the propagation distance <code>z</code> (the beam is actually aligned with the y-axis for the beam simulation). The solid red curve indicates the beam’s upper waist boundary, while the dashed red curve (below the optical axis) shows its symmetric lower boundary. As the beam propagates, you can see how the waist gradually expands due to combined effects of wave and ray optics.</p><p><img src="../mi_waist_curve.png" alt="Waist curve"/></p><h2 id="Setting-up-a-mirror"><a class="docs-heading-anchor" href="#Setting-up-a-mirror">Setting up a mirror</a><a id="Setting-up-a-mirror-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-mirror" title="Permalink"></a></h2><p>In many optical systems, you will need to position mirrors to adjust the path of a beam through an optical system. In this example, we will use a <a href="../../reference/#BeamletOptics.RightAnglePrismMirror"><code>RightAnglePrismMirror</code></a> and place it in our system. By using the kinematic API, one can easily rotate and translate the prism to the desired position. Note that the mirror is spawned at the global origin.</p><pre><code class="language-julia hljs"># Spawn and move the mirror into position
rpm = RightAnglePrismMirror(25e-3, 25e-3)
zrotate3d!(rpm, deg2rad(45))       # rotate the mirror counter-clockwise by 45° around the global z-axis
translate3d!(rpm, [0,23.5cm,0])    # translate the mirror by 33.5 cm along the global y-axis

system = System([rpm])

solve_system!(system, beam)</code></pre><p>Once the mirror is in place, we can run the simulation to see how the beam interacts with the newly positioned mirror using the <a href="../../basics/systems/#BeamletOptics.solve_system!-basics-systems"><code>solve_system!</code></a> function. Below is a visualization of the setup, showing the HeNe laser and the right-angle prism mirror mounted in a <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=CCM1-P01/M">CCM1-P01/M</a> cage mount.</p><p><img src="../mi_corner_mirror.png" alt="Right angle prism mirror"/></p><h2 id="Placing-the-beamsplitter"><a class="docs-heading-anchor" href="#Placing-the-beamsplitter">Placing the beamsplitter</a><a id="Placing-the-beamsplitter-1"></a><a class="docs-heading-anchor-permalink" href="#Placing-the-beamsplitter" title="Permalink"></a></h2><p>The beamsplitter splits the beam into a reference and probe beam path. In this step, a 1&quot; <a href="../../reference/#BeamletOptics.CubeBeamsplitter"><code>CubeBeamsplitter</code></a> with a splitting ratio of 50% will be placed within the system, along with the previously defined mirror. Refer to the <a href="../../components/beamsplitters/#Cube-beamsplitter">Cube beamsplitter</a> section for more information. We also reset the beam to ensure we start from its original parameters before propagation through the new configuration:</p><pre><code class="language-julia hljs">reset_beamlet!(beam)

# define NBK7 ref. index for λ
NBK7 = DiscreteRefractiveIndex([632.8e-9], [1.51509])

cbs = CubeBeamsplitter(BeamletOptics.inch, NBK7)

# move splitter into position
zrotate3d!(cbs, deg2rad(-90))
translate_to3d!(cbs, [18.81cm, 23.5cm, 0])

system = System([rpm, cbs])

solve_system!(system, beam)</code></pre><p>The following image shows the <code>cbs</code>, e.g. a cage-mounted <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=CCM1-BS013/M">BS013</a>, and the resulting reflected and transmitted beams.</p><p><img src="../mi_beamsplitter.png" alt="Cube beamsplitter"/></p><p>By adding two additional <a href="../../reference/#BeamletOptics.RoundPlanoMirror"><code>RoundPlanoMirror</code></a>s that reflect the beams back into themselves we can overlay the probe and reference beam after they pass the <code>cbs</code> again.</p><pre><code class="language-julia hljs">m1 = RoundPlanoMirror(BeamletOptics.inch, 5e-3)
m2 = RoundPlanoMirror(BeamletOptics.inch, 5e-3)

# Move and turn mirror 1
zrotate3d!(m1, deg2rad(-90))
translate3d!(m1, [42.715cm, 23.5cm, 0])

# Move mirror 2
translate3d!(m2, [18.81cm, 37.405cm, 0])

system = System([rpm, cbs, m1, m2])
solve_system!(system, beam)</code></pre><p>The following figure shows two 1&quot; mirrors mounted in <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=KC1L/M">KC1L/M</a> kinematic mounts. Note that while the realigned return probe and reference beams exit the interferometer, a part of the light is involuntarily reflected back into the laser itself.</p><p><img src="../mi_arms.png" alt="Interferometer arms"/></p><h2 id="Adding-the-detector"><a class="docs-heading-anchor" href="#Adding-the-detector">Adding the detector</a><a id="Adding-the-detector-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-the-detector" title="Permalink"></a></h2><p>The final step in creating a functional interferometer simulation is to add a <a href="../../reference/#BeamletOptics.Photodetector"><code>Photodetector</code></a> that captures the field data of the incoming beamlets.</p><pre><code class="language-julia hljs">reset_beamlet!(beam)

# define detector with 8x8 mm active area and 200x200 resolution
pd = Photodetector(8e-3, 200)

# move detector into position
translate_to3d!(pd, [18.81cm, 9.595cm, 0])

system = System([rpm, cbs, m1, m2, pd])

solve_system!(system, beam)</code></pre><p>Below you can find a rendering of the interferometer with the <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=PDA10A2">PDA10A2</a> Si-detector. The device is connected to the cage system with a <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=SM1L30C">SM1L30C</a> lens tube and a <a href="https://www.thorlabs.com/thorproduct.cfm?partnumber=CP33T/M">CP33T/M</a> adapter. Once the <code>solve_system!</code> command has been executed, you can inspect the detector’s data to observe interference fringes and measure optical power. This typically involves examining the detector’s stored field array, which will be discussed in the next section.</p><p><img src="../mi_pd.png" alt="Photodetector"/></p><p>With the detector in place, the Michelson interferometer is now fully &quot;operational&quot;. You can adjust mirror positions, beamsplitter properties, or laser parameters to explore how each change influences the simulations results and gain hands-on experience with the capabilities of this package.</p><h2 id="Visualizing-the-fringes"><a class="docs-heading-anchor" href="#Visualizing-the-fringes">Visualizing the fringes</a><a id="Visualizing-the-fringes-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-fringes" title="Permalink"></a></h2><p>Once the beam has been split, reflected, and recombined on the <code>pd</code>, you can visualize the resulting intensity distribution to observe interference effects. In many interferometer setups, small adjustments – such as rotating a mirror or slightly shifting its position – introduce a spatial difference between the wavefronts of the beams, causing interference fringes to appear. Below is a comparison of the photodetector’s intensity data before (left) and after a slight rotation of mirror <code>m1</code> by 1 mrad (right). Initially, the wavefronts may overlap closely in space, producing a relatively uniform spot. After rotation, the mismatch occurs, creating a series of bright and dark fringes due to constructive and destructive interference:</p><p><img src="../mi_fringes.png" alt="Interferometer fringes"/></p><p>You can recreate this figure by running the following code:</p><pre><code class="language-julia hljs">fringes_fig = Figure()
heat1 = Axis(fringes_fig[1, 1], aspect=1)
heat2 = Axis(fringes_fig[1, 2], aspect=1)

hm = heatmap!(heat1, pd.x, pd.y, BeamletOptics.intensity(pd), colormap=:viridis)

# rotate m1, reset pd field data, resolve system
zrotate3d!(m1, 1e-3)
empty!(pd)
solve_system!(system, beam)

hm = heatmap!(heat2, pd.x, pd.y, BeamletOptics.intensity(pd), colormap=:viridis)</code></pre><p>By experimenting with different mirror angles, arm lengths, or beamsplitter properties, you can observe how interference fringes evolve and gain insights into the stability and sensitivity of the interferometric setup. This can be important to optimize alignment and achieve high contrast fringes.</p><div class="admonition is-info" id="Statefulness-4efe02c03a818176"><header class="admonition-header">Statefulness<a class="admonition-anchor" href="#Statefulness-4efe02c03a818176" title="Permalink"></a></header><div class="admonition-body"><p>Many steps of the simulation process mutate the data structures of the <code>system</code> and <code>beam</code>. If you run the above code multiple times odd effects might occur, since with each run the mirror is moved by one mrad. This is also important for the use of the correct use of the detector via the <a href="../../reference/#Base.empty!-Tuple{D} where D&lt;:BeamletOptics.AbstractDetector"><code>empty!</code></a> function. For more information, refer to the <a href="../../components/detectors/#Detectors">Detectors</a> chapter.</p></div></div><h2 id="Running-successive-simulations"><a class="docs-heading-anchor" href="#Running-successive-simulations">Running successive simulations</a><a id="Running-successive-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Running-successive-simulations" title="Permalink"></a></h2><p>Finally, we will run a sequence of &quot;single-shot&quot; simulations where we capture the integrated optical power on the photodetector for each step. This will allows us to simulate the kinematic behavior of the system. For this example, we will translate the mirror <code>m2</code> along the y-axis and investigate the resulting power signal. In order to achieve this, we translate <code>m2</code> in tiny increments via the <a href="../../reference/#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>translate3d!</code></a> function. However, first we reset the rotation of <code>m1</code> introduced in the previous section in order to increase the interferometric contrast again. The code for this part of the tutorial looks as follows:</p><pre><code class="language-julia hljs"># reset the 1 mrad z-axis rotation from the prev. section
zrotate3d!(m1, -1e-3)

# calculate the translation step for a total mirror movement of one wavelength λ
n = 100
Δy = λ/n

# Allocate optical power result vector
P = zeros(n+1)

# Run sim
for i in eachindex(P)
    empty!(pd)
    solve_system!(system, beam)
    P[i] = BeamletOptics.optical_power(pd)
    # translate by Δy
    translate3d!(m2, [0, Δy, 0])
end

# x-axis values
ys = LinRange(0, n*Δy, n+1)

# plot Figure
power_fig = Figure(size=(600, 250))
power_ax = Axis(power_fig[1, 1], xlabel=&quot;Δy [nm]&quot;, ylabel=&quot;P [mW]&quot;,)

lines!(power_ax, ys*1e9, P*1e3, color=:red)
vlines!(power_ax, λ*1e9, color=:red, linestyle=:dashdot)

ylims!(power_ax, 0, 1)</code></pre><p>Below is the resulting figure, illustrating the power oscillation as the mirror translates from its starting position to Δy = λ, marked by the dashed red line. It can be observed that the optical power does not reach 0 mW or the full 1 mW of the input laser power. This is because of the slight difference in arm length between the probe and reference beams. Also, the resulting power curve features two periods whereas the translation only corresponds to a movement of one wavelength. This is because the mirror movement by a single Δy step will cause a total increase of 2 ⋅ Δy in path length difference.</p><p><img src="../mi_powerplot.png" alt="Detector power curve"/></p><div class="admonition is-success" id="Two-color-interferometry-13343c35f973eb22"><header class="admonition-header">Two-color interferometry<a class="admonition-anchor" href="#Two-color-interferometry-13343c35f973eb22" title="Permalink"></a></header><div class="admonition-body"><p>For a much more sophisticated simulation example, refer to the master&#39;s thesis of Manny (2024) [<a href="../../reference/#Manny:2024">2</a>]. It is publicly available <a href="https://elib.dlr.de/211867/">here</a>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../microscope/">« Miniature microscope</a><a class="docs-footer-nextpage" href="../../examples/spherical_lenses/">Spherical lenses »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Friday 13 June 2025 11:10">Friday 13 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
