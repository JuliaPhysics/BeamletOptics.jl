var documenterSearchIndex = {"docs":
[{"location":"components/detectors/#Detectors","page":"Detectors","title":"Detectors","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"Detectors provide a way to evaluate beam data during optical simulations. They are designed to accumulate e.g. field data, enabling analysis of intensity distributions, interference patterns, and other beam properties.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"Detectors are supposed to fall under the BeamletOptics.AbstractDetector type, which defines a interface for detector implementations.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"warning: Resetting detectors\nIn general, the data stored in a detector is not automatically reset between calls of solve_system!. This task is placed within the responsibility of the user. A detector reset can be performed with the empty! function.","category":"page"},{"location":"components/detectors/#Photodetector-type","page":"Detectors","title":"Photodetector type","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"A concrete implementation to \"measure\" intensity distributions generated by a GaussianBeamlet is provided in the form of the Photodetector:","category":"page"},{"location":"components/detectors/#BeamletOptics.Photodetector-Tuple{Real, Int64}-components-detectors","page":"Detectors","title":"BeamletOptics.Photodetector","text":"Photodetector(width, n)\n\nSpawns a quadratic rectangular 2D Photodetector that is aligned with the positive y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\nn: field discretization factor, higher results in more computational cost\n\n\n\n\n\n","category":"method"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"asset_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(asset_dir, \"photodetector_showcase.jl\"))\n\nsave(\"fringes_showcase.png\", fringes_fig, px_per_unit=4)\nsave(\"pd_showcase.png\", detector_fig, px_per_unit=4)\n\nnothing","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"The interact3d model of the Photodetector can store complex electric field (E-field) values from intersecting GaussianBeamlets, enabling the reconstruction of spatial intensity distribution across its active surface. This data can be used to calculate e.g. beam interference patterns via the intensity function. The BeamletOptics.optical_power method can be used in order to obtain the total optical power at the detector. Below a rendered example of a detector model (FDS010) can be seen. The detector active area is marked in blue (1x1 mm²). ","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Photodetector showcase)","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"One of the use cases of the Photodetector is to analyse interference patterns. The figure below demonstrates an example intensity distribution captured by the detector pictured above, showing radial fringes due to a mismatch of the radii of curvature of the interfering GaussianBeamlets.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"tip: Interferometer tutorial\nRefer to the Michelson interferometer section for a detailed tutorial on how to use the Photodetector.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Interference fringes showcase)","category":"page"},{"location":"components/detectors/#Spotdetector-type","page":"Detectors","title":"Spotdetector type","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"A straight forward detector that stores the BeamletOptics.Intersection position of an incoming Beam. The Spotdetector can be used to generate spot diagrams, which are commonly used to perform initial assessments of the optical performance of an imaging setup.","category":"page"},{"location":"components/detectors/#BeamletOptics.Spotdetector-Tuple{AbstractFloat}-components-detectors","page":"Detectors","title":"BeamletOptics.Spotdetector","text":"Spotdetector(width)\n\nGenerates a quadratic rectangular 2D Spotdetector that is aligned with the negative y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\n\n\n\n\n\n","category":"method"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"asset_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(asset_dir, \"spotdetector_showcase.jl\"))\n\nsave(\"spot_diagram_system.png\", system_fig, px_per_unit=4)\nsave(\"spot_diagram_showcase.png\", spot_fig, px_per_unit=4)\n\nnothing","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"Below an optical system consisting of a collection of collimated Beams passing through a ThinLens is shown. A Spotdetector is positioned at the approximate focal plane to capture the resulting spot diagram.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Thin lens setup)","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"The beam bundle used to generate the spot diagram was created via the CollimatedSource constructor. The resulting spot diagram of the lens shown above is visualized below.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Spot diagram showcase)","category":"page"},{"location":"components/detectors/#Point-spread-function-detector-type","page":"Detectors","title":"Point-spread-function detector type","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"warning: Experimental feature\nThe point spread function estimation is a highly experimental feature. It does not use pupils (yet) but merely uses superposition of the ray-attached plane-waves. While this gives qualitatively sound results, it requires good sampling of the problem to obtain quantitatively good results. Currently no Strehl-ratio is calculated due to that.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"The package offers a simple method to estimate the point spread function of a system. It is  currently limited and requires careful assessment by the user, if the results are to be trusted.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"To analyze the PSF of a imaging system a PSFDetector is added to the system at the plane and orientation where the PSF is requested. This is the same approach as for the other detector types.","category":"page"},{"location":"components/detectors/#BeamletOptics.PSFDetector-Tuple{Real}-components-detectors","page":"Detectors","title":"BeamletOptics.PSFDetector","text":"Photodetector(width)\n\nSpawns a quadratic rectangular 2D PSFDetector that is aligned with the positive y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\n\n\n\n\n\n","category":"method"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"The intensity map together with the coordinate system of the detector can be retrieved after solving the system by calling the intensity function.","category":"page"},{"location":"components/detectors/#BeamletOptics.intensity-Tuple{PSFDetector}-components-detectors","page":"Detectors","title":"BeamletOptics.intensity","text":"intensity(psf::PSFDetector{T};\n          n::Int=100,\n          crop_factor::Real=1,\n          center::Symbol=:centroid,\n          x_min = Inf,\n          x_max = Inf,\n          z_min = Inf,\n          z_max = Inf,\n          x0_shift::Real=0,\n          z0_shift::Real=0) where T\n\nCompute the two‐dimensional point‐spread function (PSF) of an optical system as captured by a PSFDetector.  The returned intensity map is sampled on a regular n×n grid in the detector’s local (x,z)-plane.\n\nKeyword Arguments\n\nn::Int=100 Number of sample points per axis.\ncrop_factor::Real=1 Scales the half‐width of the sampling window returned by calc_local_lims; values >1 expand, <1 shrink.\ncenter::Symbol=:centroid How the sampling window is centred. :centroid uses the projection‑weighted centroid, :bbox uses the geometric mid‑point of the bounding box.\nx_min, x_max, z_min, z_max Manually override the sampling bounds in the local x or z directions. If left as Inf, the bounds from calc_local_lims are used.\nx0_shift::Real=0, z0_shift::Real=0 Apply a constant offset to the entire x or z coordinate arrays, useful for recentring or testing alignment.\n\nReturns\n\nA tuple (xs, zs, I) where\n\nxs::LinRange{T} and zs::LinRange{T} are the sampled coordinates in the detector’s local x and z axes,\nI::Matrix{T} is the corresponding raw/unscaled intensity map\n\nnote: Resetting detectors\nBe sure to call empty!(psf) before each new measurement if reusing the same detector.\n\nnote: Scaling\nThe returned values are raw/unscaled and not a Strehl ratio. This feature is not yet added. In future versions a pupil finder along with a Strehl estimator will be added.\n\n\n\n\n\n","category":"method"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"warning: Warning\nWhen dealing with a collimated source as the input to your optical system, where you want to calculate the PSF, DO NOT use the CollimatedSource beam group directly but instead use the UniformDiscSource constructor. This function returns a CollimatedSource with an equal-area sampling, which correctly weights the outer beams in relation to the inner beams. Otherwise the results might be wrong.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"asset_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(asset_dir, \"psfdetector_showcase.jl\"))\n\nsave(\"psf_airy_showcase.png\", fringes_fig, px_per_unit=4)\nsave(\"psf_tilted_showcase.png\", asph_fig, px_per_unit=4)\n\nnothing","category":"page"},{"location":"components/detectors/#Airy-Disc-Example","page":"Detectors","title":"Airy-Disc Example","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"This is a classic example where a collimated circular beam is imaged onto a point by a singlet lens. Due to the finite size of the aperture stop (in this case given by the 15 mm size of the beam), the diffraction limited intensity pattern is given by the Airy-disc:","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"I(r)=I_0leftfrac2J_1bigl(pi D r(lambda f)bigr)pi D r(lambda f)right^2","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"With r the radius from the origin, I_0 the maximum intensity, J_1 the Bessel function of the first kind of order one, D the aperture width, lambda the wavelength and the focal length f.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"# example parameters\nl = 1e-3\nR1 = 100e-3\nR2 = Inf\nd = 25.4e-3\nn = 1.5\nλ = 1e-6\n\n# generate uniform source, lens and PSF detector\ncs = UniformDiscSource([0, -10mm, 0], [0, 1, 0], 15e-3, λ)\nlens = SphericalLens(R1, R2, l, d, x -> n)\npsfd = PSFDetector(10e-3)\n\n# shift detector into focus\ntranslate3d!(psfd, [0, 200mm + 0.13mm, 0])\n\n# build system\nsys = System([lens, psfd])\n\nsolve_system!(sys, cs)\n\n# retrieve intensity\nx, z, I_num = intensity(psfd; n=500, crop_factor=5)","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"Visualizing the result yields the expected Airy-disk pattern.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Airy disc PSF)","category":"page"},{"location":"components/detectors/#Coma-and-Astigmatism-Example","page":"Detectors","title":"Coma and Astigmatism Example","text":"","category":"section"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"In this example, an aspheric lens images the collimated source onto a point but is tilted around the x-axis by 0.5 degrees. This results in aberrations distorting the stigmatic imaging and leading to coma and astigmatism.","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"k = -0.675\nd = 75.0e-3\nl = 15e-3\nradius = 76.68e-3\nA = [0*(1e3)^1, 2.7709219e-8*(1e3)^3, 6.418186e-13*(1e3)^5, -1.5724014e-17*(1e3)^7, -2.7768768e-21*(1e3)^9, -2.590162e-25*(1e3)^11]\nAL75150 = Lens(\n    EvenAsphericalSurface(radius, d, k, A),\n    l,\n    n -> 1.5006520430\n)\n\nxrotate3d!(AL75150, deg2rad(-0.5))\n\npd = PSFDetector(15e-3)\n\ntranslate3d!(pd, [0, 158.1779e-3, 0.0])\nsystem = System([AL75150, pd])\n\nps = UniformDiscSource([0, -0.1, 0], [0,1,0], 0.8*d, 1550e-9)\n\nsolve_system!(system, ps)","category":"page"},{"location":"components/detectors/","page":"Detectors","title":"Detectors","text":"(Image: Tilted asphere PSF)","category":"page"},{"location":"examples/lens_groups/#Lens-groups","page":"Lens groups","title":"Lens groups","text":"","category":"section"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"This example highlights the capabilities of ObjectGroups. Several groups of optics will be defined and then traced like an ordinary System of optical elements.","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"using CairoMakie, BeamletOptics\n\n# focus group\nl1 = SphericalDoubletLens(103.4371e-3, 61.14925e-3, -603.2959e-3, 1.5e-3, 10.03975e-3, 55e-3, 1.963000, 1.603112)\nl2 = SphericalLens(49.97282e-3, 168.2416e-3, 8.622723e-3, 52e-3, 1.603001)\n\nl_2 = BeamletOptics.thickness(l1) + 1e-4\ntranslate3d!(l2, [0, l_2, 0])\n\nfocus_group = ObjectGroup([l1, l2])\n\nnothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"# variator\nl3 = SphericalLens(100.3834e-3, 16.72327e-3, 1e-3, 28.00995e-3, λ -> 1.603112)\nl4 = SphericalLens(-30.28003e-3, 21.29033e-3, 0.5e-3, 22.31297e-3, λ -> 1.764500)\nl5 = SphericalLens(23.06904e-3, 243.5999e-3, 3.2e-3, 22.12162e-3, λ -> 1.963000)\n\nl_3 = l_2 + BeamletOptics.thickness(l2) + 1.1e-3\nl_4 = l_3 + BeamletOptics.thickness(l3) + 7.25496e-3\nl_5 = l_4 + BeamletOptics.thickness(l4) + 0.5e-3\ntranslate3d!(l3, [0, l_3, 0])\ntranslate3d!(l4, [0, l_4, 0])\ntranslate3d!(l5, [0, l_5, 0])\n\nvariator_group = ObjectGroup([l3, l4, l5])\n\nnothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"# compensator\nl6 = SphericalLens(-24.31747e-3, -255.5571e-3, 1e-3, 17.70449e-3, λ -> 1.638539)\ncompensator = l6\n\nl_6 = l_5 + BeamletOptics.thickness(l5) + 40.889e-3\ntranslate3d!(l6, [0, l_6, 0])\n\n# master I\nl7 = SphericalLens(Inf, Inf, 1.2e-3, 19.896e-3, λ -> 1.516330)\nl8 = SphericalLens(1207.65e-3, -28.39078e-3, 2.4e-3, 21.05932e-3, λ -> 1.583126)\nl9 = SphericalLens(74.34233e-3, -62.52319e-3, 2.4e-3, 21.61478e-3, λ -> 1.570989)\nl10 = SphericalLens(42.10459e-3, -128.0055e-3, 2.4e-3, 20.88128e-3, λ -> 1.583126)\nl11 = SphericalLens(28.62223e-3, 378.3789e-3, 2.4e-3, 19.26452e-3, λ -> 1.651000)\nl12 = SphericalLens(-40.92189e-3, 41.10496e-3, 1e-3, 18.17719e-3, λ -> 1.854779)\n\nl_7 = l_6 + BeamletOptics.thickness(l6) + 4.765141e-3\nl_8 = l_7 + BeamletOptics.thickness(l7) + 1e-3\nl_9 = l_8 + BeamletOptics.thickness(l8) + 0.2e-3\nl_10 = l_9 + BeamletOptics.thickness(l9) + 1e-3\nl_11 = l_10 + BeamletOptics.thickness(l10) + 0.1e-3\nl_12 = l_11 + BeamletOptics.thickness(l11) + 1.583061e-3\ntranslate3d!(l7, [0, l_7, 0])\ntranslate3d!(l8, [0, l_8, 0])\ntranslate3d!(l9, [0, l_9, 0])\ntranslate3d!(l10, [0, l_10, 0])\ntranslate3d!(l11, [0, l_11, 0])\ntranslate3d!(l12, [0, l_12, 0])\n\nmaster_group_I = ObjectGroup([l7, l8, l9, l10, l11, l12])\n\nnothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"# master II\nl13 = SphericalLens(34.65626e-3, -45.71147e-3, 2.4e-3, 15.6e-3, λ -> 1.762001)\nl14 = SphericalLens(27.08863e-3, 11.38107e-3, 1e-3, 14.40932e-3, λ -> 1.761821)\nl15 = SphericalLens(20.49712e-3, -203.9304e-3, 2.4e-3, 14.40932e-3, λ -> 1.693501)\nl16 = SphericalLens(Inf, Inf, 4e-3, 12.92286e-3, λ -> 1.522494)\n\nl_13 = l_12 + BeamletOptics.thickness(l12) + 11.97864e-3\nl_14 = l_13 + BeamletOptics.thickness(l13) + 0.1e-3\nl_15 = l_14 + BeamletOptics.thickness(l14) + 1.428573e-3\nl_16 = l_15 + BeamletOptics.thickness(l15) + 0.2e-3\ntranslate3d!(l13, [0, l_13, 0])\ntranslate3d!(l14, [0, l_14, 0])\ntranslate3d!(l15, [0, l_15, 0])\ntranslate3d!(l16, [0, l_16, 0])\n\nmaster_group_II = ObjectGroup([l13, l14, l15, l16])\n\nnothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"# zoom lens\nlens = ObjectGroup([focus_group, variator_group, compensator, master_group_I, master_group_II])\nsystem = System(lens)\n\nnothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"# generate render\nfig = Figure(size=(600, 380))\naspect = (1,2,1)\nlimits = (-0.05, 0.05, -0.05, 0.15, -0.05, 0.05)\nax = Axis3(fig[1, 1], aspect=aspect, limits=limits, azimuth=0, elevation=1e-3)\n# hide decorations for vis. purposes\nhidexdecorations!(ax)\nhidezdecorations!(ax)\n\nrender!(ax, system)\n\nfor z in LinRange(-0.003, 0.003, 5)\n    ray = Ray([0, -0.05, z], [0, 1.0, 0])\n    beam = Beam(ray)\n    solve_system!(system, beam, r_max=40)\n    render!(ax, beam, flen=0.1)\nend\n\nsave(\"lens_groups_0.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"(Image: Lens groups - no movement)","category":"page"},{"location":"examples/lens_groups/#Moving-groups","page":"Lens groups","title":"Moving groups","text":"","category":"section"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"Now the variator and compensator will be moved in order to simulate a zooming effect.","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"function compensator_movement(x)\n    if x < 0 || x > 42.75e-3\n        error(\"x out of bounds\")\n    end\n    return 1e3*0.01169*x^2 - 0.4155*x\nend\n\nΔx_variator = 40e-3\nΔx_compensator = compensator_movement(Δx_variator)\n\ntranslate3d!(variator_group, [0, Δx_variator, 0])\ntranslate3d!(compensator, [0, Δx_compensator, 0])\n\ndelete!(ax) # hide\nax = Axis3(fig[1, 1], aspect=aspect, limits=limits, azimuth=0, elevation=1e-3) # hide\nhidexdecorations!(ax) # hide\nhidezdecorations!(ax) # hide\n\nrender!(ax, system)\n\nfor z in LinRange(-0.022, 0.022, 5)\n    ray = Ray([0, -0.05, z], [0, 1.0, 0])\n    beam = Beam(ray)\n    solve_system!(system, beam, r_max=40)\n    render!(ax, beam, flen=0.1)\nend\n\nsave(\"lens_groups_1.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"(Image: Lens groups - with movement)","category":"page"},{"location":"examples/lens_groups/#Beam-type-compatibility","page":"Lens groups","title":"Beam type compatibility","text":"","category":"section"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"We can easily switch out the type of beam we are tracing through the system using the API of this package. We will trace a single GaussianBeamlet through the objective. Note that this example is for illustration purposes only and does not yield an accurate representation of the actual imaging preformance due to the limitations of the beam tracing method described in the Stigmatic Beamlets section.","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"delete!(ax) # hide\nax = Axis3(fig[1, 1], aspect=aspect, limits=limits, azimuth=0, elevation=1e-3) # hide\nhidexdecorations!(ax) # hide\nhidezdecorations!(ax) # hide\n\nbeam = GaussianBeamlet([0, -0.05, 0], [0, 1, 0], 1000e-9, 2.2e-2)\nsolve_system!(system, beam, r_max=40)\n\nrender!(ax, beam, color=:green2)\nrender!(ax, system)\n\nsave(\"lens_groups_2.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/lens_groups/","page":"Lens groups","title":"Lens groups","text":"(Image: Lens groups - with GaussianBeamlet)","category":"page"},{"location":"basics/rays/#Rays","page":"Rays","title":"Rays","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"Individual monochromatic rays form the basic building blocks to describe the propagation of light through an optical system using geometrical optics. In general, the ray path in the context of this package is described by ","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"vecx(t) = vecp + t cdot vecd","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"where vecp and vecd are the position and direction mathbbR^3-vectors, respectively. The ray length t is used to describe the geometrical length of the ray. This assumes that the BeamletOptics.RefractiveIndex along the ray path is constant. If after solving an optical system a ray intersection is determined, a new ray must be spawned to model an arbitrary light path. This data is stored, e.g., in a Beam. More on this can be found in the Beams chapter. ","category":"page"},{"location":"basics/rays/#Basic-Ray","page":"Rays","title":"Basic Ray","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"The generic type that describes geometrical rays is BeamletOptics.AbstractRay. Refer to its documentation for more information about what data is used to model light propagation. A minimal implementation of this API (i.e. subtype) is provided by the Ray:","category":"page"},{"location":"basics/rays/#BeamletOptics.Ray-basics-rays","page":"Rays","title":"BeamletOptics.Ray","text":"Ray{T} <: AbstractRay{T}\n\nMutable struct to store ray information.\n\nFields\n\npos: a point in R³ that describes the Ray origin\ndir: a normalized vector in R³ that describes the Ray direction\nintersection: refer to Intersection\nλ: wavelength in [m]\nn: refractive index along the beam path\n\n\n\n\n\n","category":"type"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"This ray type is able to model reflection and refraction, using Snell's law, within the limits of geometrical optics. A single ray only ever describes the optical path between its starting point and the closest intersection, e.g. the surface of a Lens. A visualization is shown below. The position of the Ray is stored in relation to a global coordinate system. The normed direction is indicated by the blue arrow. The Ray intersects with a shape and stores this data in the intersection field. This includes the length until the point of intersection (marked as a dashed blue line) and the normal vector at the intersected surface (marked by a black arrow). ","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"(Image: Basic ray plot)","category":"page"},{"location":"basics/rays/#Polarized-Rays","page":"Rays","title":"Polarized Rays","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"In order to model the effect of polarizing elements, the polarization ray tracing calculus of Yun et. al is used [3, 4]. This formalism allows to model the effects of said elements on the electric field vector E_0 using the Jones formalism in global coordinates:","category":"page"},{"location":"basics/rays/#BeamletOptics.PolarizedRay-basics-rays","page":"Rays","title":"BeamletOptics.PolarizedRay","text":"PolarizedRay{T} <: AbstractRay{T}\n\nA ray type to model the propagation of an electric field vector based on the publication:\n\nYun, Garam, Karlton Crabtree, and Russell A. Chipman. \"Three-dimensional polarization ray-tracing calculus I: definition and diattenuation.\" Applied optics 50.18 (2011): 2855-2865.\n\nThe geometrical ray description is identical to the standard Ray. The polarization interaction can be described in local s-p-coordinates but must be transformed into global coordinates using the method described in the publication above, see also _calculate_global_E0.\n\nFields\n\npos: a point in R³ that describes the Ray origin\ndir: a normalized vector in R³ that describes the Ray direction\nintersection: refer to Intersection\nλ: wavelength in [m]\nn: refractive index along the beam path\nE0: complex-valued 3-tuple to represent the electric field in global coordinates\n\nJones matrices\n\nIn local coordinates the Jones matrices in the case of reflection/refraction are defined as\n\nreflection: [-rₛ 0; 0 rₚ]\ntransmission: [tₛ 0; 0 tₚ]\n\nwhere r and t are the complex-valued Fresnel coefficients (see also fresnel_coefficients).\n\nAdditional information\n\nwarning: Field vector\nIt is assumed that the electric field vector E_0 stays orthogonal to the direction of propagation throughout the optical system.\n\nwarning: Intensity\nE0 can not be converted into an intensity value, since a single PolarizedRay can not directly model the change in intensity during imaging by an optical system.\n\n\n\n\n\n","category":"type"},{"location":"basics/rays/#Fresnel-coefficients","page":"Rays","title":"Fresnel coefficients","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"This package uses the equations of Fowles [5, p. 44] and Peatross [6, p. 78] to determine the Fresnel coefficents at a given surface where the PolarizedRay enters from a medium with (complex) refractive index n_1 into a medium with n_2. The ability to define coatings is currently not included. ","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"warning: Warning\nWhen a PolarizedRay interacts with a refractive medium, e.g. an BeamletOptics.AbstractRefractiveOptic, the default tracing behaviour is to only trace the refracted and ignore the reflected ray, unless Total Internal Reflection (TIR) occurs. ","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"Below the Fresnel coefficients for different n_1 rightarrow n_2 interfaces are listed to highlight the definition of signs used for this package.","category":"page"},{"location":"basics/rays/#Vacuum-to-glass","page":"Rays","title":"Vacuum to glass","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"First, the Fresnel coefficients for n_1 = 10 to n_2 = 15 will be calculated. The angle of incidence theta refers to the plane of incidence in the senkrecht and parallel coordinate system. Note that the imaginary part of the coefficents is shown by the dash-dotted lines.","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"using CairoMakie # hide\nCairoMakie.activate!() # hide\nusing BeamletOptics\ninclude(\"fresnel.jl\") # hide\n\n# Angle of incidence\nθ = deg2rad.(0:.01:90)\n\n# Define refractive indices - vacuum to glass\nn1 = 1.0\nn2 = 1.5\n\n# Calculate complex Fresnel coefficients\nrs, rp, ts, tp = BeamletOptics.fresnel_coefficients(θ, n2/n1)\n\nplot_and_save_fresnel_coeffs(n1, n2, save_fig=false) # hide","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"Note that for this example, the imaginary part of the coefficients is zero for all considered θs.","category":"page"},{"location":"basics/rays/#Glass-to-vacuum","page":"Rays","title":"Glass to vacuum","text":"","category":"section"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"For a glass-vacuum interface with n_1 = 15 to n_2 = 10 the coefficients are calculated likewise. Note the unsteadiness of the coefficients at around 40°. This is the critical angle where TIR occurs.","category":"page"},{"location":"basics/rays/","page":"Rays","title":"Rays","text":"# Define refractive indices - glass to vacuum\nn1 = 1.5\nn2 = 1.0\n\n# Calculate complex Fresnel coefficients\nrs, rp, ts, tp = BeamletOptics.fresnel_coefficients(θ, n2/n1)\n\nplot_and_save_fresnel_coeffs(n1, n2, save_fig=false) # hide","category":"page"},{"location":"tutorials/michelson/#Michelson-interferometer","page":"Michelson interferometer","title":"Michelson interferometer","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"In this tutorial, a simple Michelson Interferometer will be built step by step, using some core functions and components of this package. You will learn how to:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Define a simple laser source representation (i.e. a GaussianBeamlet).\nCreate and position optical elements (splitter, mirrors).\nAdd a Photodetector to capture interference patterns.\nRun a simple simulation featuring moving components","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Intro figure)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"info: Makie\nThis package uses Makie for visualization purposes. However, it is not imported directly as part of this package. You must install it manually e.g. via ] add GLMakie into your current project environment. When both Makie and this package are loaded – that is via using GLMakie, BeamletOptics – the Makie extension of this package will become available.","category":"page"},{"location":"tutorials/michelson/#How-to-follow-this-tutorial","page":"Michelson interferometer","title":"How to follow this tutorial","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"All figures you will see below are pregenerated. The full code and all 3D assets are available in the following files:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"using GLMakie, BeamletOptics\n\nconst BMO = BeamletOptics\n\nGLMakie.activate!()\n\nfile_dir = joinpath(@__DIR__, \"..\", \"assets\", \"mi_assets\")\n\ninclude(joinpath(file_dir, \"michelson_showcase.jl\"))\ninclude(joinpath(file_dir, \"michelson_plots.jl\"))\n\npath = normpath(file_dir) # hide\n@info \"Files located at:\" path # hide","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"If you want to reproduce the tutorial by yourself, it is recommend that you use the following plotting code:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"using GLMakie, BeamletOptics\n\n# assume that there is a defined \"system\" and solved \"beam\"\n\nfig = Figure()\nax = LScene(fig[1,1])\nrender!(ax, system)\nrender!(ax, beam, flen=1e-2)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The flen keyword sets the plotted length of \"infinite\" beams to 10 cm. Using the LScene environment will allow for easy viewing of the optical system and beam path. When the system or beam change, the plot will not update automatically. Rerunning the plot code above is necessary in this case.","category":"page"},{"location":"tutorials/michelson/#Specific-constants-and-functions","page":"Michelson interferometer","title":"Specific constants and functions","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"For the context of this tutorial, the following constants and helper functions have been defined in the michelson_showcase.jl file","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"cm: corresponds to 1e-2 m\nmm: corresponds to 1e-3 m\nreset_beamlet: a helper function that resets an already solved GaussianBeamlet beam path to its initial position and direction","category":"page"},{"location":"tutorials/michelson/#Building-the-optical-system","page":"Michelson interferometer","title":"Building the optical system","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The optomechanical interferometer setup that will be shown below has been created in a CAD program using components from the Thorlabs product catalog. The parts were then exported in the .stl format in order to render them with Makie. It is important to note that they are for illustrations purposes only. The code used to load the optomechanical parts and position them in order to form the full interferometer setup can be found in the michelson_showcase.jl file. A step by step explanation for each component group can be found in the following sections.","category":"page"},{"location":"tutorials/michelson/#HeNe-laser-source","page":"Michelson interferometer","title":"HeNe laser source","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The laser source for this interferometer will be a HeNe laser, e.g. the HRS015B. The manufacturer data specifies the following parameters:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"wavelength λ ≈ 632.8 nm\nwaist diameter d0 ≈ 0.65 mm\nbeam divergence full angle θ ≈ 1.4 mrad","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"To represent the HeNe beam in code, we use the GaussianBeamlet with parameters derived from the manufacturer data. The snippet below demonstrates how to initialize the beam. We can calculate the ideal divergence angle of the beam for the given wavelength and waist diameter and derive the beam quality factor M² from there.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"λ = 632.8e-9\nw0 = 0.65e-3 / 2\n\nθ_spec = 1.4e-3 / 2  # half-angle in mrad\nθ_ideal = BeamletOptics.divergence_angle(λ, w0, 1)\n\nM2 = θ_spec / θ_ideal\n\nbeam = GaussianBeamlet(\n    [0.0, 0.0, 0.0],   # Beam origin\n    [0.0, 1.0, 0.0],   # Propagation direction (y-axis in this example)\n    λ,\n    w0;\n    M2\n)\n\n@info \"Beam quality factor is:\" M2 # hide","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Below you can find a rendering of the HRS015B laser in a HCM2A/M cage mount, illustrating how the laser tube and output beam might appear in your optical setup. For the purpose of this tutorial the beam spawn point is set at the center of the laser mount and aligned with its central axis. This might not be the case in practice. ","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: HeNe laser)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"info: Simulation constraints\nIt is important to note that the use of a single GaussianBeamlet for the interferometer model places some constraints on the fidelity of the simulation. That is, the effects of spherical abberations, polarization abberations and astigmatism can not be fully or correctly captured. Refer to the Gaussian beamlet section for more information. ","category":"page"},{"location":"tutorials/michelson/#Calculating-beam-parameters","page":"Michelson interferometer","title":"Calculating beam parameters","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"To gain deeper insight into the evolution of the Gaussian beam as it propagates, you can use the BeamletOptics.gauss_parameters function. This function computes several key metrics at a series of positions along the beam optical axis:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"zs = 0:1e-3:50cm\nw, R, ψ, ~ = BeamletOptics.gauss_parameters(beam, zs)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The returned values are","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"w: Beam radius (1/e² intensity radius) at each position z.\nR: Wavefront curvature\nψ: Gouy phase, which quantifies the phase shift relative to a plane wave.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The figure below shows a plot of the beam radius as a function of the propagation distance z (the beam is actually aligned with the y-axis for the beam simulation). The solid red curve indicates the beam’s upper waist boundary, while the dashed red curve (below the optical axis) shows its symmetric lower boundary. As the beam propagates, you can see how the waist gradually expands due to combined effects of wave and ray optics.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Waist curve)","category":"page"},{"location":"tutorials/michelson/#Setting-up-a-mirror","page":"Michelson interferometer","title":"Setting up a mirror","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"In many optical systems, you will need to position mirrors to adjust the path of a beam through an optical system. In this example, we will use a RightAnglePrismMirror and place it in our system. By using the kinematic API, one can easily rotate and translate the prism to the desired position. Note that the mirror is spawned at the global origin.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"# Spawn and move the mirror into position\nrpm = RightAnglePrismMirror(25e-3, 25e-3)\nzrotate3d!(rpm, deg2rad(45))       # rotate the mirror counter-clockwise by 45° around the global z-axis\ntranslate3d!(rpm, [0,23.5cm,0])    # translate the mirror by 33.5 cm along the global y-axis\n\nsystem = System([rpm])\n\nsolve_system!(system, beam)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Once the mirror is in place, we can run the simulation to see how the beam interacts with the newly positioned mirror using the solve_system! function. Below is a visualization of the setup, showing the HeNe laser and the right-angle prism mirror mounted in a CCM1-P01/M cage mount.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Right angle prism mirror)","category":"page"},{"location":"tutorials/michelson/#Placing-the-beamsplitter","page":"Michelson interferometer","title":"Placing the beamsplitter","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The beamsplitter splits the beam into a reference and probe beam path. In this step, a 1\" CubeBeamsplitter with a splitting ratio of 50% will be placed within the system, along with the previously defined mirror. Refer to the Cube beamsplitter section for more information. We also reset the beam to ensure we start from its original parameters before propagation through the new configuration:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"reset_beamlet!(beam)\n\n# define NBK7 ref. index for λ\nNBK7 = DiscreteRefractiveIndex([632.8e-9], [1.51509])\n\ncbs = CubeBeamsplitter(BeamletOptics.inch, NBK7)\n\n# move splitter into position\nzrotate3d!(cbs, deg2rad(-90))\ntranslate_to3d!(cbs, [18.81cm, 23.5cm, 0])\n\nsystem = System([rpm, cbs])\n\nsolve_system!(system, beam)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The following image shows the cbs, e.g. a cage-mounted BS013, and the resulting reflected and transmitted beams.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Cube beamsplitter)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"By adding two additional RoundPlanoMirrors that reflect the beams back into themselves we can overlay the probe and reference beam after they pass the cbs again.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"m1 = RoundPlanoMirror(BeamletOptics.inch, 5e-3)\nm2 = RoundPlanoMirror(BeamletOptics.inch, 5e-3)\n\n# Move and turn mirror 1\nzrotate3d!(m1, deg2rad(-90))\ntranslate3d!(m1, [42.715cm, 23.5cm, 0])\n\n# Move mirror 2\ntranslate3d!(m2, [18.81cm, 37.405cm, 0])\n\nsystem = System([rpm, cbs, m1, m2])\nsolve_system!(system, beam)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The following figure shows two 1\" mirrors mounted in KC1L/M kinematic mounts. Note that while the realigned return probe and reference beams exit the interferometer, a part of the light is involuntarily reflected back into the laser itself.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Interferometer arms)","category":"page"},{"location":"tutorials/michelson/#Adding-the-detector","page":"Michelson interferometer","title":"Adding the detector","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"The final step in creating a functional interferometer simulation is to add a Photodetector that captures the field data of the incoming beamlets.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"reset_beamlet!(beam)\n\n# define detector with 8x8 mm active area and 200x200 resolution\npd = Photodetector(8e-3, 200)\n\n# move detector into position\ntranslate_to3d!(pd, [18.81cm, 9.595cm, 0])\n\nsystem = System([rpm, cbs, m1, m2, pd])\n\nsolve_system!(system, beam)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Below you can find a rendering of the interferometer with the PDA10A2 Si-detector. The device is connected to the cage system with a SM1L30C lens tube and a CP33T/M adapter. Once the solve_system! command has been executed, you can inspect the detector’s data to observe interference fringes and measure optical power. This typically involves examining the detector’s stored field array, which will be discussed in the next section.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Photodetector)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"With the detector in place, the Michelson interferometer is now fully \"operational\". You can adjust mirror positions, beamsplitter properties, or laser parameters to explore how each change influences the simulations results and gain hands-on experience with the capabilities of this package.","category":"page"},{"location":"tutorials/michelson/#Visualizing-the-fringes","page":"Michelson interferometer","title":"Visualizing the fringes","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Once the beam has been split, reflected, and recombined on the pd, you can visualize the resulting intensity distribution to observe interference effects. In many interferometer setups, small adjustments – such as rotating a mirror or slightly shifting its position – introduce a spatial difference between the wavefronts of the beams, causing interference fringes to appear. Below is a comparison of the photodetector’s intensity data before (left) and after a slight rotation of mirror m1 by 1 mrad (right). Initially, the wavefronts may overlap closely in space, producing a relatively uniform spot. After rotation, the mismatch occurs, creating a series of bright and dark fringes due to constructive and destructive interference:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Interferometer fringes)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"You can recreate this figure by running the following code:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"fringes_fig = Figure()\nheat1 = Axis(fringes_fig[1, 1], aspect=1)\nheat2 = Axis(fringes_fig[1, 2], aspect=1)\n\nhm = heatmap!(heat1, pd.x, pd.y, intensity(pd), colormap=:viridis)\n\n# rotate m1, reset pd field data, resolve system\nzrotate3d!(m1, 1e-3)\nempty!(pd)\nsolve_system!(system, beam)\n\nhm = heatmap!(heat2, pd.x, pd.y, intensity(pd), colormap=:viridis)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"By experimenting with different mirror angles, arm lengths, or beamsplitter properties, you can observe how interference fringes evolve and gain insights into the stability and sensitivity of the interferometric setup. This can be important to optimize alignment and achieve high contrast fringes.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"info: Statefulness\nMany steps of the simulation process mutate the data structures of the system and beam. If you run the above code multiple times odd effects might occur, since with each run the mirror is moved by one mrad. This is also important for the use of the correct use of the detector via the empty! function. For more information, refer to the Detectors chapter.","category":"page"},{"location":"tutorials/michelson/#Running-successive-simulations","page":"Michelson interferometer","title":"Running successive simulations","text":"","category":"section"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Finally, we will run a sequence of \"single-shot\" simulations where we capture the integrated optical power on the photodetector for each step. This will allows us to simulate the kinematic behavior of the system. For this example, we will translate the mirror m2 along the y-axis and investigate the resulting power signal. In order to achieve this, we translate m2 in tiny increments via the translate3d! function. However, first we reset the rotation of m1 introduced in the previous section in order to increase the interferometric contrast again. The code for this part of the tutorial looks as follows:","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"# reset the 1 mrad z-axis rotation from the prev. section\nzrotate3d!(m1, -1e-3)\n\n# calculate the translation step for a total mirror movement of one wavelength λ\nn = 100\nΔy = λ/n\n\n# Allocate optical power result vector\nP = zeros(n+1)\n\n# Run sim\nfor i in eachindex(P)\n    empty!(pd)\n    solve_system!(system, beam)\n    P[i] = BeamletOptics.optical_power(pd)\n    # translate by Δy\n    translate3d!(m2, [0, Δy, 0])\nend\n\n# x-axis values\nys = LinRange(0, n*Δy, n+1)\n\n# plot Figure\npower_fig = Figure(size=(600, 250))\npower_ax = Axis(power_fig[1, 1], xlabel=\"Δy [nm]\", ylabel=\"P [mW]\",)\n\nlines!(power_ax, ys*1e9, P*1e3, color=:red)\nvlines!(power_ax, λ*1e9, color=:red, linestyle=:dashdot)\n\nylims!(power_ax, 0, 1)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"Below is the resulting figure, illustrating the power oscillation as the mirror translates from its starting position to Δy = λ, marked by the dashed red line. It can be observed that the optical power does not reach 0 mW or the full 1 mW of the input laser power. This is because of the slight difference in arm length between the probe and reference beams. Also, the resulting power curve features two periods whereas the translation only corresponds to a movement of one wavelength. This is because the mirror movement by a single Δy step will cause a total increase of 2 ⋅ Δy in path length difference.","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"(Image: Detector power curve)","category":"page"},{"location":"tutorials/michelson/","page":"Michelson interferometer","title":"Michelson interferometer","text":"tip: Two-color interferometry\nFor a much more sophisticated simulation example, refer to the master's thesis of Manny (2024) [2]. It is publicly available here.","category":"page"},{"location":"examples/spherical_lenses/#Spherical-lens-example","page":"Spherical lenses","title":"Spherical lens example","text":"","category":"section"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"This example recreates the figure shown in the Spherical lenses section of the Lenses chapter. The lens parameters are taken from the Thorlabs website and are listed below:","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"Lenses (in order of appearance)\nLD1464\nLB1811\nLC1715\nLE1234\nLA1805","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"First a function is defined that returns the refractive index n(lambda) for the relevent wavelengths. ","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"using CairoMakie, BeamletOptics\n\nNBK7 = DiscreteRefractiveIndex([532e-9, 1064e-9], [1.5195, 1.5066])\n\nnothing # hide","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"Then the different spherical lenses referred to above are generated using the SphericalLens convenience constructor.","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"# lens diameter \nd = BeamletOptics.inch\n\n# lens types\nr1 = 34.9e-3\nr2 = -34.9e-3\nl = 6.8e-3\nLB1811 = SphericalLens(r1, r2, l, d, NBK7)\n\nr1 = Inf\nr2 = -15.5e-3\nl = 8.6e-3\nLA1805 = SphericalLens(r1, r2, l, d, NBK7)\n\nr1 = -52e-3\nr2 = 52e-3\nl = 3e-3\nLD1464 = SphericalLens(r1, r2, l, d, NBK7)\n\nr1 = Inf\nr2 = 25.7e-3\nl = 3.5e-3\nLC1715 = SphericalLens(r1, r2, l, d, NBK7)\n\nr1 = -82.2e-3\nr2 = -32.1e-3\nl = 3.6e-3\nLE1234 = SphericalLens(r1, r2, l, d, NBK7)\n\nnothing # hide","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"The lenses are then moved into arbitray positions along the y-axis for the showcase. A GaussianBeamlet with lambda = 532textnm and w_0 = 5textmm is used for this purpose.","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"translate3d!(LD1464, [0, 0*d, 0])\ntranslate3d!(LB1811, [0, 1*d, 0])\ntranslate3d!(LC1715, [0, 2*d, 0])\ntranslate3d!(LE1234, [0, 3*d, 0])\ntranslate3d!(LA1805, [0, 4*d, 0])\n\nsystem = StaticSystem([\n    LB1811,\n    LA1805,\n    LD1464,\n    LC1715,\n    LE1234\n])\n\nbeam = GaussianBeamlet([0, -0.05, 0], [0, 1, 0], 532e-9, 5e-3)\nsolve_system!(system, beam)\n\nnothing # hide","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"The following code will recreate the figure:","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"fig = Figure(size=(600,240))\naspect = (1,4,1)\nlimits = (-0.025, 0.025, -0.05, 0.15, -0.025, 0.025)\nax = Axis3(fig[1,1], aspect=aspect, limits=limits, azimuth=0., elevation=1e-3)\n\n\nhidexdecorations!(ax)\nhidezdecorations!(ax)\n\nrender!(ax, beam, color=:green2)\nrender!(ax, system)\n\nsave(\"spherical_lens_showcase.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/spherical_lenses/","page":"Spherical lenses","title":"Spherical lenses","text":"(Image: Spherical lens showcase)","category":"page"},{"location":"components/beamsplitters/#Beamsplitters","page":"Beamsplitters","title":"Beamsplitters","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"Beamsplitters are used to split beams of light, enabling the separation of an incoming beam into reflected and transmitted parts. In this package, beamsplitters are implemented via the BeamletOptics.AbstractBeamsplitter interface. This type loosely defines the interaction logic used for the tracing and retracing of optical systems that incorporate these devices. When a beam is split the new beams are referred to as the children of the parent beam. This package uses the AbstractTrees.jl interface in order to represent the splitting of BeamletOptics.AbstractBeams. For concrete implementations of splitters, skip to the Rectangular plate beamsplitter or Cube beamsplitter section.","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"info: Child order\nIn order to ensure consistency the following definition for the order of appended child beams is used: The transmitted beam is appended first and the reflected beam is appended second. The beam path of the parent beam stops at the splitting interface, i.e. a nothing optical interaction occurs.","category":"page"},{"location":"components/beamsplitters/#Thin-beamsplitter","page":"Beamsplitters","title":"Thin beamsplitter","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"This model acts as a quasi-coating, representing a very thin (zero-thickness) layer that directly splits the beamlets. This type is used for testing purposes mainly and to build composite objects. For optical setups it is recommended to use one of the splitter types listed below. One of two constructors can be used in order to spawn thin splitters:","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"ThinBeamsplitter\nRoundThinBeamsplitter","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"info: Beamsplitter phase jump\nIf you want to learn more about how beam splitting is modeled, especially in the context of interferometer simulations, refer to the ThinBeamsplitter type docs and the specific BeamletOptics.interact3d documentation.","category":"page"},{"location":"components/beamsplitters/#Plate-beamsplitters","page":"Beamsplitters","title":"Plate beamsplitters","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"Plate beamsplitters provide a more sophisticated model by incorporating a substrate with finite thickness and BeamletOptics.RefractiveIndex. The splitter coating is modeled via a ThinBeamsplitter placed flush onto a single face of the substrate. This allows for more realistic simulation of refractive effects such as e.g. beam path displacement and optical path differences caused by the substrate's geometry. Below two concrete implementations are showcased.","category":"page"},{"location":"components/beamsplitters/#Rectangular-plate-beamsplitter","page":"Beamsplitters","title":"Rectangular plate beamsplitter","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"The RectangularPlateBeamsplitter represents a planar, rectangular substrate with a partially reflective coating. ","category":"page"},{"location":"components/beamsplitters/#BeamletOptics.RectangularPlateBeamsplitter-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}-components-beamsplitters","page":"Beamsplitters","title":"BeamletOptics.RectangularPlateBeamsplitter","text":"RectangularPlateBeamsplitter(width, height, thickness, n; reflectance=0.5)\n\nCreates a RectangularPlateBeamsplitter. The splitter is aligned with the negative y-axis. The splitter coating is centered at the origin. See also RoundPlateBeamsplitter.\n\nInputs\n\nwidth: substrate width along the x-axis in [m]\nheight: substrate height along the z-axis in [m]\nthickness: substrate thickness along the y-axis in [m]\nn: the RefractiveIndex of the substrate\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"A common application involves that this type of beamsplitter is paired with a compensator plate. Below an exemplary illustration of such a setup is shown, where the beamsplitter reflects part of the incoming beam perpendiculary. A RectangularCompensatorPlate ensures that the parallel path offset is corrected.","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"file_dir = joinpath(@__DIR__, \"..\", \"assets\", \"bs_assets\")\n\nBase.include(@__MODULE__, joinpath(file_dir, \"pbs_showcase.jl\"))\n\ntake_screenshot(\"pbs_showcase.png\", system, beam; size=(600, 400), view=pbs_view, px_per_unit=8, optional_rendering_fct=test)","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"(Image: Plate beamsplitter showcase)","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"The depicted system consist of a rectangular beamsplitter (e.g. BSW26R) in combination with a compensator plate (e.g. BCP42R). They are both mounted in KM2536 kinematic mounts. The splitter substrate thickness is exaggerated for the purpose of illustration.","category":"page"},{"location":"components/beamsplitters/#Round-plate-beamsplitter","page":"Beamsplitters","title":"Round plate beamsplitter","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"This variant uses a circular substrate. While components of this type often feature a wedge angle to avoid \"ghost beams\" in practice, e.g. the BSW26, this is not modeled here.","category":"page"},{"location":"components/beamsplitters/#BeamletOptics.RoundPlateBeamsplitter-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}-components-beamsplitters","page":"Beamsplitters","title":"BeamletOptics.RoundPlateBeamsplitter","text":"RoundPlateBeamsplitter(diameter, thickness, n; reflectance=0.5)\n\nCreates a RoundPlateBeamsplitter. The splitter is aligned with the negative y-axis. The coating is centered at the origin. See also RectangularPlateBeamsplitter.\n\nInputs\n\ndiameter: x-z-plane substrate diameter in [m]\nthickness: substrate thickness along the z-axis in [m]\nn: the RefractiveIndex of the substrate\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"components/beamsplitters/#Cube-beamsplitter","page":"Beamsplitters","title":"Cube beamsplitter","text":"","category":"section"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"The CubeBeamsplitter is composed of two RightAnglePrisms with a partially reflective interface at their internal joint. The splitting interface is represented by a ThinBeamsplitter. As with other beamsplitters in this package, the cube beamsplitter uses scalar reflection and transmission coefficients.","category":"page"},{"location":"components/beamsplitters/#BeamletOptics.CubeBeamsplitter-Tuple{Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}-components-beamsplitters","page":"Beamsplitters","title":"BeamletOptics.CubeBeamsplitter","text":"CubeBeamsplitter(leg_length, n; reflectance=0.5)\n\nCreates a CubeBeamsplitter. The cuboid is centered at the origin. The splitter  coating is orientated at a 45° angle with respect to the y-axis.\n\nInputs\n\nleg_length: the x-, y- and z-edge length in [m]\nn: the RefractiveIndex of the front and back prism\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"file_dir = joinpath(@__DIR__, \"..\", \"assets\", \"bs_assets\")\n\nBase.include(@__MODULE__, joinpath(file_dir, \"cbs_showcase.jl\"))\n\ntake_screenshot(\"cbs_showcase.png\", system, beam; size=(600, 400), view=mzi_view, px_per_unit=8)","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"A classic application of cube beamsplitters is in Mach–Zehnder interferometers, where two beamsplitters combine with additional mirrors to form two optical paths that later recombine. The figure below shows a rudimentary Mach–Zehnder arrangement using two cube beamsplitters and two RightAnglePrismMirrors:","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"(Image: Cube beamsplitter showcase)","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"The system is made up of two cube beamsplitters (e.g. BS013) and two mirrors mounted in KM100PM/M prism mounts with PM4 clamping arms. The GaussianBeamlet enters from the bottom left and exits at the top right. Note that due to the splitting, two beams exit the systems. Depending on the relative phase, they mutually interfere. Total optical power is conserved.","category":"page"},{"location":"components/beamsplitters/","page":"Beamsplitters","title":"Beamsplitters","text":"tip: Interferometer tutorial\nRefer to the Michelson interferometer tutorial for a detailed showcase featuring beam splitters and other components.","category":"page"},{"location":"components/lenses/#Lenses","page":"Lenses","title":"Lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Lenses are fundamental optical components used to focus or diverge light, making them essential for constructing imaging systems. The BeamletOptics.AbstractRefractiveOptic type provides a general definition of components that refract light. This package includes a variety of rotationally symmetric lens models to simulate simple imaging setups. All lens models provided as part of this package are based on SDFs. Refer to the Signed Distance Functions (SDFs) section for more information.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"A concrete implementation is provided by the Lens type.","category":"page"},{"location":"components/lenses/#BeamletOptics.Lens-components-lenses","page":"Lenses","title":"BeamletOptics.Lens","text":"Lens{T, S <: AbstractShape{T}, N <: RefractiveIndex} <: AbstractRefractiveOptic{T, S, N}\n\nRepresents an uncoated Lens with a homogeneous RefractiveIndex n = n(λ). Refer to the Lens and SphericalLens constructors for more information on how to generate lenses.\n\nFields\n\nshape: geometry of the lens, refer to AbstractShape for more information\nn: RefractiveIndex function that returns n(λ)\n\nAdditional information\n\ninfo: Refractive index\nThe chromatic dispersion of the lens is represented by a λ-dependent function for n and must be provided by the user. For testing purposes, an anonymous function, e.g. λ -> 1.5 can be passed such that the lens has the same refractive index for all wavelengths.\n\n\n\n\n\n","category":"type"},{"location":"components/lenses/#Constructing-lens-shapes","page":"Lenses","title":"Constructing lens shapes","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"In practice, a great variety and mixture of different lens shapes exists – e.g. spherical and aspherical lenses surfaces and all combinations thereof. Usually a lens is a block of a transparent, dielectric material with two optically active surfaces (fancy special cases using the sides of the lens as well exist, e.g. for HUD displays). It is common to describe such a lens by specifying the properties of the two surfaces and the material in between. This package, however, works with closed volume shapes for all of its optical elements and any erroneous (i.e. non-watertight) SDF might result in unphysical behaviour. Refer to the Geometry representation section for more information.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"tip: Lens constructors\nOne of the following constructors can be used to generate lens objects:Lens constructor\ncapable constructor for a wide combination of surface types (spherical, aspherical, etc.)\nSphericalLens constructor\nsimplified constructor for spherical surfacesRefer to the specific documentation or enter e.g. ? Lens into the REPL to learn more about the constructors and their interfaces, as well as sign definitions and so on.","category":"page"},{"location":"components/lenses/#Surface-based-lens-construction","page":"Lenses","title":"Surface based lens construction","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"To make it easier to specify lenses similar to established optical simulation frameworks, e.g. Zemax, the BeamletOptics.AbstractSurface API can be used. This is a helper interface for surfaces specifications and interprets them to the corresponding SDF-based volume representation. ","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"warning: Warning\nIt is important to note that BMO does not work with these surfaces representations directly for ray tracing. All shapes are translated to closed volumes internally. ","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Currently the following surface types are implemented:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using BeamletOptics # hide\nBeamletOptics.list_subtypes(BeamletOptics.AbstractSurface);","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"A Lens can be then constructed with the following function call:","category":"page"},{"location":"components/lenses/#BeamletOptics.Lens-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractRotationallySymmetricSurface, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}-components-lenses","page":"Lenses","title":"BeamletOptics.Lens","text":" Lens(front_surface::AbstractRotationallySymmetricSurface, back_surface::AbstractRotationallySymmetricSurface, center_thickness::Real, n::RefractiveIndex)\n\nConstructs a new Lens object using the surface specifications front_surface and back_surface and the center_thickness. These inputs are used to construct a UnionSDF that consists of the appropriate sub-SDFs to represent the shape of the lens.\n\nThe material properties are supplied via the n parameter.\n\nAdditional information\n\ninfo: Radius of curvature (ROC) sign definition\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\nwarning: Meniscus\nIf your specification results in a meniscus lens, only spherical meniscus lenses are supported at the moment.\n\n\n\n\n\n","category":"method"},{"location":"components/lenses/#Lens-constructor-example","page":"Lenses","title":"Lens constructor example","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"In practice, this works as follows: the bi-convex LB1811 lens consists of two spherical surfaces and can be constructed like this:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using CairoMakie, BeamletOptics # hide\n\n# refractive index of NBK7 for 532 and 1064 nm\nNBK7 = DiscreteRefractiveIndex([532e-9, 1064e-9], [1.5195, 1.5066])\n\n# lens diameter \nd = BeamletOptics.inch\n\n# lens types\nr1 = 34.9e-3\nr2 = -34.9e-3\nl = 6.8e-3\nLB1811 = Lens(\n    SphericalSurface(r1, d),\n    SphericalSurface(r2, d),\n    l, \n    NBK7\n)\n\nsystem = System([LB1811]) # hide\n\nfig = Figure(size=(600,240)) # hide\nax = Axis3(fig[1,1], aspect=:data, azimuth=0., elevation=1e-3) # hide\n\nhidedecorations!(ax) # hide\nhidespines!(ax) # hide\n\nrender!(ax, system) # hide\n\nfig # hide","category":"page"},{"location":"components/lenses/#SDF-based-spherical-lenses","page":"Lenses","title":"SDF-based spherical lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"In order to model the lens surfaces shown above, the following SDF-based spherical lens shapes have been implemented:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"BeamletOptics.ConvexSphericalSurfaceSDF\nBeamletOptics.ConcaveSphericalSurfaceSDF\nBeamletOptics.MeniscusLensSDF\nBeamletOptics.PlanoSurfaceSDF","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"The BeamletOptics.AbstractSurface will translate surface specifications into volume representations using the sub-volumes above. This is achieved by combining the sub-volumes via the BeamletOptics.UnionSDF-API in order to enable the quasi-surface-based design of spherical lens systems. Additional distance functions have been implemented in order to model aspherical and cylinder lenses. ","category":"page"},{"location":"components/lenses/#Spherical-lenses","page":"Lenses","title":"Spherical lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Spherical lenses are characterized by surfaces with constant curvature, making them straightforward to model and ideal for basic imaging applications. The SphericalLens constructor can be used in order to define this lens type in a concise manner.","category":"page"},{"location":"components/lenses/#BeamletOptics.SphericalLens-components-lenses","page":"Lenses","title":"BeamletOptics.SphericalLens","text":"SphericalLens(r1, r2, l, d=1inch, n=λ->1.5)\n\nCreates a spherical Lens based on:\n\nr1: front radius\nr2: back radius\nl: lens thickness\nd: lens diameter, default is one inch\nn: RefractiveIndex as a function of λ, i.e. n = n(λ)\n\nNotes\n\ninfo: Radius of curvature (ROC) sign\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\ninfo: Thin lenses\nIf l is set to zero, a ThinLens will be created. However, note that the actual lens thickness will be different from zero.\n\n\n\n\n\n","category":"function"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Below, several spherical lenses are recreated from manufacturer data.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"GaussianBeamlet parameters\nw_0 = 5textmm\nlambda=532textnm\nLenses (in order of appearance)\nLD1464\nLB1811\nLC1715\nLE1234\nLA1805","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"The spherical lenses are shown below. To recreate this figure, refer to the Spherical lens example.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"file_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(file_dir, \"spherical_lens_showcase.jl\"))\n\nsave(\"spherical_lens_showcase.png\", fig, px_per_unit=4); nothing","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"(Image: Spherical lens showcase)","category":"page"},{"location":"components/lenses/#Aspherical-lenses","page":"Lenses","title":"Aspherical lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Aspherical lenses offer more advanced control over aberrations, enabling higher performance in specialized optical systems. The package offers surface support for rotationally symetrical aspheric lenses that adhere to the DIN ISO 10110 convention with even terms.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"To construct a lens with any possible combination of convex/concave, spherical/aspherical surfaces you can use the Lens constructor with the EvenAsphericalSurface surface specification type. ","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"A complex example of such a lens might look like the following example. This lens has the following peculiarities:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"The front surface is an aspherical convex surface with a clear diameter smaller than the full mechanical diameter\nThe back surface is an aspherical concave surface which first curves outwards before change slope and curving invards, giving a more \"convex\" like character while still beeing a concave lens by definition. Also this surface extends towards the full outer diameter.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"warning: Warning\nAspheric lenses are somewhat experimental at the moment. Use this feature with some caution when building unconventional lenses. Default/simple aspheres work fine.   ","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using CairoMakie, BeamletOptics # hide\n\nL3 = Lens(\n    EvenAsphericalSurface(\n        3.618e-3,               # r\n        3.04e-3,                # d\n        -44.874,                # conic\n        [0,-0.14756*(1e3)^3, 0.035194*(1e3)^5, -0.0032262*(1e3)^7,\n        0.0018592*(1e3)^9, 0.00036658*(1e3)^11, -0.00016039*(1e3)^13,\n        -3.1846e-5*(1e3)^15]    # coeffs\n    ),\n    EvenAsphericalSurface(\n        2.161e-3,               # r\n        3.7e-3,                 # d\n        -10.719,                # conic\n        [0,-0.096568*(1e3)^3, 0.026771*(1e3)^5, -0.011261*(1e3)^7,\n        0.0019879*(1e3)^9, 0.00015579*(1e3)^11, -0.00012433*(1e3)^13,\n        1.5264e-5*(1e3)^15]     # coeffs\n    ),\n    0.7e-3,                     # center_thickness\n    n -> 1.580200               # refractive index\n)\n\nfig = Figure(size=(600,240)) # hide\nax = Axis3(fig[1,1], aspect=:data, azimuth=0., elevation=1e-3) # hide\n\nhidedecorations!(ax) # hide\nhidespines!(ax) # hide\n\nrender!(ax, L3) # hide\n\nfig # hide","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"tip: Aspherical lens example\nRefer to the Simple aspherical lens example for a showcase on how to implement a plano-convex asphere.","category":"page"},{"location":"components/lenses/#Cylindrical-lenses","page":"Lenses","title":"Cylindrical lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"Cylindrical lenses are non-rotationally symmetric lenses where a spherical or aspherical curvature is present only in one dimension, i.e. leading to a cylindrical shape. Thus, they focus or collimate light only in one dimension. This package currently supports convex/concave cylindrical and acylindrical lenses with an even aspheric deviation from the cylindrical shape.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"A plano-convex cylindrical lens can be constructed in the following way. Note that for this lens type a plano-surface can be constructed by passing a RectangularFlatSurface to the lens constructor:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using CairoMakie, BeamletOptics # hide\n\nr = 5.2e-3  # radius\nd = 10e-3   # diameter/width of the cylindric portion\nh = 20e-3   # height/length of the cylinder\nct = 5.9e-3 # center thickness\nlens = Lens(\n    CylindricalSurface(r, d, h),    \n    ct,\n    n -> 1.517\n)\n\nfig = Figure() # hide\n\nax = Axis3(fig[1,1], aspect=:data, azimuth=-pi/4, elevation=deg2rad(30)) # hide\n\nhidedecorations!(ax) # hide\nhidespines!(ax) # hide\n\nrender!(ax,lens) # hide\n\nfig # hide\n","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"An acylindrical lens can easily be constructed using the AcylindricalSurface surface type:","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using CairoMakie, BeamletOptics # hide\n\nradius = -15.538e-3\ndiameter = 25e-3\nheight = 50e-3\nconic_constant = -1.0\n\nlens = Lens(\n    BeamletOptics.AcylindricalSurface(\n            radius,\n            diameter,\n            height,\n            conic_constant,\n            [0, 1.1926075e-5*(1e3)^3, -2.9323497e-9*(1e3)^5, -1.8718889e-11*(1e3)^7, -1.7009961e-14*(1e3)^9, 3.5481542e-17*(1e3)^11, 6.5241296e-20*(1e3)^13]\n        ),        \n        7.5e-3,\n        n -> 1.777\n    )\n\nfig = Figure() # hide\n\nax = Axis3(fig[1,1], aspect=:data, azimuth=-pi/4, elevation=deg2rad(30)) # hide\n\nhidedecorations!(ax) # hide\nhidespines!(ax) # hide\n\nrender!(ax,lens) # hide\n\nfig # hide","category":"page"},{"location":"components/lenses/#Doublet-lenses","page":"Lenses","title":"Doublet lenses","text":"","category":"section"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"The DoubletLens is an example for a multi-shape object as mentioned in the Multi-shape objects section. For spherical doublet lenses the following constructor can be used.","category":"page"},{"location":"components/lenses/#BeamletOptics.SphericalDoubletLens-NTuple{8, Any}-components-lenses","page":"Lenses","title":"BeamletOptics.SphericalDoubletLens","text":"SphericalDoubletLens(r1, r2, r3, l1, l2, d, n1, n2)\n\nGenerates a two-component \"cemented\" doublet lens consisting of two spherical lenses. For radii sign definition, refer to the SphericalLens constructor.\n\nArguments\n\nr1: radius of curvature for first surface\nr2: radius of curvature for second (cemented) surface\nr3: radius of curvature for third surface\nl1: first lens thickness\nl2: second lens thickness\nd: lens diameter\nn1: first lens RefractiveIndex\nn1: second lens RefractiveIndex\n\n\n\n\n\n","category":"method"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"The following image shows the AC254-150-AB doublet lens for 488 and 707 nm. It has been created using the SphericalDoubletLens constructor shown above.","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"using CairoMakie, BeamletOptics\n\nλs = [488e-9, 707e-9, 1064e-9]\n\nNLAK22 = DiscreteRefractiveIndex(λs, [1.6591, 1.6456, 1.6374])\nNSF10 = DiscreteRefractiveIndex(λs, [1.7460, 1.7168, 1.7021])\n\nAC254_150_AB = SphericalDoubletLens(87.9e-3, 105.6e-3, 1000, 6e-3, 3e-3, BeamletOptics.inch, NLAK22, NSF10)\n\nsystem = System([AC254_150_AB])\n\nfig = Figure(size=(600,170))\nax = Axis3(fig[1,1], aspect=:data, azimuth=0., elevation=1e-3)\n\nhidedecorations!(ax)\nhidespines!(ax)\n\nrender!(ax, system)\n\nzs_1 = LinRange(-0.011, 0.011, 6)\nzs_2 = LinRange(-0.01, 0.01, 5)\n\nfor (i, z) in enumerate(zs_1)\n    beam = Beam([0, -0.02 , z], [0,1.,0], 488e-9)\n    solve_system!(system, beam)\n    render!(ax, beam, flen=0.15, color=RGBAf(0,0,1,0.7))\nend\n\nfor (i, z) in enumerate(zs_2)\n    beam = Beam([0, -0.02 , z], [0,1.,0], 707e-9)\n    solve_system!(system, beam)\n    render!(ax, beam, flen=0.15, color=RGBAf(1,0,0,0.5))\nend\n\nsave(\"doublet_showcase.png\", fig, px_per_unit=4)\n\nnothing","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"(Image: Doublet lens showcase)","category":"page"},{"location":"components/lenses/","page":"Lenses","title":"Lenses","text":"tip: Spherical lens example\nFor a complex showcase featuring spherical singlet and doublet lenses, refer to the Double Gauss lens example page.","category":"page"},{"location":"examples/aspherical_lenses/#Simple-aspherical-lens-example","page":"Aspherical lenses","title":"Simple aspherical lens example","text":"","category":"section"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"The package has a basic support for ISO 10110 even aspheres. It is planned to extend this support in the future to include extended aspheres and maybe Q-aspheres. The following example shows the most simple usage of the plano-aspheric asphere constructor based on the Thorlabs AL50100J aspheric lens:","category":"page"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"using CairoMakie, BeamletOptics\n\n# radius\nR = 50.3583e-3\n# conic constant\nk = -0.789119\n# even aspheric coefficients up to 8th order\nA = [0, 2.10405e-7*(1e3)^3, 1.76468e-11*(1e3)^5, 1.02641e-15*(1e3)^7]\n# center thickness\nct = 10.2e-3\n# diameter\nd = 50e-3\n# refractive index of BK-7 @ 1310 nm (design wavelength)\nn = 1.5036\n\nlens = Lens(\n        EvenAsphericalSurface(R, d, k, A),\n        SphericalSurface(Inf, d),\n        ct,\n        x -> n\n    )\n\nsystem = System(lens)\n\nfig = Figure(size=(640,480))\n\nax = fig[1,1] = Axis3(fig, aspect=:data, azimuth=0., elevation=1e-3)\n\nhidexdecorations!(ax)\nhidezdecorations!(ax)\n\nfor z in -0.02:0.001:0.02\n    pos = [0.0, -0.05, z]\n    dir = [0.0, 1.0, 0]\n    ray = Ray(pos, dir)\n    beam = Beam(ray)\n    solve_system!(system, beam, r_max=40)\n\n    render!(ax, beam, flen=0.1)\nend\nrender!(ax, lens)\n\nsave(\"aspherical_lens_showcase.png\", fig, px_per_unit=4); nothing # hide\n","category":"page"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"(Image: Aspherical lens showcase)","category":"page"},{"location":"examples/aspherical_lenses/#Complex-aspherical-lens-example","page":"Aspherical lenses","title":"Complex aspherical lens example","text":"","category":"section"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"This example shows how a complex optical system for a mobile device can be modeled and traced using this package. This example is taken from Pencil of Rays.","category":"page"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"The whole system consists of three complex-shaped aspherical lenses, a filter and a cover glass in front of a sensor plane. All five components can be easily modeled using the Lens constructor and shifted in space using the kinematic API. The field has to be modeled manually.","category":"page"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"using CairoMakie, BeamletOptics\n\n## mobile-kyocera-3P_USP8558939.zmx\n\n# construct the first lens\nL1 = Lens(\n        EvenAsphericalSurface(\n            1.054e-3, # r\n            1.333024e-3, # d\n            -0.14294, # conic\n             [0,0.038162*(1e3)^3, 0.06317*(1e3)^5, -0.020792*(1e3)^7, 0.18432*(1e3)^9,\n             -0.04827*(1e3)^11, 0.094529*(1e3)^13] # coeffs\n        ),\n        EvenAsphericalSurface(\n            2.027e-3, # r\n            1.216472e-3, # d\n            8.0226, # conic\n            [0,0.0074974*(1e3)^3, 0.064686*(1e3)^5, 0.19354*(1e3)^7, -0.50703*(1e3)^9,\n            -0.34529*(1e3)^11, 5.9938*(1e3)^13] # coeffs\n        ),\n        0.72e-3, # center thickness\n        n -> 1.580200\n    )\n\n# construct the second lens\nL2 = Lens(\n        EvenAsphericalSurface(\n            -3.116e-3, # r\n            1.4e-3, # d\n            -49.984, # conic\n            [0,-0.31608*(1e3)^3, 0.34755*(1e3)^5, -0.17102*(1e3)^7, -0.41506*(1e3)^9,\n            -1.342*(1e3)^11, 5.0594*(1e3)^13, -2.7483*(1e3)^15] # coeffs\n        ),\n        EvenAsphericalSurface(\n            -4.835e-3, # r\n            1.9e-3, # d\n            1.6674, # conic\n            [0,-0.079727*(1e3)^3, 0.13899*(1e3)^5, -0.044057*(1e3)^7,\n            -0.019369*(1e3)^9, 0.016993*(1e3)^11, 0.093716*(1e3)^13,\n            -0.080329*(1e3)^15] # coeffs\n        ),\n        0.55e-3, # center_thickness\n        n -> 1.804700\n    )\n\n# shift the second lens to its position, assuming L1 is at the origin (0,0,0)\ntranslate3d!(L2, [0, BeamletOptics.thickness(L1) + 0.39e-3,0])\n\n# construct the third lens\nL3 = Lens(\n        EvenAsphericalSurface(\n            3.618e-3, # r\n            3.04e-3, # d\n            -44.874, # conic\n            [0,-0.14756*(1e3)^3, 0.035194*(1e3)^5, -0.0032262*(1e3)^7,\n            0.0018592*(1e3)^9, 0.00036658*(1e3)^11, -0.00016039*(1e3)^13,\n            -3.1846e-5*(1e3)^15] # coeffs\n        ),\n        EvenAsphericalSurface(\n            2.161e-3, # r\n            3.7e-3, # d\n            -10.719, # conic\n            [0,-0.096568*(1e3)^3, 0.026771*(1e3)^5, -0.011261*(1e3)^7,\n            0.0019879*(1e3)^9, 0.00015579*(1e3)^11, -0.00012433*(1e3)^13,\n            1.5264e-5*(1e3)^15] # coeffs\n        ),\n        0.7e-3, # center_thickness\n        n -> 1.580200\n    )\n\n# first translate the lens to the L2 position, then shift it by the relative offset with respect to L2\ntranslate_to3d!(L3, position(L2))\ntranslate3d!(L3, [0, BeamletOptics.thickness(L2) + 0.63e-3,0])\n\n# construct the filter by setting the radius to Inf for front/back, resulting in a parallel plate\nFilt = Lens(\n        SphericalSurface(Inf, 4.2e-3),\n        SphericalSurface(Inf, 4.2e-3),\n        0.15e-3,\n        n -> 1.516800\n    )\n\n# same principle as for L3\ntranslate_to3d!(Filt, position(L3))\ntranslate3d!(Filt, [0, BeamletOptics.thickness(L3) + 0.19e-3,0])\n\n# Construct the cover glass and shift into position\nCover = Lens(\n        SphericalSurface(Inf, 4.9e-3),\n        SphericalSurface(Inf, 4.9e-3),\n        0.5e-3,\n        n -> 1.469200\n    )\ntranslate_to3d!(Cover, position(Filt))\ntranslate3d!(Cover, [0, BeamletOptics.thickness(Filt) + 0.18e-3,0])\n\nsystem = System([L1, L2, L3, Filt, Cover])\n\nfig = Figure()\nax = Axis3(fig[1,1], aspect=:data, azimuth=0.0, elevation=.0)\nhidedecorations!(ax)\nhidespines!(ax)\n\nrender!(ax, system)\n\n# 0° beams\nbeams = [\n    Beam([0, -0.5e-3, -1.3e-3/2], [0, 1, 0], 0.5876e-6),\n    Beam([0, -0.5e-3, 0], [0, 1, 0], 0.5876e-6),\n    Beam([0, -0.5e-3, 1.3e-3/2], [0, 1, 0], 0.5876e-6)\n]\nfield_angles = 6:6:30\ncolors = [:blue, :green, :red, :yellow, :magenta, :cyan]\nfor beam in beams    \n    i = 1\n    solve_system!(system, beam, r_max=50)\n    render!(ax, beam, flen=0.12e-3, color = colors[i], show_pos=true)\n    # use the 0° beams to construct all other beam sets\n\n    pos = beam.rays[1].pos + BeamletOptics.intersection(beam.rays[1]).t*beam.rays[1].dir\n    for angle in field_angles\n        i += 1\n        # tilted input beam generation\n        dir = [0, cosd(angle), sind(angle)]\n        spos = pos - dir * BeamletOptics.intersection(beam.rays[1]).t\n        abeam = Beam(spos, dir, beam.rays[1].λ)\n\n        # trace through system\n        solve_system!(system, abeam, r_max=50)\n        render!(ax, abeam, flen=0.12e-3*(1+sind(angle)), color = colors[i], show_pos=true)\n    end\nend\n\nsave(\"aspherical_lens_mobile.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/aspherical_lenses/","page":"Aspherical lenses","title":"Aspherical lenses","text":"(Image: Mobile lens with comples aspheres)","category":"page"},{"location":"components/mirrors/#Mirrors","page":"Mirrors","title":"Mirrors","text":"","category":"section"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"A common optical element with a straight-forward optical interaction. This kind of component is in general defined as a BeamletOptics.AbstractReflectiveOptic. For a basic Ray the interaction is simply defined by the BeamletOptics.reflection3d function. A more complex algorithm is required when when a PolarizedRay interacts with a reflecting surface. The polarization calculus that is performed is explained in the Polarized Rays section. Below, some of the concrete implemented mirror types are shown. In general, the Mirror is used as a concrete type to represent an arbitrary reflecting shape.","category":"page"},{"location":"components/mirrors/#BeamletOptics.Mirror-components-mirrors","page":"Mirrors","title":"BeamletOptics.Mirror","text":"Mirror{S <: AbstractShape} <: AbstractReflectiveOptic\n\nConcrete implementation of a perfect mirror (R = 1) with arbitrary shape.\n\nwarning: Reflecting surfaces\nIt is important to consider that all surfaces of this mirror type are reflecting!\n\n\n\n\n\n","category":"type"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"The following constructors can be used to generate flat reflecting shapes. Additional types are explained below.","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"SquarePlanoMirror2D\nSquarePlanoMirror\nRectangularPlanoMirror\nRetroreflector","category":"page"},{"location":"components/mirrors/#Plano-Mirrors","page":"Mirrors","title":"Plano Mirrors","text":"","category":"section"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"A category of mirrors with a flat reflecting surface. A round version of this mirror can be easily generated using the RoundPlanoMirror or RightAnglePrismMirror types:","category":"page"},{"location":"components/mirrors/#BeamletOptics.RoundPlanoMirror-Tuple{Real, Real}-components-mirrors","page":"Mirrors","title":"BeamletOptics.RoundPlanoMirror","text":"RoundPlanoMirror(diameter, thickness)\n\nReturns a cylindrical, flat RoundPlanoMirror with perfect reflectivity based on:\n\nInputs\n\ndiameter: mirror diameter in [m]\nthickness: mirror substrate thickness in [m]\n\n\n\n\n\n","category":"method"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"Below, a trivial example of a beam path propagating through a system of Ø1\"-mirrors mounted in KM100CP/M kinematic mounts is shown (e.g. PF10-03-P01). Note that the mounts are modeled as NonInteractableObjects.","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"file_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(file_dir, \"plano_mirror_showcase.jl\"))\n\ntake_screenshot(\"plano_mirror_showcase.png\", system, beam; size=(600, 400), view=mirror_camera, color=RGBf(0,1,0), flen=.4)","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"(Image: Plano mirror showcase)","category":"page"},{"location":"components/mirrors/#Concave-Mirrors","page":"Mirrors","title":"Concave Mirrors","text":"","category":"section"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"The ConcaveSphericalMirror represents an ideal optical element with a spherical concave reflective surface, commonly used for non-dispersive focusing applications. Its geometry is modeled using a combination of a concave spherical surface and a plano substrate, represented internally by a BeamletOptics.UnionSDF (refer also to the SDF-based spherical lenses section).","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"file_dir = joinpath(@__DIR__, \"..\", \"assets\")\n\nBase.include(@__MODULE__, joinpath(file_dir, \"spherical_mirror_showcase.jl\"))\n\nsave(\"concave_mirror_showcase.png\", fig, px_per_unit=4); nothing","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"(Image: Concave mirror multipass showcase)","category":"page"},{"location":"components/mirrors/","page":"Mirrors","title":"Mirrors","text":"The following constructor allows the spawning of concave spherical mirrors.","category":"page"},{"location":"components/mirrors/#BeamletOptics.ConcaveSphericalMirror-Tuple{Real, Real, Real}-components-mirrors","page":"Mirrors","title":"BeamletOptics.ConcaveSphericalMirror","text":"ConcaveSphericalMirror(radius, thickness, diameter)\n\nConstructor for a spherical mirror with a concave reflecting surface. The component is aligned with the positive y-axis. See also ConcaveSphericalMirror. \n\nInputs\n\nradius: the spherical surface radius of curvature in [m]\nthickness: substrate thickness in [m]\ndiameter: mirror outer diameter in [m]\n\n\n\n\n\n","category":"method"},{"location":"basics/beams/#Beams","page":"Beams","title":"Beams","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"As mentioned in the Rays section, a beam within the context of this package serves as a data structure for storing collections of rays, forming the backbone of the simulation framework. Beams are intended to be designed as AbstractTrees to allow for ray bifurcations, e.g. in the case of optical elements such as beamsplitters. The solve_system! function relies on this data structure to perform ray tracing computations within optical systems. ","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"To ensure compatibility and extensibility, beam types must adhere to the BeamletOptics.AbstractBeam interface. Refer to its documentation for more information.","category":"page"},{"location":"basics/beams/#Basic-beam","page":"Beams","title":"Basic beam","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"A minimal implementation of the BeamletOptics.AbstractBeam type is provided by the Beam. It can be used to store a light path through an optical system. If the beam is split, its children will be recursively traced until all paths are solved.","category":"page"},{"location":"basics/beams/#BeamletOptics.Beam-basics-beams","page":"Beams","title":"BeamletOptics.Beam","text":"Beam{T, R <: AbstractRay{T}} <: AbstractBeam{T, R}\n\nStores the rays that are calculated from geometric optics when propagating through an optical system. The Beam type is parametrically defined by the AbstractRay subtype that it stores.\n\nFields\n\nrays: vector of AbstractRay objects, representing the rays that make up the beam\nparent: reference to the parent beam, if any (Nullable to account for the root beam which has no parent)\nchildren: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting\n\n\n\n\n\n","category":"type"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"A ray tracing example through an arbitrary system using a Beam is shown below. Individual Ray segments are marked by their starting position and direction. The Beam expander and Miniature microscope tutorial covers the use of the Beam in more detail. ","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Beam structure)","category":"page"},{"location":"basics/beams/#Beam-groups","page":"Beams","title":"Beam groups","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"For convenience, the BeamletOptics.AbstractBeamGroup offers a container-like interface for groups of Beams as commonly used in other software packages. The following concrete implementations are currently provided:","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"using BeamletOptics # hide\nBeamletOptics.list_subtypes(BeamletOptics.AbstractBeamGroup);","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Refer to the following sections for convenience constructors to generate the sources listed above.","category":"page"},{"location":"basics/beams/#Collimated-beam-source","page":"Beams","title":"Collimated beam source","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The collimated beam source is ideal to model light coming from a focal plane at infinity. This is useful for simulating plane wavefronts. You can define a collimated monochromatic Beam source as follows:","category":"page"},{"location":"basics/beams/#BeamletOptics.CollimatedSource-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, Real, Real}-basics-beams","page":"Beams","title":"BeamletOptics.CollimatedSource","text":"CollimatedSource(pos, dir, diameter, λ; num_rings, num_rays)\n\nSpawns a bundle of collimated Beams at the specified position and direction. The source is modelled as a ring of concentric beam rings around the center beam. The amount of beam rings between the center ray and outer diameter can be specified via num_rings.\n\ninfo: Info\nNote that for correct sampling, the number of rays should be atleast 20x the number of rings.\n\nArguments\n\nThe following inputs and arguments can be used to configure the CollimatedSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\ndiameter: outer beam bundle diameter in [m]\nλ = 1e-6: wavelength in [m], default val. is 1000 nm\n\nKeyword Arguments\n\nnum_rings: number of concentric beam rings, default is 10\nnum_rays: total number of rays in the source, default is 100x num_rings\n\nwarning: Warning\nThe orthogonal basis vectors for the beam generation are generated randomly.\n\n\n\n\n\n","category":"method"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Collimated group of beams)","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"A special constructor called UniformDiscSource is available, which offers an equal-area sampling (Fibonnaci-pattern) sampling and is thus favorable in situations where the weighting of the individual beams becomes important, e.g. for calculating a point spread function using PSFDetector.","category":"page"},{"location":"basics/beams/#BeamletOptics.UniformDiscSource-basics-beams","page":"Beams","title":"BeamletOptics.UniformDiscSource","text":"UniformDiscSource(pos, dir, diameter, λ; num_rays=1_000)\n\nGenerates a ray fan with equal area per ray across a circular pupil using the deterministic sunflower (Fibonacci) pattern.\n\nnote: Note\nThis is merely a CollimatedSource constructor which uses Fibonacci sampling instead of a linear grid.\n\nArguments\n\nThe following inputs and arguments can be used to configure the underlying CollimatedSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\ndiameter: outer beam bundle diameter in [m]\nλ = 1e-6: wavelength in [m]\n\nKeyword Arguments\n\nnum_rays=1000: total number of rays in the source\n\n\n\n\n\n","category":"function"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Collimated uniform group of beams)","category":"page"},{"location":"basics/beams/#Point-beam-source","page":"Beams","title":"Point beam source","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The PointSource type is used to model emission from a spatially localized source that radiates Beams in a range of directions. This is commonly used to simulate conical emission patterns, such as light emerging from a fiber tip or a light source for a lens objective with a known focal distance. You can specify the origin and a propagation direction, which are then used to construct the monochromatic PointSource.","category":"page"},{"location":"basics/beams/#BeamletOptics.PointSource-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, Real, Real}-basics-beams","page":"Beams","title":"BeamletOptics.PointSource","text":"PointSource(pos, dir, θ, λ; num_rings, num_rays)\n\nSpawns a point source of Beams at the specified position and direction. The point source is modelled as a collection of concentric beam fans centered around the center beam. The amount of beam rings between the center ray and half-spread-angle θ can be specified via num_rings.\n\ninfo: Info\nNote that for correct sampling, the number of rays should be atleast 20x the number of rings.\n\nArguments\n\nThe following inputs and arguments can be used to configure the PointSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\nθ: half spread angle in rad\nλ = 1e-6: wavelength in [m], default val. is 1000 nm\n\nKeyword Arguments\n\nnum_rings: number of concentric beam rings, default is 10\nnum_rays: total number of rays in the source, default is 100x num_rings\n\nwarning: Warning\nThe orthogonal basis vectors for the beam generation are generated randomly.\n\n\n\n\n\n","category":"method"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Below you can find an exemplary illustration of a PointSource.","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Point source of beams)","category":"page"},{"location":"basics/beams/#Gaussian-beamlet","page":"Beams","title":"Gaussian beamlet","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Lasers are common devices in modern optical laboratories. Modeling their propagation through an optical setup can be of interest when planning new experiments. Geometrical ray tracing struggles to capture the propagation of a laser beam correctly, since it can not inherently capture the wave nature of e.g. the Gaussian beam.","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The electric field of the textTEM_00 spatial Gaussian mode can be calculated analytically using the BeamletOptics.electric_field function: ","category":"page"},{"location":"basics/beams/#BeamletOptics.electric_field-Tuple{Real, Real, Vararg{Any, 6}}-basics-beams","page":"Beams","title":"BeamletOptics.electric_field","text":"electric_field(r, z, E0, w0, w, k, ψ, R) -> ComplexF64\n\nComputes the analytical complex electric field distribution of a stigmatic TEM₀₀ Gaussian beam which is described by:\n\nE(rz) = E_0fracw_0w(z)expleft(  - fracr^2w(z)^2 right)expleft(ileft kz + psi + frackr^22 R(z) right right)\n\nArguments\n\nr: radial distance from beam origin\nz: axial distance from beam origin\nE0: peak electric field amplitude\nw0: waist radius\nw: local beam radius\nk: wave number, equal to 2π/λ\nψ: Gouy phase shift (defined as -textatanleft(fraczz_rright) !)\nR: wavefront curvature, i.e. 1/r (radius of curvature)\n\n\n\n\n\n","category":"method"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The evolution of this field through an optical system can be modeled e.g. by the ray transfer matrix formalism using the complex q-factor [7, pp. 27]. A Julia-based implementation of this approach can be found in ABCDMatrixOptics.jl. However, in the case of this package another approach will be used.","category":"page"},{"location":"basics/beams/#Complex-ray-tracing","page":"Beams","title":"Complex ray tracing","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"In 1968 an internal publication at Bell Labs by J. Arnaud introduced the concept of complex rays wherein three geometrical beams can be used to model the propagation of a Gaussian in fundamental mode through a symmetric optical system, i.e. without the Gaussian obtaining astigmatism and/or higher-order abberations. This method is analoguos to the ray transfer matrix based q-method [8].","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Without extensions of the original method, the following key assumptions must be met such that this method can be applied","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"all (complex) beams of the Gaussian in question must intersect the same optical elements\nthe optical elements are large compared to the beam (waist)\nthe paraxial approximation must hold for each beam\nthe Gaussian may not be clipped by hard apertures\nLagrange invariant must be fulfilled","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Various versions of this approach have been implemented under different names in commercial software, most notably FRED and Code V, as well as in open source software, e.g. ","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Raypier - based on Cython, maintenance status not known\nPoke - based on Zemax API and Python, maintained by J. Ashcraft et al. [9]\nIfoCAD - maintenance status not known, refer to Wanner et al. [10]","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"This package implements the above method via the GaussianBeamlet and the BeamletOptics.AstigmaticGaussianBeamlet (Work in progress).","category":"page"},{"location":"basics/beams/#Stigmatic-Beamlets","page":"Beams","title":"Stigmatic Beamlets","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The GaussianBeamlet implements the BeamletOptics.AbstractBeam interface and can be used to model the propagation of a monochromatic Gaussian (textTEM_00-mode) through optical system where all optics lie on the optical axis, e.g. no tip and/or tilt dealignment, and abberations can be neglected. It is represented by a chief (red), waist (blue) and divergence (green) beam. See below how these beans are placed in relation to the envelope of the Gaussian beam.","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Complex ray tracing I)","category":"page"},{"location":"basics/beams/#BeamletOptics.GaussianBeamlet-basics-beams","page":"Beams","title":"BeamletOptics.GaussianBeamlet","text":"GaussianBeamlet{T} <: AbstractBeam{T, Ray{T}}\n\nRay representation of the stigmatic Gaussian beam as per J. Arnaud (1985). The beam quality M2 is fully considered via the divergence angle. The formalism for the beam parameter calculation is based on the following publications:\n\nJacques Arnaud, \"Representation of Gaussian beams by complex rays,\" Appl. Opt. 24, 538-543 (1985)\n\nand\n\nDonald DeJager and Mark Noethen, \"Gaussian beam parameters that use Coddington-based Y-NU paraprincipal ray tracing,\" Appl. Opt. 31, 2199-2205 (1992)\n\nFields\n\nchief: a Beam of Rays to store the chief ray\nwaist: a Beam of Rays to store the waist ray\ndivergence: a Beam of Rays to store the divergence ray\nλ: beam wavelength in [m]\nw0: local beam waist radius in [m]\nE0: complex field value in [V/m]\nparent: reference to the parent beam, if any (Nullable to account for the root beam which has no parent)\nchildren: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting\n\nAdditional information\n\ninfo: Beam parameters\nParameters of the beam, e.g. w(z) or R(z), can be obtained through the gauss_parameters function.\n\nwarning: Astigmatism and abberations\nIt is assumed, but not forbidden, that the optical system contains non-flat or non-parabolic beam-surface-interactions that cause the beam to obtain astigmatism or higher-order abberations. These can not be represented by the GaussianBeamlet.\n\n\n\n\n\n","category":"type"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"A GaussianBeamlet can be constructed via:","category":"page"},{"location":"basics/beams/#BeamletOptics.GaussianBeamlet-Tuple{AbstractArray{<:Real}, AbstractArray{<:Real}, Real, Real}-basics-beams","page":"Beams","title":"BeamletOptics.GaussianBeamlet","text":"GaussianBeamlet(position, direction, λ, w0; kwargs...)\n\nConstructs a Gaussian beamlet at its waist with the specified beam parameters.\n\nArguments\n\nThe following inputs and arguments can be used to configure the beamlet:\n\nInputs\n\nposition: origin of the beamlet\ndirection: direction of the beamlet\nλ: wavelength of the beamlet in [m]. Default value is 1000 nm.\nw0: beam waist (radius) in [m]. Default value is 1 mm.\n\nKeyword Arguments\n\nM2: beam quality factor. Default is 1\nP0: beam total power in [W]. Default is 1 mW\nz0: beam waist offset in [m]. Default is 0 m\nsupport: Nullable support vector for the construction of the waist and div rays\n\nAdditional information\n\ntip: Waist offset\nThe z0 keyword arg. can be used in order to spawn a beam where the waist is not located at the specified position, but rather at an offset z0 in [m] along the chief ray axis.\n\ninfo: Support vector\nIn order to calculate the basis vectors required for the beamlet construction, a random orthogonal vector is chosen. If results fluctuate due to the randomness of this vector, make sure to specify a fixed orthogonal support vector.\n\n\n\n\n\n","category":"method"},{"location":"basics/beams/#Obtaining-the-beam-parameters","page":"Beams","title":"Obtaining the beam parameters","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Once a GaussianBeamlet has been traced through an optical system, several parameters might be of interest for further analysis. In order to relate the traced geometrical beams/rays to the Gaussian parameters, the publications of Arnaud, Herloski et al. and DeJager et al. are used [8, 11, 12]. Consider the following system where a Gaussian beam with arbitrary parameters has been traced through a lens using the approach outlined in the Complex ray tracing section.","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Complex ray tracing II)","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"The user can obtain parameters such as the beam waist radius, the radius of curvature and more using the BeamletOptics.gauss_parameters function. Below the local waist radius and curvature R = r^-1 have been calculated for the example above.","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"(Image: Gauss beam parameters)","category":"page"},{"location":"basics/beams/#Astigmatic-Polarized-Beamlets","page":"Beams","title":"Astigmatic Polarized Beamlets","text":"","category":"section"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"Assumptions\nhomogeneous polarization distribution across waist\nLagrange invariant","category":"page"},{"location":"basics/beams/","page":"Beams","title":"Beams","text":"info: Info\nWORK IN PROGRESS","category":"page"},{"location":"components/polarizers/#Polarizers","page":"Polarizers","title":"Polarizers","text":"","category":"section"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"Polarizers in the context of this package are optical elements that select or modify the R³ polarization vector of a PolarizedRay, e.g. filters or λ/2 waveplates. This is mainly done by two approaches:","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"3D polarization ray-tracing calculus\n3D modified Jones matrix calculus","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"For more information on the first method refer to the section: Polarized Rays. For the second approach, elements fall under the category of the BeamletOptics.AbstractJonesPolarizer.","category":"page"},{"location":"components/polarizers/#BeamletOptics.AbstractJonesPolarizer-components-polarizers","page":"Polarizers","title":"BeamletOptics.AbstractJonesPolarizer","text":"AbstractJonesPolarizer <: AbstractObject\n\nRepresents infinitesimally thin components that change the polarization state of incoming PolarizedRays via global Jones matrix calculus. Rather than using the generic Yun ray tracing scheme as referred to in the PolarizedRay docs, this element interacts with the global E-field vector E0 by using a GlobalJonesBasis and projecting the entries into the transverse plane defined by the incoming ray direction and orthogonal E-field vector. This approach is partially inspired by the publication:\n\nJan Korger et al., \"The polarization properties of a tilted polarizer,\" Opt. Express 21, 27032-27042 (2013)\n\nwarning: Warning\nIt is assumed that the ray direction of propagation is not changed during the interaction.\n\nImplementation reqs.\n\nSubtypes of AbstractJonesPolarizer should implement all supertype requirements.\n\nInteraction logic\n\nThe GlobalJonesBasis tracks the rotation in 3D-space via the orientation of the attached AbstractShape. The polarization matrix P is calculated by projecting the previous matrix into the incoming orthogonal plane of polarization. Refer to the _calculate_global_E0 implementation for more information.\n\ninfo: Info\nThe validity of this approach is still under consideration for non-normal incidence.\n\n\n\n\n\n","category":"type"},{"location":"components/polarizers/#Jones-matrix-element-representation","page":"Polarizers","title":"Jones matrix element representation","text":"","category":"section"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"Fundamentally, the approach used here to simulate the effect of polarizers is referred to as Jones calculus and gives a \"0th order\" approximation of the physical effect. Out of plane tilts with respect to the optical axis of an incoming ray are currently only considered via a projection into the transverse plane of the incoming ray [13].","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"In a nutshell, elements are characterized by a 2x2 matrix that determines how the E-field components in the transverse plane to the optical axis are passed through in a global coordinate system where a ray of polarized light propagates along the z-axis. For instance, the entries for a linear filter that blocks in the y-direction are","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"J = \nbeginpmatrix\n1  0\n0  0\nendpmatrix ","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"While this allows to simply model a specific set of polarizing elements, its important to note that more complex phenomena need more extensive implementations. For 3D-calculations, the J-matrix representation is embedded into ","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"P =\nbeginbmatrix\n  J  beginmatrix0  0endmatrix \n  beginmatrix0  0endmatrix  1\nendbmatrix","category":"page"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"in order to calculate vecE_1 = P cdot vecE_0 for normal incidence. Additional details are provided in the docs above.","category":"page"},{"location":"components/polarizers/#Polarisation-filter","page":"Polarizers","title":"Polarisation filter","text":"","category":"section"},{"location":"components/polarizers/","page":"Polarizers","title":"Polarizers","text":"A polarisation filter or linear polarizer is the simplest practical polarizer and is commonly used to select a desired polarization state. This package provides the PolarizationFilter as an idealized implementation for a zero-thickness filter.","category":"page"},{"location":"components/polarizers/#BeamletOptics.PolarizationFilter-Tuple{Real}-components-polarizers","page":"Polarizers","title":"BeamletOptics.PolarizationFilter","text":"PolarizationFilter(edge_length; cutoff_strength)\n\nSpawns a thin, rectangular PolarizationFilter. The edge_length has to be specified in [m]. The filter is aligned with the global y-axis and transmits along the x-axis, while blocking polarization components along the global z-axis.\n\n\n\n\n\n","category":"method"},{"location":"guide/#Developers-guide","page":"Dev. guide","title":"Developers guide","text":"","category":"section"},{"location":"guide/#Contributing","page":"Dev. guide","title":"Contributing","text":"","category":"section"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"While not strictly adhering to the SciML Style Guide, we recommend consulting the guide as a baseline for contributions to this package. Refer to the SciML Contributors Guide as well. Ideally, your contribution features:","category":"page"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"tests for new or changed functionality\ndocstrings for relevant functions\ndocumentation and examples","category":"page"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"We would also love to feature your work with this package as part of the Examples section.","category":"page"},{"location":"guide/#Documentation-development","page":"Dev. guide","title":"Documentation development","text":"","category":"section"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"If you want to edit the package documentation locally, follow these steps:","category":"page"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"Create your local dev. repository via ] dev BeamletOptics\nSwitch into the docs environment, e.g. ] activate . inside of the docs folder\nInside of VS Code you can activate the local environment by right-clicking the make.jl file\nIf you have the Julia plugin installed, you will be able to select Julia: Activate This Environment\nInside of the docs environment switch the dependency onto your local BeamletOptics dev folder via ] dev BeamletOptics\nThis step is important, otherwise an incompatible version of BeamletOptics might be used to generate the docs\nRun the make.jl file","category":"page"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"Changes you have made will then be saved into the build folder. You can host the website locally by opening the index.html starting page.","category":"page"},{"location":"guide/#Section-titles","page":"Dev. guide","title":"Section titles","text":"","category":"section"},{"location":"guide/","page":"Dev. guide","title":"Dev. guide","text":"When creating a custom section in the documentation, you should avoid naming the section the same way as your type, e.g. for MyCustomType you should not create a section that is called # MyCustomType. The reason for this is that the @ref macro will confuse the docstring of your type with the section header, leading to undefined behavior for any links pointing to the embedded docstring via [MyCustomType](@ref).","category":"page"},{"location":"tutorials/microscope/#Miniature-microscope","page":"Miniature microscope","title":"Miniature microscope","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The UCLA Miniscope is a lightweight microscope that utilizes 2-photon fluorescence imaging to record neural activity in awake, freely moving mice [1]. This beginner tutorial aims to reproduce the optical path of the imaging system from the data provided in the UCLA 2P Miniscope repository. You will learn how to:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Define optical components (e.g. a SphericalDoubletLens)\nPosition the mentioned components using the kinematic API\nDefine an optical System\nAdd a source of Rays \nTrace a Beam through the optical system\nVisualize the results ","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"All specifications for the optical system and CAD files are taken from the UCLA miniscope repository under GNU GPL-3.0.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: UCLA miniscope introduction figure)","category":"page"},{"location":"tutorials/microscope/#How-to-follow-this-tutorial","page":"Miniature microscope","title":"How to follow this tutorial","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"All figures you will see below are pregenerated. The full code and all 3D assets are available in the following files:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"path = normpath(tutorial_dir) # hide\n@info \"Files located at:\" path # hide","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"If you want to reproduce the plots in this tutorial by yourself, it is recommend that you use the render! function as described in the Visualization section. In addition, your simulation script to follow this tutorial should include the following setup code at the start of the file:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"using GLMakie, BeamletOptics\n\nconst BMO = BeamletOptics\n\nconst cm = 1e-2\nconst mm = 1e-3","category":"page"},{"location":"tutorials/microscope/#Miniscope-objective-lenses","page":"Miniature microscope","title":"Miniscope objective lenses","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"This tutorial will focus on modeling the return path of the fluorescence light. Based on the design files provided in the resources above, we will start by defining the first lens along the optical path. This plano-convex lens can be generated via three approaches:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Design a BeamletOptics.AbstractShape and pass it into the Lens type\nUse the SphericalLens convenience constructor\nUtilize the quasi surface-based Lens constructor","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Due to its versatility, we will use the latter method in order to reimplement the Zemax design file. It is based on the definition of surface types which will be translated into the correct AbstractShape automatically. Refer to the Surface based lens construction section for more information.","category":"page"},{"location":"tutorials/microscope/#Defining-refractive-index-data","page":"Miniature microscope","title":"Defining refractive index data","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Before we can start, we will need to define refractive indices as a function of the wavelength. For the purpose of this tutorial, we will need to consider the refractive index of the relevant glasses at the design wavelengths. Later on we will define geometrical beams with discrete wavelengths for the ray tracing solver. For the purpose of fluorescence imaging, we will look at lambda_green = 5461mathrmnm and lambda_red = 6563mathrmnm. The indices have been manually taken from the Schott glass catalog.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"# Define the design wavelengths\nλ_green = 546.1e-9\nλ_red   = 656.3e-9\nlambdas = [λ_green, λ_red]\n# Define ref. indices at the specified wavelengths\nNBK7    = DiscreteRefractiveIndex(lambdas, [1.51872, 1.51432])\nNSK5    = DiscreteRefractiveIndex(lambdas, [1.59142, 1.58619])\nNSF4    = DiscreteRefractiveIndex(lambdas, [1.76164, 1.74719])\nNLAK22  = DiscreteRefractiveIndex(lambdas, [1.65391, 1.64760])\nNLASF44 = DiscreteRefractiveIndex(lambdas, [1.80832, 1.79901])","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Note that the data for (lambda_1, lambda_2) is mapped onto (n_1, n_2). For more information, refer to the DiscreteRefractiveIndex docs.","category":"page"},{"location":"tutorials/microscope/#Specifying-the-lens-shape","page":"Miniature microscope","title":"Specifying the lens shape","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The following code defines the front planar surface and the back spherical convex surface.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"# Objective lens 1\nsurf_1 = CircularFlatSurface(2*1.144mm)\nsurf_2 = SphericalSurface(-1.448mm, 2*1.144mm)\nobj_lens_1 = Lens(surf_1, surf_2, 1.3mm, NSK5)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Note that obj_lens_1 is a single Lens entity once spawned and can be manipulated in 3D-space as described in the section: Moving optical elements.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: First objective lens)","category":"page"},{"location":"tutorials/microscope/#Building-the-objective-group","page":"Miniature microscope","title":"Building the objective group","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"To build the second and third lens elements of the objective group we will proceed as above. However, these lenses are spherical doublets formed by two lenses bonded with an optical adhesive in practice. They are also more complex in shape, featuring a mechanical outer diameter. For the second lens the generating code is provided below. Two Lenses can be combined into a DoubletLens. Correct \"assembly\" of the lens parts is the responsibility of the user.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"# Objective lens 2 - define surfaces\nsurf_1 = SphericalSurface(38.184mm, 2*1.840mm, 2*2.380mm)\nsurf_2 = SphericalSurface(3.467mm, 2*2.060mm, 2*2.380mm)\nsurf_3 = SphericalSurface(-5.020mm, 2*2.380mm)\n# Define front and back lens\ndl11 = Lens(surf_1, surf_2, 0.5mm, NSF4)\ndl12 = Lens(surf_2, surf_3, 2.5mm, NLAK22)\n# Move back lens into position\ntranslate3d!(dl12, [0, thickness(dl11), 0])\n# Spawn doublet\nobj_lens_2 = DoubletLens(dl11, dl12)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The lens parts dl11 and dl12 are joined together by moving dl12 along the y-axis by a distance equal to the on-axis thickness of dl11.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: Second objective lens)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"info: Axis conventions\nIn general, most components provided by BMO are aligned with the global y-axis and spawned at the origin unless specified otherwise.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Similarily, the third objective lens can be reproduced from the available Zemax data as follows:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"# Tube lens\nsurf_1 = SphericalSurface(7.744mm, 2*2.812mm, 2*3mm)\nsurf_2 = SphericalSurface(-3.642mm, 2*3mm)\nsurf_3 = SphericalSurface(-14.413mm, 2*2.812mm, 2*3mm)\ndl21 = Lens(surf_1, surf_2, 3.4mm, NLAK22)\ndl22 = Lens(surf_2, surf_3, 1.0mm, NSF4)\ntranslate3d!(dl22, [0, thickness(dl21), 0])\ntube_lens = DoubletLens(dl21, dl22)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Assembling the objective group requires that the individual lens elements be translated into position along the optical axis. This is achieved in the code below by taking the current position of the elements and adding the on-axis thickness in addition to the element distancing taken from the specification.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"translate_to3d!(obj_lens_2, [0, position(obj_lens_1)[2] + thickness(obj_lens_1) + 3.344mm, 0])\ntranslate_to3d!(tube_lens, [0, position(obj_lens_2)[2] + thickness(obj_lens_2) + 2mm, 0])\nobj_group = ObjectGroup([obj_lens_1, obj_lens_2, tube_lens])","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The ObjectGroup locks all elements in place with respect to their relative positions and allows for combined translations and rotations of the elements.","category":"page"},{"location":"tutorials/microscope/#Visualizing-the-lenses","page":"Miniature microscope","title":"Visualizing the lenses","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"In order to visualize what we have done so far, we will use GLMakie to create a 3D plot of the BMO geometry representation. The following code will be used.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"# define rgba for lens look\nlens_color() = RGBf(0.678, 0.847, 0.902)\nlens_color(alpha) = RGBAf(0.678, 0.847, 0.902, alpha)\n\n# generate figure\nfig = Figure()\nax = LScene(fig[1,1])\nrender!(ax, obj_lens_1, transparency=true, color=lens_color(0.5))\nrender!(ax, obj_lens_2, transparency=true, color=lens_color(0.5))\nrender!(ax, tube_lens, transparency=true, color=lens_color(0.5))","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The generated figure can be seen below. A dashdot line has been added to indicate the global y-axis and lens labels are shown for easier viewing.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: Miniscope objective lenses)","category":"page"},{"location":"tutorials/microscope/#The-filter-and-collection-group","page":"Miniature microscope","title":"The filter and collection group","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The miniscope features a dichroic beamsplitter to seperate the emission path from the imaging optics. For the imaging path, the beamsplitter is followed by two filters and a collection lens. For the purpose of this tutorial, we will model the beamsplitter and filters as simple glass plates, i.e. Prisms. However, for an accurate representation, we will first have to move the lens group into position. This involves a rotation around the x-axis by 90°. We can achieve this simply with the following command. Note that the pivot point lies at the origin.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"xrotate3d!(obj_group, deg2rad(90))","category":"page"},{"location":"tutorials/microscope/#Modeling-the-dichroic-filter","page":"Miniature microscope","title":"Modeling the dichroic filter","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Spawning the \"filter\" works as detailled above. Using a Prism to represent the dispersive properties of the substrate glass is functionally equal to using a Lens and serves simply to indicate that this element is not for imaging purposes. Use the following snippet to create the element. Note that the element is moved to its global absolute position. This data is taken from the CAD model provided in the repository.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"## Dichroic \"splitter\" - glass plate\nshape = BMO.CuboidMesh(8mm, 1mm, 8.5mm)\ntranslate3d!(shape, [-4mm, 0.0mm, -4.25mm])\nBMO.set_new_origin3d!(shape)\nsplitter = Prism(shape, NBK7)\n# Move to global position from origin\ntranslate3d!(splitter, [0, 0, 18.677mm])\nxrotate3d!(splitter, deg2rad(45))","category":"page"},{"location":"tutorials/microscope/#Modeling-the-collection-group","page":"Miniature microscope","title":"Modeling the collection group","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"For the collection group filters we use the same approach as above. The collection lens parameters are derived from the Zemax file and the parametrization works analogously as in the section: Building the objective group","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"ef_1 = Prism(BMO.PlanoSurfaceSDF(1mm, 4mm), NBK7)\nef_2 = Prism(BMO.PlanoSurfaceSDF(1mm, 4mm), NBK7)\n\ncollect_lens = Lens(\n    SphericalSurface(6.580mm, 4.5mm),\n    SphericalSurface(-6.580mm, 4.5mm),\n    2.6mm,\n    NLASF44\n)\n\ntranslate3d!(collect_lens, [0, position(ef_1)[2] + thickness(ef_1) + 0.1mm, 0])\ntranslate3d!(ef_2, [0, position(collect_lens)[2] + thickness(collect_lens) + 0.25mm, 0])\n\ncollect_group = ObjectGroup([ef_1, collect_lens, ef_2])\n\n# Move to global position from origin\nxrotate3d!(collect_group, deg2rad(90))\ntranslate3d!(collect_group, [0, 0.332mm, 21.937mm])","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Finally, we can define a System that stores all optical elements for the following ray tracing procedure. ","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"system = System([obj_group, filter, collect_group])","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Elements can still be moved mutably while being inside the system and their final position is considered when running the solve_system! command. Visualizing the system can be easily achieved via render!(ax, system; # kwargs go here). The full optical system is shown below.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: Full miniscope optical system)","category":"page"},{"location":"tutorials/microscope/#Geometrical-ray-tracing-of-the-miniscope","page":"Miniature microscope","title":"Geometrical ray tracing of the miniscope","text":"","category":"section"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"Finally we are ready to perform the ray tracing step. This requires us to have a defined system and one or more beams for the solve_system!(system, beam) function. For more information on this topic, refer to the section: Tracing systems. ","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"This package provides the convenience PointSource which will allows us to model a spread fan of light rays easily. We will define two monochromatic sources for the wavelengths specified above:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"ps_green = PointSource([0, 0, -0.5mm], [0, 0, 1], deg2rad(20), λ_green, num_rays=1000, num_rings=5)\nps_red =   PointSource([0, 0, -0.5mm], [0, 0, 1], deg2rad(30), λ_red,   num_rays=1000, num_rings=5)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The sources for lambda_5461mathrmnm and lambda_6563mathrmnm are initialized 0.5mm below the first optical surface of the imaging system with half-spread-angles of 20° and 30°, respectively. It is important to note that this value was chosen in order to roughly match the illustrated optical path in the miniscope publication [1, Fig. 1]. Feel free to play around the initialization values and observe how they influence the result of the optical path. Further, each source is initialized with a total of 1000 rays layered in 5 rings, where the first \"ring\" is a single beam along the optical axis.","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"In order to calculate the optical path, simply run the following command:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"solve_system!(system, ps_green)\nsolve_system!(system, ps_red)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"The results can be visualized with the following script:","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"fig = Figure()\nax = LScene(fig[1,1])\n\nrender!(ax, system)\nrender!(ax, ps_green; color=RGBAf(0,1,0,1.00), render_every=5, flen=3mm, show_pos=false)\nrender!(ax, ps_red;   color=RGBAf(1,0,0,0.25), render_every=5, flen=3mm, show_pos=false)","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"For the plotting of the PointSource we will use the render_every keyword argument in order to only display every fifth beam. The flen keyword limits the length of the final, non-intersecting ray to 3mm after its last interaction. Below, the resulting figure is displayed (rotated by 90°):","category":"page"},{"location":"tutorials/microscope/","page":"Miniature microscope","title":"Miniature microscope","text":"(Image: Miniscope optical path)","category":"page"},{"location":"design/#API-design","page":"API design","title":"API design","text":"","category":"section"},{"location":"design/","page":"API design","title":"API design","text":"warning: Warning\nThis page is very much WIP...","category":"page"},{"location":"design/#Conventions","page":"API design","title":"Conventions","text":"","category":"section"},{"location":"design/#Right-handedness","page":"API design","title":"Right-handedness","text":"","category":"section"},{"location":"design/","page":"API design","title":"API design","text":"All coordinate systems are or must be defined right-handed! All normal vectors are or must be defined right-handed!  All rotations are or must be performed in a counter-clockwise manner for a positive rotation angle theta  0 and vice-versa! For a definition of rotation matrix order, refer to this article.","category":"page"},{"location":"design/","page":"API design","title":"API design","text":"warning: Warning\nFailure to comply with this convention can lead to spurious effects and silent bugs when using the kinematic API of this package!","category":"page"},{"location":"design/#Intersect-Interact-Repeat-Loop-(IIRP)","page":"API design","title":"Intersect - Interact - Repeat - Loop (IIRP)","text":"","category":"section"},{"location":"design/#Tracing","page":"API design","title":"Tracing","text":"","category":"section"},{"location":"design/#Retracing","page":"API design","title":"Retracing","text":"","category":"section"},{"location":"design/#CPU-and-GPU","page":"API design","title":"CPU and GPU","text":"","category":"section"},{"location":"design/","page":"API design","title":"API design","text":"info: Info\nGPU processing (tracing) of optical systems is  not supported at the moment.","category":"page"},{"location":"design/#Geometry-representation","page":"API design","title":"Geometry representation","text":"","category":"section"},{"location":"design/#Meshes","page":"API design","title":"Meshes","text":"","category":"section"},{"location":"design/#Signed-Distance-Functions-(SDFs)","page":"API design","title":"Signed Distance Functions (SDFs)","text":"","category":"section"},{"location":"design/","page":"API design","title":"API design","text":"For an introduction into SDFs the website of Inigo Quilez is referred to. The following shapes have been implemented:","category":"page"},{"location":"design/","page":"API design","title":"API design","text":"using BeamletOptics # hide\nBeamletOptics.list_subtypes(BeamletOptics.AbstractSDF);","category":"page"},{"location":"examples/double_gauss/#Double-Gauss-lens","page":"Double Gauss lens","title":"Double Gauss lens","text":"","category":"section"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"This showcase is taken from the pencilofrays.com website and will demonstrate how to simulate an advanced lens assembly. Firstly, we will define the spherical lenses based on the data given in the mentioned reference.","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"using CairoMakie, BeamletOptics\n\n# define spherical lenses\nl1 = SphericalLens(48.88e-3, 182.96e-3, 8.89e-3, 52.3e-3, λ -> 1.62286)\nl23 = SphericalDoubletLens(36.92e-3, Inf, 23.06e-3, 15.11e-3, 2.31e-3, 45.11e-3, λ -> 1.58565, λ -> 1.67764)\nl45 = SphericalDoubletLens(-23.91e-3, Inf, -36.92e-3, 1.92e-3, 7.77e-3, 40.01e-3, λ -> 1.57046, λ -> 1.64128)\nl6 = SphericalLens(1063.24e-3, -48.88e-3, 6.73e-3, 45.11e-3, λ -> 1.62286)\n\n# Calculate translation distances\nl_23 = BeamletOptics.thickness(l1) + 0.38e-3\nl_45 = l_23 + BeamletOptics.thickness(l23) + 9.14e-3 + 13.36e-3\nl_6 = l_45 + BeamletOptics.thickness(l45) + 0.38e-3\n\n# move elements into position\ntranslate3d!(l23, [0, l_23, 0])\ntranslate3d!(l45, [0, l_45, 0])\ntranslate3d!(l6, [0, l_6, 0])\n\nsystem = StaticSystem([l1, l23, l45, l6])\n\nnothing # hide","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"Defining a StaticSystem will allow the compiler to generate more efficient code to solve this simulation. Note that the refractive indices above are given as anonymous functions. This is because no lens material is specified. Rather, these indices are unique to lambda =  4860textnm.","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"In the next step, we will define a Figure and Axis3 environment in which the ray-tracing results will be visualized.","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"# generate render\nfig = Figure(size=(600,380))\nax = Axis3(fig[1,1]; aspect=:data, azimuth=0, elevation=1e-3)\n\n# hide decorations for vis. purposes\nhidexdecorations!(ax)\nhidezdecorations!(ax)\n\nrender!(ax, system)","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"For interactive viewing it is recommended that a LScene is used instead of the Axis3 with the GLMakie backend. At this point the system can be solved. A Beam consisting of Rays with the wavelength mentioned above will be used for tracing.","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"λ = 486.0 # nm\nzs = LinRange(-0.02, 0.02, 10)\nfor (i, z) in enumerate(zs)\n    beam = Beam(Ray([0, -0.05, z], [0, 1, 0], λ))\n    solve_system!(system, beam)\n    render!(ax, beam, flen=0.1)\nend\n\nsave(\"double_gauss.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"(Image: Double Gauss lens)","category":"page"},{"location":"examples/double_gauss/#Thin-lens-comparison","page":"Double Gauss lens","title":"Thin lens comparison","text":"","category":"section"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"The back focal length of the Double Gauss lens above is f_textbfl = 5921textmm with an overall effective focal length of f = 100textmm. As a comparison, a thin lens with an analogous focal length will be traced. For simplicity it is assumed that n(lambda = 486textnm) = 15.","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"thin_lens = SphericalLens(100e-3, 100e-3, 0, 52.3e-3, λ -> 1.5)\n\ntl_system = StaticSystem([thin_lens])\n\nfig = Figure(size=(600,380))\naspect = (1,2,1)\nlimits = (-0.05, 0.05, -0.05, 0.15, -0.05, 0.05)\nax = Axis3(fig[1,1]; aspect, limits, azimuth=0, elevation=1e-3)\n\n# hide decorations for vis. purposes\nhidexdecorations!(ax)\nhidezdecorations!(ax)\n\nrender!(ax, tl_system)\n\nλ = 486.0 # nm\nzs = LinRange(-0.02, 0.02, 10)\nfor (i, z) in enumerate(zs)\n    beam = Beam(Ray([0, -0.05, z], [0, 1, 0], λ))\n    solve_system!(tl_system, beam)\n    render!(ax, beam, flen=0.2)\nend\n\nsave(\"thin_lens_f100.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"examples/double_gauss/","page":"Double Gauss lens","title":"Double Gauss lens","text":"(Image: Thin lens with f = 100 mm)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This page contains the full source code documentation and the literature referenced througout this website.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]\nDepth = 5","category":"page"},{"location":"reference/#Literature","page":"Reference","title":"Literature","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"B. A. Madruga, C. C. Dorian, M. Sehgal, A. J. Silva, M. Shtrahman, D. Aharoni and P. Golshani. Open-source, high performance miniature multiphoton microscopy systems for freely behaving animals, bioRxiv (2024).\n\n\n\nA. Manny. Simulation of the contrast mechanisms of a heterodyne two-color interferometer. Master's thesis, Faculty of Aerospace Engineering and Geodesy, University of Stuttgart (Dec 2024).\n\n\n\nG. Yun, K. Crabtree and R. A. Chipman. Three-dimensional polarization ray-tracing calculus I: definition and diattenuation. Appl. Opt. 50, 2855–2865 (2011).\n\n\n\nG. Yun, S. C. McClain and R. A. Chipman. Three-dimensional polarization ray-tracing calculus II: retardance. Appl. Opt. 50, 2866–2874 (2011).\n\n\n\nG. Fowles. Introduction to Modern Optics. Dover Books on Physics Series (Dover Publications, 1989).\n\n\n\nM. Ware and J. Peatross. Physics of Light and Optics (Black & White) (Brigham Young University, Department of Physics, 2015).\n\n\n\nB. Saleh and M. Teich. Fundamentals of Photonics. Wiley Series in Pure and Applied Optics (Wiley, 2019).\n\n\n\nJ. Arnaud. Representation of Gaussian beams by complex rays. Appl. Opt. 24, 538–543 (1985).\n\n\n\nJ. Ashcraft, poke v0.1.0, https://zenodo.org/10.5281/zenodo.7117214 (Sep 2022).\n\n\n\nG. Wanner, E. Kochkina, C. Mahrdt, V. Müller, S. Schuster, G. Heinzel and K. Danzmann. Simulating laser interferometers for missions such as (E)Lisa, Lisa pathfinder and Grace follow-on. In: International Conference on Space Optics — ICSO 2014, Vol. 10563, edited by Z. Sodnik, B. Cugny and N. Karafolas (International Society for Optics and Photonics, SPIE, 2017); p. 105632G.\n\n\n\nR. Herloski, S. Marshall and R. Antos. Gaussian beam ray-equivalent modeling and optical design. Appl. Opt. 22, 1168–1174 (1983).\n\n\n\nD. DeJager and M. Noethen. Gaussian beam parameters that use Coddington-based Y–NU paraprincipal ray tracing. Appl. Opt. 31, 2199–2205 (1992).\n\n\n\nJ. Korger, T. Kolb, P. Banzer, A. Aiello, C. Wittmann, C. Marquardt and G. Leuchs. The polarization properties of a tilted polarizer. Opt. Express 21, 27032–27042 (2013).\n\n\n\n","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/#BeamletOptics.Nullable","page":"Reference","title":"BeamletOptics.Nullable","text":"Nullable{T}\n\nAn alias which results in Union{T, Nothing} to provide a shorter notation for struct fields which can containing nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.NullableVector","page":"Reference","title":"BeamletOptics.NullableVector","text":"NullableVector{T}\n\nAn alias which results in Union{Vector{T}, Nothing} to provide a shorter notation for struct fields which can containing nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RefractiveIndex","page":"Reference","title":"BeamletOptics.RefractiveIndex","text":"RefractiveIndex\n\nUnion type that represents valid means to pass a refractive index n to e.g. AbstractObjects. The core assumption is that:\n\nthe refractive index is callable with a single Number argument λ to represent the wavelength in [m]\nthe return value is a single Number value for the refractive index\n\nRefer to e.g. DiscreteRefractiveIndex.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics._RenderTypes","page":"Reference","title":"BeamletOptics._RenderTypes","text":"A collection of all types from BMO which might be renderable in principle.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractBeam","page":"Reference","title":"BeamletOptics.AbstractBeam","text":"AbstractBeam{T <: Real, R <: AbstractRay{T}}\n\nA generic type for a container type which holds rays, beams etc.\n\nParametrization:\n\nA subtype of AbstractBeam is parameterized by its main data type T <: Real, as well as the underlying ray representation R <: AbstractRay{T}. If a beam is to be compatible with different AbstractRay implementations, it must be parameterized by T and R. However, it can also be set to a fixed type for T and R, i.e. MyBeam <: AbstractBeam{Float32, MyRay}.\n\nImplementation reqs.\n\nSubtypes of AbstractBeam must implement the following:\n\nFields:\n\nparent: a Nullable field that holds the same type as the subtype, used for tree navigation\nchildren: a vector that holds the same type as the subtype, used for sub-beam tracking, i.e. beamsplitting\n\nFunctions:\n\n_modify_beam_head!: modifies the beam path for retracing purposes\n_last_beam_intersection: returns the last Beam intersection\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractBeamGroup","page":"Reference","title":"BeamletOptics.AbstractBeamGroup","text":"AbstractBeamGroup\n\nProvides a generic container type interface for bundles of Beams.  This interface assumes that there exists a central beam around which the bundle propagates, e.g. akin to an optical axis.\n\nImplementation reqs.\n\nSubtypes of AbstractBeamGroup must implement the following:\n\nFields:\n\nbeams: a vector or tuple of Beams\n\nFunctions:\n\nIf the beams field does not exist, the following getters must be dispatched:\n\nbeams: getter for the beams field or equivalent return type\nposition: getter for the starting position of the central Beam\ndirection: getter for the starting direction of the central Beam\nwavelength: getter for the common wavelength of the beam bundle\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractBeamsplitter","page":"Reference","title":"BeamletOptics.AbstractBeamsplitter","text":"AbstractBeamsplitter <: AbstractObject\n\nA generic type to represent an AbstractObject that splits incoming beams by reflection and transmission.\n\nImplementation reqs.\n\nSubtypes of AbstractBeamsplitter should implement all supertype requirements.\n\nInteraction logic\n\nAfter intersection with the AbstractShape at which the beam splitting occurs, the interact3d function  should appended the transmitted and reflected sub-beams to the parent beam via the children! function. The interact3d function should then return nothing in order to stop the tracing of the parent beam.\n\ninfo: Appending convention\nAs a convention, when splitting an incoming beam, the order of children appended to the parent beam should betransmitted beam\nreflected beam\n\nFunctions\n\ninteract3d: see above\n_beamsplitter_transmitted_beam: optional helper function\n_beamsplitter_reflected_beam: optical helper function\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractCylindricalSurfaceSDF","page":"Reference","title":"BeamletOptics.AbstractCylindricalSurfaceSDF","text":"AbstractCylindricalSurfaceSDF <: AbstractLensSDF{T}\n\nA class of AbstractSDFs that can be used to represent cylindric non-rotationally symmetric lens surfaces. It is implicity assumed that all surfaces are represented by closed volumes for ray-tracing correctness.\n\nImplementation reqs.\n\nSubtypes of AbstractCylindricalSurfaceSDF must implement the following additional methods.\n\nFunctions:\n\nheight: this function returns the height of the cylinder part of the surface\nradius: this function returns the radius of the cylinder surface curvature\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractDetector","page":"Reference","title":"BeamletOptics.AbstractDetector","text":"AbstractDetector <: AbstractObject\n\nA generic representation of a detector that evaluates AbstractBeam data during interaction. Refer to Photodetector for more information.\n\nImplementation reqs.\n\nSubtypes of AbstractDetector should implement all supertype requirements as well as:\n\nFunctions\n\ninteract3d: see e.g. Photodetector for reference\nempty!: resets data stored in the detector, see below\n\nAdditional information\n\nThe information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.\n\nData mutability\n\nIn order to model field superposition effects, the concrete implementation of an AbstractDetector should be a mutable struct with a constant shape field. This is necessary, since (sub-)beams will interact sequentially with the detector during solve_system!. Only if the data can be accumulated sequentially, multiple beam interactions can be captured for a complex system, e.g. an interferometer.\n\nData reset\n\nSince e.g. E-field data is supposed to be accumulated by mutability of the detector data, the burden of resetting the data for a new solver call is placed on the user. This function should be called empty!.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractInteraction","page":"Reference","title":"BeamletOptics.AbstractInteraction","text":"AbstractInteraction\n\nDescribes how an AbstractBeam and an AbstractObject interact with each other. This data type stores information from the interact3d function and provides it to the solver. The solver can use this data to extend the AbstractBeam.\n\nImplementation reqs.\n\nSubtypes of AbstractInteraction must implement the following:\n\nFields\n\nhint: a nullable Hint for the solver (optional but recommended)\n\nBeam data\n\nIt is required that concrete implementations of this type provide some form of data on how to extend the beam. For instance, refer to BeamInteraction and GaussianBeamletInteraction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractJonesPolarizer","page":"Reference","title":"BeamletOptics.AbstractJonesPolarizer","text":"AbstractJonesPolarizer <: AbstractObject\n\nRepresents infinitesimally thin components that change the polarization state of incoming PolarizedRays via global Jones matrix calculus. Rather than using the generic Yun ray tracing scheme as referred to in the PolarizedRay docs, this element interacts with the global E-field vector E0 by using a GlobalJonesBasis and projecting the entries into the transverse plane defined by the incoming ray direction and orthogonal E-field vector. This approach is partially inspired by the publication:\n\nJan Korger et al., \"The polarization properties of a tilted polarizer,\" Opt. Express 21, 27032-27042 (2013)\n\nwarning: Warning\nIt is assumed that the ray direction of propagation is not changed during the interaction.\n\nImplementation reqs.\n\nSubtypes of AbstractJonesPolarizer should implement all supertype requirements.\n\nInteraction logic\n\nThe GlobalJonesBasis tracks the rotation in 3D-space via the orientation of the attached AbstractShape. The polarization matrix P is calculated by projecting the previous matrix into the incoming orthogonal plane of polarization. Refer to the _calculate_global_E0 implementation for more information.\n\ninfo: Info\nThe validity of this approach is still under consideration for non-normal incidence.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractLensSDF","page":"Reference","title":"BeamletOptics.AbstractLensSDF","text":"AbstractLensSDF\n\nA class of AbstractSDFs that can be used to represent rotationally symmetric lens surfaces. It is implicity assumed that all surfaces are represented by closed volumes for ray-tracing correctness.\n\nImplementation reqs.\n\nSubtypes of AbstractLensSDF must implement the following:\n\nFunctions:\n\nthickness: this function returns the material thickness of the element along its symmetry axis\ndiameter: this function returns the outer diameter of the element\n\nnote: Shape orientation\nFor easy compatibility between subtypes, the follwing requirements should be fulfilled:Symmetry axis aligned onto the y-axis\nSurface contour aligned towards negative y-values\nSurface point with min(y) should satisfy min(y) = 0 on the symmetry axis\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractMesh","page":"Reference","title":"BeamletOptics.AbstractMesh","text":"AbstractMesh <: AbstractShape\n\nA generic type for an shape whose volume can be described by a mesh. Must have a field mesh of type Mesh. See also Mesh{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractObject","page":"Reference","title":"BeamletOptics.AbstractObject","text":"AbstractObject\n\nA generic type for 2D/3D objects that can be used to model optical elements. The geometry of the object is represented via a AbstractShape. The optical effect that occurs between the object and an incoming ray/beam of light is modeled via its interact3d method.\n\nImplementation reqs.\n\nSubtypes of AbstractObject must implement the following:\n\nShape trait\n\nAn AbstractObject can consist of a single AbstractShape, e.g. a lens element, or a collection of functionally dependant shapes, e.g. a cube beamsplitter. In order to model this, the API implementation of an AbstractObject requires the definition of the shape trait. This trait allows the dispatch onto specialized methods to handle the kinematic interface and tracing methods for objects consisting of one or more shapes.\n\nshape_trait_of: defines the shape type of the AbstractObject, refer to AbstractShapeTrait for more information\n\ninfo: Default shape trait\nUnless specified otherwise, the shape_trait_of an AbstractObject is defined as SingleShape. This requires object.shape as a dedicated field. For MultiShapes the getter function shape(object) must return a tuple of all shapes that make up the object.\n\nGetters/setters\n\nAll kinematic functions defined for the AbstractShape can also be called for a AbstractObject. In this case, the shape trait will define how the specific movement function is dispatched.\n\nFunctions:\n\ninteract3d: defines the optical interaction, the return type must be Nothing or an AbstractInteraction\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractObjectGroup","page":"Reference","title":"BeamletOptics.AbstractObjectGroup","text":"AbstractObjectGroup <: AbstractObject\n\nContainer type for groups of optical elements, based on a tree-like data structure. Intended for easier kinematic handling of connected elements. See also ObjectGroup for a concrete implementation.\n\nImplementation reqs.\n\nSubtypes of AbstractObjectGroup must implement the following:\n\nFields:\n\nobjects: stores objects or additional subgroups of objects, allows for hierarchical structures\n\nFunctions:\n\nfor the kinematic API, all corresponding functions of AbstractObject must be implemented\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractPlateBeamsplitter","page":"Reference","title":"BeamletOptics.AbstractPlateBeamsplitter","text":"AbstractPlateBeamsplitter <: AbstractBeamsplitter\n\nA generic type to represent an AbstractBeamsplitter that consists of a substrate with a  single coated face at which a beam splitting interaction occurs.\n\nImplementation reqs.\n\nSubtypes of AbstractPlateBeamsplitter should implement all supertype reqs. as well as:\n\nFields\n\ncoating: a ThinBeamsplitter that represents the splitter coating\nsubstrate: a Prism that represents the substrate\n\nGetters/setters\n\nIf the concrete implementation does not define the above fields, the following getters must be defined:\n\ncoating: returns a ThinBeamsplitter\nsubstrate: returns a Prism\n\nAdditional information\n\ninfo: Object orientation\nThis interact3d method of this type strongly assumes that the coating is positioned directly upon a single face of the substrate with a 100% fill factor.\n\ninfo: Interaction logic\nThis type uses the Hint-API in order to ensure that the splitting interaction is correctly triggered at the coating.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractRay","page":"Reference","title":"BeamletOptics.AbstractRay","text":"AbstractRay{T<:Real}\n\nAn implementation for a geometrical optics ray in R³. In general, a AbstractRay is described by vecp + tcdotvecd with tin(0infty). AbstractRays are intended to model the propagation of light between optical interactions according to the laws of geometrical optics. To store the result of a ray tracing solution, refer to AbstractBeam.\n\nIntersections:\n\nSince the length of a ray can not be known before solving an optical system, the Intersection-type is used. This Nullable type can represent the intersection with an optical element, or lack thereof.\n\nImplementation reqs.\n\nSubtypes of AbstractBeam must implement the following:\n\nFields:\n\npos: a R³-vector that stores the current position vecp\ndir: a R³-vector that stores the current direction vecd\nintersection: a Nullable field that stores the current [Intersection] or nothing\nλ: wavelength in [m]\nn: refractive index along the ray path\n\nAdditional information\n\ninfo: Ray length\nBase.length: this function is used to return the length of the AbstractRay (if no intersection exists, the ray length is Inf). The opl keyword can be used to obtain the optical path length instead.\n\nwarning: Ray direction\nMany functions assume that the direction vector has unit length (i.e. vecp = 1). Violating this assumption might lead to spurious results.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractReflectiveOptic","page":"Reference","title":"BeamletOptics.AbstractReflectiveOptic","text":"AbstractReflectiveOptic <: AbstractObject\n\nA generic type to represent an [AbstractObject] which reflects incoming rays.\n\nImplementation reqs.\n\nSubtypes of AbstractReflectiveOptic should implement all supertype reqs. as well as:\n\nFields\n\nno specific fields required\n\nGetters/setters\n\nnone required\n\nFunctions\n\ninteract3d:  the interaction logic should be akin to reflection3d for each surface crossing\n\nAdditional information\n\nThe information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.\n\ninfo: Polarization ray tracing\nFresnel coefficients during reflection are set such that no reflection losses occur (i.e. |rₚ| = |rₛ| = 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractRefractiveOptic","page":"Reference","title":"BeamletOptics.AbstractRefractiveOptic","text":"AbstractRefractiveOptic <: AbstractObject\n\nA generic type to represent an AbstractObject that refracts incoming rays.\n\nImplementation reqs.\n\nSubtypes of AbstractRefractiveOptic should implement all supertype reqs. as well as:\n\nFields\n\nn: a callable field which returns the RefractiveIndex for a wavelength λ\n\nGetters/setters\n\nrefractive_index: gets the ref. index data of the optic\n\nFunctions\n\ninteract3d: the interaction logic should be akin to refraction3d for each surface crossing\n\nAdditional information\n\nThe information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.\n\ninfo: Uniform ref. index\nIt is assumed that the optic consists of a single transparent material with a homogeneous refractive index n. It does not consider coated surfaces.\n\ninfo: Polarization ray tracing\nFresnel coefficients at the point of refraction are calculated via the fresnel_coefficients function with the refractive index data of the substrate and the previous medium.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractRotationallySymmetricSurface","page":"Reference","title":"BeamletOptics.AbstractRotationallySymmetricSurface","text":"AbstractRotationallySymmetricSurface{T} <: AbstractSurface{T}\n\nA surface type which is rotationally symmetric around one axis.\n\nImplementation reqs.\n\nSubtypes of AbstractShape should implement the following:\n\nGetters/setters\n\nradius : Returns the radius of curvature of the AbstractRotationallySymmetricSurface\ndiameter : Returns the clear optical diameter of the AbstractRotationallySymmetricSurface\nmechanical_diameter : Returns the mechanical diameter of the AbstractRotationallySymmetricSurface\nedge_sag : Returns the edge sagitta of the AbstractRotationallySymmetricSurface\n\nFunctions:\n\nsdf(::AbstractRotationallySymmetricSurface, ::Union{Nothing, AbstractOrientationType}) :   Converts the surface specification of AbstractRotationallySymmetricSurface into an AbstractSDF\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractSDF","page":"Reference","title":"BeamletOptics.AbstractSDF","text":"AbstractSDF <: AbstractShape\n\nProvides a shape function based on signed distance functions. See https://iquilezles.org/articles/distfunctions/ for more information.\n\nImplementation reqs.\n\nSubtypes of AbstractSDF should implement all reqs. of AbstractShape as well as the following:\n\nFunctions\n\nsdf(::AbstractSDF, point): a function that returns the signed distance for a point in 3D space\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractShape","page":"Reference","title":"BeamletOptics.AbstractShape","text":"AbstractShape{T<:Real}\n\nA generic type for a shape that exists in 3D-space. Must have a position and orientation.\nTypes used to describe the geometry of a shape should be subtypes of Real.\n\n\nImplementation reqs.\n\nSubtypes of AbstractShape should implement the following:\n\nFields:\n\npos: a 3D-vector that stores the current position of the object-specific coordinate system\ndir: a 3x3-matrix that represents the orthonormal basis of the object and therefore, the orientation\n\nGetters/setters\n\nposition / position!: gets or sets the position vector of the AbstractShape\norientation / orientation!: gets or sets the orientation matrix of the AbstractShape\n\nKinematic:\n\ntranslate3d!: the object is moved by a translation vector relative to its current position\ntranslate_to3d!: the object is moved towards the target position\nrotate3d!: the object is rotated by an angle around a reference vector\nxrotate3d!: rotation around the x-axis\nyrotate3d!: rotation around the y-axis\nzrotate3d!: rotation around the z-axis\nalign3d!: align local shape y-axis with target vector\nreset_translation3d!: return the object to the global origin\nreset_rotation3d!: rotate the object back into its original state\n\nRay Tracing:\n\nintersect3d: returns the intersection between an AbstractShape and AbstractRay, or lack thereof. See also Intersection\n\nRendering (with Makie):\n\nRefer to the render! documentation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractShapeTrait","page":"Reference","title":"BeamletOptics.AbstractShapeTrait","text":"AbstractShapeTrait\n\nThe shape trait defines how many shapes an AbstractObject consists of.  Two different traits are defined:\n\nSingleShape: the AbstractObject consists of a single AbstractShape\nMultiShape: the AbstractObject consists of two or more AbstractShapes\n\nRefer to the respective documentation for more information\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractSphericalSurfaceSDF","page":"Reference","title":"BeamletOptics.AbstractSphericalSurfaceSDF","text":"AbstractSphericalSurfaceSDF{T} <: AbstractSDF{T}\n\nAn abstract type for SDF-based volumes which represent spherical lens surfaces, i.e. ConvexSphericalSurfaceSDF or ConcaveSphericalSurfaceSDF.\n\nImplementation reqs.\n\nSubtypes of AbstractSphericalSurfaceSDF should implement all supertype reqs. as well as the following:\n\nFields:\n\nradius: the radius of curvature\ndiameter: the lens outer diameter\nsag: the lens sagitta\n\nLens construction\n\nIt is intended that practical lens shapes are constructed from AbstractSphericalSurfaceSDFs using the UnionSDF type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractSurface","page":"Reference","title":"BeamletOptics.AbstractSurface","text":"AbstractSurface{T}\n\nA generic type for a surface which is basically an information storage type in order to build shapes (volumes) from a combination of surfaces.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AbstractSystem","page":"Reference","title":"BeamletOptics.AbstractSystem","text":"AbstractSystem\n\nA generic representation of a system of optical elements.\n\nImplementation reqs.\n\nSubtypes of AbstractSystem must implement the following:\n\nFields:\n\nobjects: a vector or tuple of AbstractObjects that make up the system\nn: (optional) RefractiveIndex of the surrounding medium, default value is 1.0\n\nFunctions:\n\nrefractive_index: returns the RefractiveIndex n of the system medium, see above\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AconcaveCylinderSDF","page":"Reference","title":"BeamletOptics.AconcaveCylinderSDF","text":"AconcaveCylinderSDF{T} <: AbstractAcylindricalSurfaceSDF{T}\n\nImplements the SDF of a concave cylinder with radius r, diameter d and height h.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AconcaveCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}","page":"Reference","title":"BeamletOptics.AconcaveCylinderSDF","text":"AconcaveCylinderSDF(radius, diameter, height)\n\nConstructs an aconcave cylinder cutout with radius r, diameter d and height h in [m]. The acylindric shape is defined by its conic_constant and the coefficients for the even aspheric polynomoial.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.AconvexCylinderSDF","page":"Reference","title":"BeamletOptics.AconvexCylinderSDF","text":"AconvexCylinderSDF{T} <: AbstractAcylindricalSurfaceSDF{T}\n\nImplements the SDF of a cut cylinder with radius r, diameter d and height h.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AconvexCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}","page":"Reference","title":"BeamletOptics.AconvexCylinderSDF","text":"AconvexCylinderSDF(radius, diameter, height)\n\nConstructs an aconvex cylinder with radius r, diameter d and height h in [m]. The acylindric shape is defined by its conic_constant and the coefficients for the even aspheric polynomoial.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.AcylindricalSurface","page":"Reference","title":"BeamletOptics.AcylindricalSurface","text":"AcylindricalSurface{T} <: AbstractAcylindricalSurface{T}\n\nA type representing an acylindric optical surface defined by its radius of curvature, diameter, height, mechanical diameter, conic constant and even aspheric coefficients. It is therefore a cylindric surface with a deviation from the perfect cylindric shape.\n\nFields\n\nradius::T: The radius of curvature of the curved surface.\ndiameter::T: The clear (optical) aperture of the surface.\nheight::T : The height/length of the uncurved surface direction\nconic_constant::T : The conic_constant of the curved surface\ncoefficients::Vector{T} : The coefficients of the even aspherical equation for the curved surface.\nmechanical_diameter::T: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.AcylindricalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, T4, AbstractVector{T5}}} where {T1, T2, T3, T4, T5}","page":"Reference","title":"BeamletOptics.AcylindricalSurface","text":"AcylindricalSurface(radius, diameter, height, conic_constant, coefficients)\n\nConstruct a CylindricalSurface given the radius of curvature, optical diameter and height. This constructor automatically sets the mechanical diameter equal to the optical diameter.\n\nArguments\n\nradius: The radius of curvature of the curved surface.\ndiameter: The clear (optical) diameter of the surface.\nheight: The height/length of the uncurved surface direction.\nconic_constant::T : The conic_constant of the curved surface\ncoefficients::Vector{T} : The coefficients of the even aspherical equation for the curved surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Beam","page":"Reference","title":"BeamletOptics.Beam","text":"Beam{T, R <: AbstractRay{T}} <: AbstractBeam{T, R}\n\nStores the rays that are calculated from geometric optics when propagating through an optical system. The Beam type is parametrically defined by the AbstractRay subtype that it stores.\n\nFields\n\nrays: vector of AbstractRay objects, representing the rays that make up the beam\nparent: reference to the parent beam, if any (Nullable to account for the root beam which has no parent)\nchildren: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Beam-Union{Tuple{E}, Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}, L, Vector{E}}} where {P, D, L, E}","page":"Reference","title":"BeamletOptics.Beam","text":"Beam(pos, dir, λ, E0)\n\nSpawns a Beam of PolarizedRays at the start position in the specified direction with the wavelength λ and electric field vector E0\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Beam-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}, L, Any}} where {P, D, L}","page":"Reference","title":"BeamletOptics.Beam","text":"Beam(pos, dir, λ, E0)\n\nSpawns a Beam at the start position in the specified direction with the wavelength λ and field vector E0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Beam-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}, L}} where {P, D, L}","page":"Reference","title":"BeamletOptics.Beam","text":"Beam(pos, dir, λ)\n\nSpawns a Beam at the start position in the specified direction with the wavelength λ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.BeamInteraction","page":"Reference","title":"BeamletOptics.BeamInteraction","text":"BeamInteraction <: AbstractInteraction\n\nThis type is used to store the new AbstractRay resulting from on optical interaction between a Beam and some AbstractObject.\n\nFields\n\nhint: optional Hint for the solver\nray: new AbstractRay resulting from the interaction\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.BoxSDF","page":"Reference","title":"BeamletOptics.BoxSDF","text":"BoxSDF <: AbstractSDF\n\nImplements the box SDF with edge lengths x, y, and z. Note that these values are stored in the dimensions field as:\n\ndimensions::Point3 = (   leninx/2,   leniny/2,   leninz/2,\n\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.BoxSDF-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}} where {X<:Real, Y<:Real, Z<:Real}","page":"Reference","title":"BeamletOptics.BoxSDF","text":"BoxSDF(x, y, z)\n\nCreates a BoxSDF with:\n\nx: x-dir. edge length in [m]\ny: y-dir. edge length in [m]\nz: z-dir. edge length in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CircularFlatSurface","page":"Reference","title":"BeamletOptics.CircularFlatSurface","text":"CircularFlatSurface{T} <: AbstractRotationallySurface{T}\n\nA type representing a planar circular surface, which is only parametrized by its diameter.\n\nFields\n\ndiameter::T: The diameter of the planar surface\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CollimatedSource","page":"Reference","title":"BeamletOptics.CollimatedSource","text":"CollimatedSource <: AbstractBeamGroup\n\nRepresents a parallel bundle of Beams being emitted from a disk in space.\n\nFields\n\nbeams: a vector of all Beams originating from the source\ndiameter: the diameter of the outermost beam ring\n\nFunctions\n\ndiameter: returns the diameter of the source\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CollimatedSource-Union{Tuple{L}, Tuple{D2}, Tuple{D1}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D1}, D2}, Tuple{AbstractArray{P}, AbstractArray{D1}, D2, L}} where {P<:Real, D1<:Real, D2<:Real, L<:Real}","page":"Reference","title":"BeamletOptics.CollimatedSource","text":"CollimatedSource(pos, dir, diameter, λ; num_rings, num_rays)\n\nSpawns a bundle of collimated Beams at the specified position and direction. The source is modelled as a ring of concentric beam rings around the center beam. The amount of beam rings between the center ray and outer diameter can be specified via num_rings.\n\ninfo: Info\nNote that for correct sampling, the number of rays should be atleast 20x the number of rings.\n\nArguments\n\nThe following inputs and arguments can be used to configure the CollimatedSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\ndiameter: outer beam bundle diameter in [m]\nλ = 1e-6: wavelength in [m], default val. is 1000 nm\n\nKeyword Arguments\n\nnum_rings: number of concentric beam rings, default is 10\nnum_rays: total number of rays in the source, default is 100x num_rings\n\nwarning: Warning\nThe orthogonal basis vectors for the beam generation are generated randomly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ConcaveAsphericalSurfaceSDF","page":"Reference","title":"BeamletOptics.ConcaveAsphericalSurfaceSDF","text":"ConcaveAsphericalSurfaceSDF\n\nConstructs an aspheric lens with a concave-like surface according to ISO10110.\n\nnote: Note\nCurrently, it is assumed that the aspheric surface is concave if the radius is negative. There might be unexpected effects for complex shapes which do not show a generally concave behavior.\n\ncoefficients : (even) coefficients of the asphere.\nradius : radius of the lens (negative!)\nconic_constant : conic constant of the lens surface\ndiameter: lens diameter\nmechanical_diameter: mechanical lens diameter, defaults to be identical to the lens diameter, Otherwise       an outer ring section will be added to the lens, if mechanical_diameter > diameter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConcaveCylinderSDF","page":"Reference","title":"BeamletOptics.ConcaveCylinderSDF","text":"ConcaveCylinderSDF <: AbstractSDF\n\nImplements the SDF of a concave cylinder with radius r, diameter d and height h.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConcaveCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}","page":"Reference","title":"BeamletOptics.ConcaveCylinderSDF","text":"ConcaveCylinderSDF(radius, diameter, height)\n\nConstructs a concave cylinder with radius r, diameter d and height h in [m].\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ConcaveSphericalMirror","page":"Reference","title":"BeamletOptics.ConcaveSphericalMirror","text":"ConcaveSphericalMirror <: AbstractReflectiveOptic\n\nAn ideal concave mirror with spherical reflecting surface, e.g. R = 1. See also RoundPlanoMirror.\n\nFields\n\nshape: a ConcaveSphericalMirrorShape that represents the substrate\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConcaveSphericalMirror-Tuple{Real, Real, Real}","page":"Reference","title":"BeamletOptics.ConcaveSphericalMirror","text":"ConcaveSphericalMirror(radius, thickness, diameter)\n\nConstructor for a spherical mirror with a concave reflecting surface. The component is aligned with the positive y-axis. See also ConcaveSphericalMirror. \n\nInputs\n\nradius: the spherical surface radius of curvature in [m]\nthickness: substrate thickness in [m]\ndiameter: mirror outer diameter in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ConcaveSphericalMirrorShape","page":"Reference","title":"BeamletOptics.ConcaveSphericalMirrorShape","text":"ConcaveSphericalMirror shape type based on a UnionSDF\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConcaveSphericalSurfaceSDF","page":"Reference","title":"BeamletOptics.ConcaveSphericalSurfaceSDF","text":"ConcaveSphericalSurfaceSDF\n\nAbstractSDF-based representation of a concave spherical lens surface. When constructed, it is assumed that the plano-surface lies at the origin and the optical axis is aligned with the y-axis. The concave surface is orientated towards negative y-values for R > 0 and vice versa.\n\nFields:\n\nradius: the radius of curvature of the convex spherical surface.\ndiameter: the outer diameter of the lens surface\nsag: the sagitta of the opposing convex shape\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConcaveSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}","page":"Reference","title":"BeamletOptics.ConcaveSphericalSurfaceSDF","text":"ConcaveSphericalSurfaceSDF(radius, diameter)\n\nConstructs a ConcaveSphericalSurfaceSDF with a specific radius of curvature and lens outer diameter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ConvexAsphericalSurfaceSDF","page":"Reference","title":"BeamletOptics.ConvexAsphericalSurfaceSDF","text":"ConvexAsphericalSurfaceSDF\n\nConstructs an aspheric lens with a convex-like surface according to ISO10110.\n\nnote: Note\nCurrently, it is assumed that the aspheric surface is convex if the radius is positive. There might be unexpected effects for complex shapes which do not show a generally convex behavior.\n\ncoefficients : (even) coefficients of the asphere.\nradius : radius of the lens\nconic_constant : conic constant of the lens surface\ndiameter: lens diameter\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConvexCylinderSDF","page":"Reference","title":"BeamletOptics.ConvexCylinderSDF","text":"ConvexCylinderSDF <: AbstractSDF\n\nImplements the SDF of a cut cylinder with radius r, diameter d and height h.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConvexCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}","page":"Reference","title":"BeamletOptics.ConvexCylinderSDF","text":"ConvexCylinderSDF(radius, diameter, height)\n\nConstructs a cut cylinder with radius r, diameter d and height h in [m].\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ConvexSphericalSurfaceSDF","page":"Reference","title":"BeamletOptics.ConvexSphericalSurfaceSDF","text":"ConvexSphericalSurfaceSDF\n\nAbstractSDF-based representation of a convex spherical lens surface. When constructed, it is assumed that the plano-surface lies at the origin and the optical axis is aligned with the y-axis. The convex surface is orientated towards negative y-values for R > 0 and vice versa.\n\nFields:\n\nradius: the radius of curvature of the concave spherical surface.\ndiameter: the outer diameter of the lens surface\nsag: the sagitta of the convex shape\nheight: the sphere cutoff height, see also CutSphereSDF\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ConvexSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}","page":"Reference","title":"BeamletOptics.ConvexSphericalSurfaceSDF","text":"ConvexSphericalSurfaceSDF(radius, diameter)\n\nConstructs a ConvexSphericalSurfaceSDF with a specific radius of curvature and lens outer diameter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CubeBeamsplitter","page":"Reference","title":"BeamletOptics.CubeBeamsplitter","text":"CubeBeamsplitter <: AbstractBeamsplitter\n\nA cuboid beamsplitter where the splitting interaction occurs between two RightAnglePrisms. For more information refer to the AbstractPlateBeamsplitter docs.\n\nFields\n\nfront: the forward facing substrate, represented by a RightAnglePrism\nback: the backward facing substrate, represented by a RightAnglePrism\ncoating: a rectangular ThinBeamsplitter that represents the splitting interface\n\nAdditional information\n\ninfo: Hints and interaction logic\nIn order to model gap-free beam propagation, the interact3d model relies heavily on the Hint-API. If the front or back substrate is hit, the Hint will ensure that the beam intersects the coating.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CubeBeamsplitter-Tuple{Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.CubeBeamsplitter","text":"CubeBeamsplitter(leg_length, n; reflectance=0.5)\n\nCreates a CubeBeamsplitter. The cuboid is centered at the origin. The splitter  coating is orientated at a 45° angle with respect to the y-axis.\n\nInputs\n\nleg_length: the x-, y- and z-edge length in [m]\nn: the RefractiveIndex of the front and back prism\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CubeBeamsplitterShape","page":"Reference","title":"BeamletOptics.CubeBeamsplitterShape","text":"Placeholder type for the  shape of a CubeBeamsplitter\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CutSphereSDF","page":"Reference","title":"BeamletOptics.CutSphereSDF","text":"CutSphereSDF <: AbstractSDF\n\nImplements SDF of a sphere which is cut off in the x-z-plane at some point along the y-axis.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CutSphereSDF-Union{Tuple{H}, Tuple{R}, Tuple{R, H}} where {R, H}","page":"Reference","title":"BeamletOptics.CutSphereSDF","text":"CutSphereSDF(pos, radius, height)\n\nConstructs a sphere with radius which is cut off along the y-axis at height.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CylinderSDF","page":"Reference","title":"BeamletOptics.CylinderSDF","text":"CylinderSDF <: AbstractSDF\n\nImplements cylinder SDF. Cylinder is initially orientated along the y-axis and symmetrical in x-z.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CylindricalSurface","page":"Reference","title":"BeamletOptics.CylindricalSurface","text":"CylindricalSurface{T} <: AbstractCylindricalSurface{T}\n\nA type representing a cylindric optical surface defined by its radius of curvature, diameter, height and mechanical diameter\n\nFields\n\nradius::T: The radius of curvature of the curved surface.\ndiameter::T: The clear (optical) aperture of the surface.\nheight::T : The height/length of the uncurved surface direction\nmechanical_diameter::T: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.CylindricalSurface-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"Reference","title":"BeamletOptics.CylindricalSurface","text":"CylindricalSurface(radius::T, diameter::T, height::T) where T\n\nConstruct a CylindricalSurface given the radius of curvature, optical diameter and height. This constructor automatically sets the mechanical diameter equal to the optical diameter.\n\nArguments\n\nradius::T: The radius of curvature of the curved surface.\ndiameter::T: The clear (optical) diameter of the surface.\nheight::T: The height/length of the uncurved surface direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.DiscreteRefractiveIndex","page":"Reference","title":"BeamletOptics.DiscreteRefractiveIndex","text":"DiscreteRefractiveIndex{T}\n\nRepresents a incomplete set of dispersion data where for each exact wavelength one refractive index value is stored in the data field. Can be called like a function n = n(λ). Does not interpolate between data points. Refer to RefractiveIndex for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.DiscreteRefractiveIndex-Union{Tuple{N}, Tuple{L}, Tuple{AbstractArray{L}, AbstractArray{N}}} where {L, N}","page":"Reference","title":"BeamletOptics.DiscreteRefractiveIndex","text":"DiscreteRefractiveIndex(λs, n)\n\nCreates a DiscreteRefractiveIndex dictionary where each wavelength in λs is mapped onto an exact exact refractive index in ns.\n\nInputs\n\nλs: array of wavelengths\nns: array of refractive indices\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.DoubletLens","page":"Reference","title":"BeamletOptics.DoubletLens","text":"DoubletLens\n\nRepresents a two-component cemented doublet lens with two respective refractive indices n = n(λ). See also SphericalDoubletLens.\n\nFields\n\nfront: front Lens component\nback: back Lens component\n\nAdditional information\n\nwarning: Air gap\nThis component type strongly assumes that both lenses are mounted fully flush with respect to each other.  Gaps between the components might lead to incorrect results.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.EvenAsphericalSurface","page":"Reference","title":"BeamletOptics.EvenAsphericalSurface","text":"EvenAsphericalSurface{T} <: AbstractRotationallySymmetricSurface{T}\n\nA type representing an aspherical optical surface defined by its radius of curvature, clear (optical) diameter, conic constant, aspheric coefficients and mechanical diameter. This surface is rotationally symmetric about its optical axis.\n\nFields\n\nspherical::SphericalSurface{T}: The base spherical surface portion of the asphere.\nconic_constant::T: The conic constant defining the deviation from a spherical shape.\ncoefficients::AbstractVector{T}: A vector of even aspheric coefficients for higher-order corrections.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.EvenAsphericalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, AbstractVector{T4}}, Tuple{T1, T2, T3, AbstractVector{T4}, T5}} where {T1, T2, T3, T4, T5}","page":"Reference","title":"BeamletOptics.EvenAsphericalSurface","text":"EvenAsphericalSurface(radius, diameter, conic_constant, coefficients::AbstractVector, mechanical_diameter = diameter)\n\nConstruct a EvenAsphericalSurface given the radius of curvature, the optical diameter, conic constant, the aspheric coefficients and optionally the mechanical diameter. This constructor automatically sets the mechanical diameter equal to the optical diameter.\n\nArguments\n\nradius: The radius of curvature of the base spherical surface.\ndiameter: The clear (optical) diameter of the surface.\nconic_constant: The conic constant defining the deviation from a spherical shape.\ncoefficients::AbstractVector: A vector of even aspheric coefficients for higher-order corrections.\nmechanical_diameter: The mechanical diameter of the surface; if not provided, it defaults to diameter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.GaussianBeamlet","page":"Reference","title":"BeamletOptics.GaussianBeamlet","text":"GaussianBeamlet{T} <: AbstractBeam{T, Ray{T}}\n\nRay representation of the stigmatic Gaussian beam as per J. Arnaud (1985). The beam quality M2 is fully considered via the divergence angle. The formalism for the beam parameter calculation is based on the following publications:\n\nJacques Arnaud, \"Representation of Gaussian beams by complex rays,\" Appl. Opt. 24, 538-543 (1985)\n\nand\n\nDonald DeJager and Mark Noethen, \"Gaussian beam parameters that use Coddington-based Y-NU paraprincipal ray tracing,\" Appl. Opt. 31, 2199-2205 (1992)\n\nFields\n\nchief: a Beam of Rays to store the chief ray\nwaist: a Beam of Rays to store the waist ray\ndivergence: a Beam of Rays to store the divergence ray\nλ: beam wavelength in [m]\nw0: local beam waist radius in [m]\nE0: complex field value in [V/m]\nparent: reference to the parent beam, if any (Nullable to account for the root beam which has no parent)\nchildren: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting\n\nAdditional information\n\ninfo: Beam parameters\nParameters of the beam, e.g. w(z) or R(z), can be obtained through the gauss_parameters function.\n\nwarning: Astigmatism and abberations\nIt is assumed, but not forbidden, that the optical system contains non-flat or non-parabolic beam-surface-interactions that cause the beam to obtain astigmatism or higher-order abberations. These can not be represented by the GaussianBeamlet.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.GaussianBeamlet-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}, Tuple{AbstractArray{P}, AbstractArray{D}, L, Real}} where {P<:Real, D<:Real, L<:Real}","page":"Reference","title":"BeamletOptics.GaussianBeamlet","text":"GaussianBeamlet(position, direction, λ, w0; kwargs...)\n\nConstructs a Gaussian beamlet at its waist with the specified beam parameters.\n\nArguments\n\nThe following inputs and arguments can be used to configure the beamlet:\n\nInputs\n\nposition: origin of the beamlet\ndirection: direction of the beamlet\nλ: wavelength of the beamlet in [m]. Default value is 1000 nm.\nw0: beam waist (radius) in [m]. Default value is 1 mm.\n\nKeyword Arguments\n\nM2: beam quality factor. Default is 1\nP0: beam total power in [W]. Default is 1 mW\nz0: beam waist offset in [m]. Default is 0 m\nsupport: Nullable support vector for the construction of the waist and div rays\n\nAdditional information\n\ntip: Waist offset\nThe z0 keyword arg. can be used in order to spawn a beam where the waist is not located at the specified position, but rather at an offset z0 in [m] along the chief ray axis.\n\ninfo: Support vector\nIn order to calculate the basis vectors required for the beamlet construction, a random orthogonal vector is chosen. If results fluctuate due to the randomness of this vector, make sure to specify a fixed orthogonal support vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.GaussianBeamletInteraction","page":"Reference","title":"BeamletOptics.GaussianBeamletInteraction","text":"GaussianBeamletInteraction <: AbstractInteraction\n\nThis type is used to store the new beamlet section resulting from on optical interaction between a GaussianBeamlet and some AbstractObject. Uses the hint of the chief beam.\n\nFields\n\nchief: Beam interaction\nwaist: Beam interaction\ndivergence: Beam interaction\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.GlobalJonesBasis","page":"Reference","title":"BeamletOptics.GlobalJonesBasis","text":"GlobalJonesBasis <: AbstractJonesMatrix\n\nStores the Jones matrix entries for a polarizing optical element that is aligned with the global y-axis as the optical axis.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Hint","page":"Reference","title":"BeamletOptics.Hint","text":"Hint\n\nA Hint can be passed as part of an AbstractInteraction and will inform the tracing algorithm about which AbstractObject in the AbstractSystem will be hit next.\n\ninfo: Info\nThe hint does not need to result in a guaranteed Intersection.\n\nFields\n\nobject: the object that might or will be intersected as next\nshape: the underlying shape that will be intersected next, i.e. shape(object), relevant for multi-shape objects\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.IntersectableObject","page":"Reference","title":"BeamletOptics.IntersectableObject","text":"IntersectableObject\n\nA passive AbstractObject which can be hit by a beam. In this case, the object acts like a hard target and blocks the beam path.\n\nFields\n\nshape: an AbstractShape\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Intersection","page":"Reference","title":"BeamletOptics.Intersection","text":"Intersection{T}\n\nStores data calculated by the intersect3d method. This information can be reused, i.e. for retracing.\n\nFields:\n\nobject: a Nullable reference to the AbstractObject that has been hit (optional but recommended)\nshape: a Nullable reference to the AbstractShape of the object that has been hit (optional but recommended)\nt: length of the ray parametrization in [m]\nn: normal vector at the point of intersection\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Lens","page":"Reference","title":"BeamletOptics.Lens","text":"Lens{T, S <: AbstractShape{T}, N <: RefractiveIndex} <: AbstractRefractiveOptic{T, S, N}\n\nRepresents an uncoated Lens with a homogeneous RefractiveIndex n = n(λ). Refer to the Lens and SphericalLens constructors for more information on how to generate lenses.\n\nFields\n\nshape: geometry of the lens, refer to AbstractShape for more information\nn: RefractiveIndex function that returns n(λ)\n\nAdditional information\n\ninfo: Refractive index\nThe chromatic dispersion of the lens is represented by a λ-dependent function for n and must be provided by the user. For testing purposes, an anonymous function, e.g. λ -> 1.5 can be passed such that the lens has the same refractive index for all wavelengths.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Lens-Tuple{BeamletOptics.AbstractCylindricalSurface, BeamletOptics.AbstractCylindricalSurface, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.Lens","text":" Lens(front_surface::AbstractCylindricalSurface, back_surface::AbstractCylindricalSurface, center_thickness::Real, n::RefractiveIndex)\n\nConstructs a new Lens object using the cylindric surface specifications front_surface and back_surface and the center_thickness. These inputs are used to construct a UnionSDF that consists of the appropriate sub-SDFs to represent the shape of the lens.\n\nThis method of Lens is specific for cylindric lenses and has some limitations:     - The cylinder height of both surfaces has to be identical     - No mixture with non-cylindric surfaces is supported at the moment\n\nThe material properties are supplied via the n parameter.\n\nAdditional information\n\ninfo: Radius of curvature (ROC) sign definition\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Lens-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractRotationallySymmetricSurface, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.Lens","text":" Lens(front_surface::AbstractRotationallySymmetricSurface, back_surface::AbstractRotationallySymmetricSurface, center_thickness::Real, n::RefractiveIndex)\n\nConstructs a new Lens object using the surface specifications front_surface and back_surface and the center_thickness. These inputs are used to construct a UnionSDF that consists of the appropriate sub-SDFs to represent the shape of the lens.\n\nThe material properties are supplied via the n parameter.\n\nAdditional information\n\ninfo: Radius of curvature (ROC) sign definition\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\nwarning: Meniscus\nIf your specification results in a meniscus lens, only spherical meniscus lenses are supported at the moment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.LocalJonesBasis","page":"Reference","title":"BeamletOptics.LocalJonesBasis","text":"LocalJonesBasis\n\nStores the s-p-basis Jones matrix coefficients. Must be defined for x-y-aligned elements where z is the optical axis.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.MeniscusLensSDF","page":"Reference","title":"BeamletOptics.MeniscusLensSDF","text":"MeniscusLensSDF\n\nAbstractSDF-based representation of a positive or negative meniscus lens. When constructed, it is assumed that the lens lies at the origin and the optical axis is aligned with the y-axis. Parameters that lead to a sharp lens edge will cause an error.\n\nNotes\n\ninfo: Radius of curvature sign convention\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\nFields:\n\nconvex: the convex part of the lens composite SDF\ncylinder: the cylindrical part of the lens composite SDF\nconcave: the concave part of the lens composite SDF\nthickness: lens thickness on the optical axis\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.MeniscusLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R2}, Tuple{R1}, Tuple{R1, R2, L, D, MD}} where {R1, R2, L, D, MD}","page":"Reference","title":"BeamletOptics.MeniscusLensSDF","text":"MeniscusLensSDF(r1::R1, r2::R2, l::L, d::D, md::MD)\n\nConstructs a positive or negative MeniscusLensSDF with:\n\nr1: front surface radis or curvature\nr2: back surface radis or curvature\nl: lens thickness\nd: lens diameter, default value is one inch\nmd: mechanical lens diameter, must be > d\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Mesh","page":"Reference","title":"BeamletOptics.Mesh","text":"Mesh <: AbstractMesh\n\nContains the STL mesh information for an arbitrary shape, that is the vertices that make up the mesh and a matrix of faces, i.e. the connectivity matrix of the mesh. The data is read in using the FileIO.jl and MeshIO.jl packages. Translations and rotations of the mesh are directly saved in absolute coordinates in the vertex matrix. For orientation and translation tracking, a positional and directional matrix are stored.\n\nFields\n\nvertices: (m x 3)-matrix that stores the edge points of all triangles\nfaces: (n x 3)-matrix that stores the connectivity data for all faces\ndir: (3 x 3)-matrix that represents the current orientation of the mesh\npos: 3-element vector that is used as the mesh location reference\nscale: scalar value that represents the current scale of the original mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Mesh-Tuple{Any}","page":"Reference","title":"BeamletOptics.Mesh","text":"Mesh(mesh)\n\nParametric type constructor for struct Mesh. Takes data of type GeometryBasics.Mesh and extracts the vertices and faces. The mesh is initialized at the global origin. Data type of Mesh is variably selected based on type of vertex data (i.e Float32). Mesh data is scaled by factor 1e-3, assuming m scale.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Mirror","page":"Reference","title":"BeamletOptics.Mirror","text":"Mirror{S <: AbstractShape} <: AbstractReflectiveOptic\n\nConcrete implementation of a perfect mirror (R = 1) with arbitrary shape.\n\nwarning: Reflecting surfaces\nIt is important to consider that all surfaces of this mirror type are reflecting!\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.MissingBackendError","page":"Reference","title":"BeamletOptics.MissingBackendError","text":"MissingBackendError\n\nCustom Exception type that indicates that the Makie extension of BeamletOptics has not been loaded correctly.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.MultiShape","page":"Reference","title":"BeamletOptics.MultiShape","text":"MultiShape <: AbstractShapeTrait\n\nRepresents that the AbstractObject consists of a two or more AbstractShapes.\n\nAbstractObject implementation reqs.\n\nIf shape_trait_of(::Foo) = MultiShape() is defined, Foo must implement the following: \n\nFunctions\n\nshape(::Foo): a getter function that returns a Tuple of all relevant shapes, e.g. (foo.front, foo.middle, foo.back)\n\nAdditional information\n\nwarn: Kinematic center\nUnless specified otherwise by dispatching position / position! and orientation / orientation! onto custom pos and dir data fields, the position and orientation of the first element returned by shape(object) will be used as the kinematic center for e.g. translate3d!.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.NonInteractableObject","page":"Reference","title":"BeamletOptics.NonInteractableObject","text":"NonInteractableObject\n\nA passive AbstractObject which does not interact with the ray tracing simulation but can be moved via the kinematic API.\n\nFields\n\nshape: an AbstractShape\n\ninfo: Usage\nThis type is intended mainly for visualization purposes, e.g. kinematic mount Meshs, or similar applications. In essence, this object behaves fully transparent. The intersect3d and interact3d methods default to nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ObjectGroup","page":"Reference","title":"BeamletOptics.ObjectGroup","text":"ObjectGroup <: AbstractObjectGroup\n\nA tree-like storage container for groups of objects. Can store individual objects and subgroups. Main purpose is handling of, i.e., groups of lenses.\n\nFields\n\ncenter: a point in 3D space which is regarded as the reference origin of the group\ndir: a 3x3 matrix that describes the common orientation of the group\nobjects: stores AbstractObject, can also store subgroups of type AbstractObjectGroup\n\nKinematic\n\nA ObjectGroup implements the kinematic functions of AbstractObject. The following logic is applied to\n\ntranslate3d!: all objects in the group are translated by the offset vector\ntranslate_to3d!: all objects are moved in parallel such that the group center is equal to the target position\nrotate3d!: all objects are rotated around the center point with respect to their relative position\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PSFDetector","page":"Reference","title":"BeamletOptics.PSFDetector","text":"PSFDetector{T} <: AbstractDetector{T, Mesh{T}}\n\nRepresents a flat quadratic surface in R³ for capturing the point spread function of a <: AbstractSystem The active surface is discretized in the local R² x-y-coordinate system. Ray hits are recorded by the corresponding interact3d method.\n\nFields\n\nshape: geometry of the active surface, must represent 2D-field in x any y dimensions\ndata : A vector of PSFData capturing the information about each ray hit.\n\nAdditional information\n\nwarning: Reset behavior\nThe PSFDetector must be reset between each call of solve_system! in order to overwrite previous results using the empty! function. Otherwise, the current result will be added onto the previous result.\n\ninfo: Supported beams\nCurrently, only the Beam is supported.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PSFDetector-Tuple{W} where W<:Real","page":"Reference","title":"BeamletOptics.PSFDetector","text":"Photodetector(width)\n\nSpawns a quadratic rectangular 2D PSFDetector that is aligned with the positive y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Photodetector","page":"Reference","title":"BeamletOptics.Photodetector","text":"Photodetector{T, S <: AbstractShape{T}} <: AbstractDetector{T, S}\n\nRepresents a flat rectangular or quadratic surface in R³ that is the active surface of a photodetector. The active surface is discretized in the local R² x-y-coordinate system.\n\nField contributions Eᵢ are added by the corresponding interact3d method.\n\nFunctions\n\nintensity values for the detector surface can be calulcated via intensity\nthe total measured power can be calculated via optical_power\n\nFields\n\nshape: geometry of the active surface, must represent 2D-field in x any y dimensions\nx: linear range of local x-coordinates\ny: linear range of local y-coordinates\nfield: size(x) by size(y) matrix of complex values to store superposition E₀\n\nAdditional information\n\nwarning: Reset behavior\nThe Photodetector must be reset between each call of solve_system! in order to overwrite previous results using the empty! function. Otherwise, the current result will be added onto the previous result.\n\ninfo: Supported beams\nCurrently, only the GaussianBeamlet is supported.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Photodetector-Union{Tuple{T}, Tuple{T, Int64}} where T<:Real","page":"Reference","title":"BeamletOptics.Photodetector","text":"Photodetector(width, n)\n\nSpawns a quadratic rectangular 2D Photodetector that is aligned with the positive y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\nn: field discretization factor, higher results in more computational cost\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PlanoSurfaceSDF","page":"Reference","title":"BeamletOptics.PlanoSurfaceSDF","text":"PlanoSurfaceSDF\n\nAbstractSDF-based representation of two flat optical surfaces, i.e. equivalent to the CylinderSDF. When constructed, it is assumed that the first flat surface lies at the origin and the optical axis is aligned with the positive y-axis.\n\nFields:\n\ndiameter: the outer diameter of the circular flat lens surface\nthickness: the distance between the flat surfaces\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PointSource","page":"Reference","title":"BeamletOptics.PointSource","text":"PointSource <: AbstractBeamGroup\n\nRepresents a cone of Beams being emitted from a single point in space.\n\nFields\n\nbeams: a vector of all Beams originating from the source\nNA: the numerical_aperture of the point source spread angle\n\nFunctions\n\nnumerical_aperture: returns the NA of the source\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PointSource-Union{Tuple{L}, Tuple{H}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}, H}, Tuple{AbstractArray{P}, AbstractArray{D}, H, L}} where {P<:Real, D<:Real, H<:Real, L<:Real}","page":"Reference","title":"BeamletOptics.PointSource","text":"PointSource(pos, dir, θ, λ; num_rings, num_rays)\n\nSpawns a point source of Beams at the specified position and direction. The point source is modelled as a collection of concentric beam fans centered around the center beam. The amount of beam rings between the center ray and half-spread-angle θ can be specified via num_rings.\n\ninfo: Info\nNote that for correct sampling, the number of rays should be atleast 20x the number of rings.\n\nArguments\n\nThe following inputs and arguments can be used to configure the PointSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\nθ: half spread angle in rad\nλ = 1e-6: wavelength in [m], default val. is 1000 nm\n\nKeyword Arguments\n\nnum_rings: number of concentric beam rings, default is 10\nnum_rays: total number of rays in the source, default is 100x num_rings\n\nwarning: Warning\nThe orthogonal basis vectors for the beam generation are generated randomly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PolarizationFilter","page":"Reference","title":"BeamletOptics.PolarizationFilter","text":"PolarizationFilter <: AbstractJonesPolarizer\n\nRepresents a zero-thickness, ideal polarization filter. \n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PolarizationFilter-Tuple{Real}","page":"Reference","title":"BeamletOptics.PolarizationFilter","text":"PolarizationFilter(edge_length; cutoff_strength)\n\nSpawns a thin, rectangular PolarizationFilter. The edge_length has to be specified in [m]. The filter is aligned with the global y-axis and transmits along the x-axis, while blocking polarization components along the global z-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PolarizedRay","page":"Reference","title":"BeamletOptics.PolarizedRay","text":"PolarizedRay{T} <: AbstractRay{T}\n\nA ray type to model the propagation of an electric field vector based on the publication:\n\nYun, Garam, Karlton Crabtree, and Russell A. Chipman. \"Three-dimensional polarization ray-tracing calculus I: definition and diattenuation.\" Applied optics 50.18 (2011): 2855-2865.\n\nThe geometrical ray description is identical to the standard Ray. The polarization interaction can be described in local s-p-coordinates but must be transformed into global coordinates using the method described in the publication above, see also _calculate_global_E0.\n\nFields\n\npos: a point in R³ that describes the Ray origin\ndir: a normalized vector in R³ that describes the Ray direction\nintersection: refer to Intersection\nλ: wavelength in [m]\nn: refractive index along the beam path\nE0: complex-valued 3-tuple to represent the electric field in global coordinates\n\nJones matrices\n\nIn local coordinates the Jones matrices in the case of reflection/refraction are defined as\n\nreflection: [-rₛ 0; 0 rₚ]\ntransmission: [tₛ 0; 0 tₚ]\n\nwhere r and t are the complex-valued Fresnel coefficients (see also fresnel_coefficients).\n\nAdditional information\n\nwarning: Field vector\nIt is assumed that the electric field vector E_0 stays orthogonal to the direction of propagation throughout the optical system.\n\nwarning: Intensity\nE0 can not be converted into an intensity value, since a single PolarizedRay can not directly model the change in intensity during imaging by an optical system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.PolarizedRay-Union{Tuple{E}, Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}, Tuple{AbstractArray{P}, AbstractArray{D}, L, AbstractArray{<:Union{Complex{E}, E}}}} where {P<:Real, D<:Real, L<:Real, E<:Real}","page":"Reference","title":"BeamletOptics.PolarizedRay","text":"PolarizedRay(pos, dir, λ = 1000e-9, E0 = [1, 0, 0])\n\n1 V/m in x-dir.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Prism","page":"Reference","title":"BeamletOptics.Prism","text":"Prism{T, S <: AbstractShape{T}, N <: RefractiveIndex} <: AbstractRefractiveOptic{T, S, N}\n\nEssentially represents the same functionality as Lens. Refer to its documentation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Ray","page":"Reference","title":"BeamletOptics.Ray","text":"Ray{T} <: AbstractRay{T}\n\nMutable struct to store ray information.\n\nFields\n\npos: a point in R³ that describes the Ray origin\ndir: a normalized vector in R³ that describes the Ray direction\nintersection: refer to Intersection\nλ: wavelength in [m]\nn: refractive index along the beam path\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Ray-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}} where {P<:Real, D<:Real, L<:Real}","page":"Reference","title":"BeamletOptics.Ray","text":"Ray(pos, dir, λ=1000e-9)\n\nConstructs a Ray where:\n\npos: is the Ray origin\ndir: is the Ray direction of propagation, normalized to unit length\n\nOptionally, a wavelength λ can be specified. The start refractive index is assumed to be in vacuum (n = 1).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RectangularFlatSurface","page":"Reference","title":"BeamletOptics.RectangularFlatSurface","text":"RectangularFlatSurface{T} <: AbstracCylindricalSurface{T}\n\nA type representing a planar rectangular surface, which is only parametrized by its size.\n\nFields\n\nsize::T: The size of the planar surface\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RectangularPlateBeamsplitter","page":"Reference","title":"BeamletOptics.RectangularPlateBeamsplitter","text":"RectangularPlateBeamsplitter <: AbstractPlateBeamsplitter\n\nA plate beamsplitter with rectangular substrate and a single coated face. For more information refer to the AbstractPlateBeamsplitter docs.\n\nFields\n\nsubstrate: a rectangular Prism that acts as the substrate\ncoating: a ThinBeamsplitter that acts as the coating\n\nAdditional information\n\ninfo: Kinematic center\nThe center of kinematics of this splitter lies at the center of the coating.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RectangularPlateBeamsplitter-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.RectangularPlateBeamsplitter","text":"RectangularPlateBeamsplitter(width, height, thickness, n; reflectance=0.5)\n\nCreates a RectangularPlateBeamsplitter. The splitter is aligned with the negative y-axis. The splitter coating is centered at the origin. See also RoundPlateBeamsplitter.\n\nInputs\n\nwidth: substrate width along the x-axis in [m]\nheight: substrate height along the z-axis in [m]\nthickness: substrate thickness along the y-axis in [m]\nn: the RefractiveIndex of the substrate\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RectangularPlateBeamsplitterShape","page":"Reference","title":"BeamletOptics.RectangularPlateBeamsplitterShape","text":"Placeholder type for the  shape of a RectangularPlateBeamsplitter\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Retroreflector","page":"Reference","title":"BeamletOptics.Retroreflector","text":"Retroreflector\n\nA Retroreflector reflects incoming rays back toward their source, independent of the incident angle. The shape is represented by a tetrahedral Mesh.\n\nFields\n\nmesh: shape of the Retroreflector\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Retroreflector-Tuple{Real}","page":"Reference","title":"BeamletOptics.Retroreflector","text":"Retroreflector(scale)\n\nSpawns a Retroreflector.\n\nInputs\n\nscale: a scaling factor for the size of the retroreflector, e.g. 1e-3 for 1 mm\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RightAnglePrismMirror","page":"Reference","title":"BeamletOptics.RightAnglePrismMirror","text":"RightAnglePrismMirror <: AbstractReflectiveOptic\n\nAn ideal right angle prism mirror with planar reflecting surface, i.e. R = 1. See also Mirror.\n\nFields\n\nshape: a RightAnglePrismSDF that represents the substrate\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RightAnglePrismMirror-Tuple{Real, Real}","page":"Reference","title":"BeamletOptics.RightAnglePrismMirror","text":"RightAnglePrismMirror(leg_length, height)\n\nConstructs a right angle prism mirror. The primary surface is aligned with the pos. y-axis.\n\nInputs\n\nleg_length: edge length in x and y in [m] \nheight: in z-axis in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RightAnglePrismSDF","page":"Reference","title":"BeamletOptics.RightAnglePrismSDF","text":"RightAnglePrismSDF <: AbstractSDF\n\nImplements the SDF of a right angle prism with symmetric leg length l and height h. Note that these values are stored in the dimensions field as:\n\ndimensions::Point3 = (     leglength,     # dim in x     leglength,     # dim in y     height,         # dim in z )\n\ninfo: Alignment\nNote that the prism is not aligned with the positive y-axis!\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RightAnglePrismSDF-Union{Tuple{H}, Tuple{L}, Tuple{L, H}} where {L, H}","page":"Reference","title":"BeamletOptics.RightAnglePrismSDF","text":"RightAnglePrismSDF(leg_length, height)\n\nConstructs a symmetric right angle prism with leg_length in x and y and height z in [m].\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RingSDF","page":"Reference","title":"BeamletOptics.RingSDF","text":"RingSDF <: AbstractSDF\n\nImplements the SDF of a ring in the x-z-plane for some distance in the y axis. This allows to add planar outer sections to any SDF which fits inside of the ring.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RingSDF-Union{Tuple{T}, Tuple{W}, Tuple{R}, Tuple{R, W, T}} where {R, W, T}","page":"Reference","title":"BeamletOptics.RingSDF","text":"RingSDF(inner_radius, width, thickness)\n\nConstructs a ring with inner_radius with a width and some thickness.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RoundPlanoMirror","page":"Reference","title":"BeamletOptics.RoundPlanoMirror","text":"RoundPlanoMirror <: AbstractReflectiveOptic\n\nAn ideal cylindrical mirror with planar reflecting surface, e.g. R = 1. See also Mirror.\n\nFields\n\nshape: a PlanoSurfaceSDF that represents the substrate\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RoundPlanoMirror-Union{Tuple{T}, Tuple{D}, Tuple{D, T}} where {D<:Real, T<:Real}","page":"Reference","title":"BeamletOptics.RoundPlanoMirror","text":"RoundPlanoMirror(diameter, thickness)\n\nReturns a cylindrical, flat RoundPlanoMirror with perfect reflectivity based on:\n\nInputs\n\ndiameter: mirror diameter in [m]\nthickness: mirror substrate thickness in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RoundPlateBeamsplitter","page":"Reference","title":"BeamletOptics.RoundPlateBeamsplitter","text":"RoundPlateBeamsplitter <: AbstractPlateBeamsplitter\n\nA plate beamsplitter with cylindrical substrate and a single coated face. For more information refer to the AbstractPlateBeamsplitter docs.\n\nFields\n\nsubstrate: a cylindrical Prism that acts as the substrate\ncoating: a RoundThinBeamsplitter that acts as the coating\n\nAdditional information\n\ninfo: Kinematic center\nThe center of kinematics of this splitter lies at the center of the coating.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.RoundPlateBeamsplitter-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.RoundPlateBeamsplitter","text":"RoundPlateBeamsplitter(diameter, thickness, n; reflectance=0.5)\n\nCreates a RoundPlateBeamsplitter. The splitter is aligned with the negative y-axis. The coating is centered at the origin. See also RectangularPlateBeamsplitter.\n\nInputs\n\ndiameter: x-z-plane substrate diameter in [m]\nthickness: substrate thickness along the z-axis in [m]\nn: the RefractiveIndex of the substrate\n\nKeywords\n\nreflectance: defines the splitting ratio in [-], i.e. R = 0 ... 1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RoundPlateBeamsplitterShape","page":"Reference","title":"BeamletOptics.RoundPlateBeamsplitterShape","text":"Placeholder type for the  shape of a RoundPlateBeamsplitterShape\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.SellmeierEquation","page":"Reference","title":"BeamletOptics.SellmeierEquation","text":"SellmeierEquation\n\nA parametric type representing the six-coefficient Sellmeier equation for a transparent dielectric material. The Sellmeier equation models the wavelength dependence of the refractive index n(λ) in the material's transparency window. This type can provide n(λ) via a functor call, e.g.:\n\nNBK7 = SellmeierEquation(...)\nn_532 = NBK7(532e-9)\n\ninfo: Info\nWhen initializing this type, the data should be provided with the classic μm-based coefficients. However, when calling the function, use SI-units, e.g. 532e-9 for 532 nm. \n\nFields\n\nB1, B2, B3 : dimensionless Sellmeier coefficients.\nC1, C2, C3 : squared resonance wavelengths in μm².\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.SellmeierEquation-Tuple{Any}","page":"Reference","title":"BeamletOptics.SellmeierEquation","text":"Returns the ref. index n(λ) for the six coefficient Sellmeier equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.SingleShape","page":"Reference","title":"BeamletOptics.SingleShape","text":"SingleShape <: AbstractShapeTrait\n\nRepresents that the AbstractObject consists of a single underlying shape.\n\nAbstractObject implementation reqs.\n\nIf shape_trait_of(::Foo) = SingleShape() is defined, Foo must implement the following: \n\nFields\n\nshape: a single concrete AbstractShape, e.g. a CylinderSDF\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.SphereSDF","page":"Reference","title":"BeamletOptics.SphereSDF","text":"SphereSDF\n\nImplements the SDF of a perfect sphere. Orientation is fixed to unity matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.SphericalSurface","page":"Reference","title":"BeamletOptics.SphericalSurface","text":"SphericalSurface{T} <: AbstractRotationallySymmetricSurface{T}\n\nA type representing a spherical optical surface defined by its radius of curvature, clear (optical) diameter, and mechanical diameter. This surface is rotationally symmetric about its optical axis.\n\nFields\n\nradius::T: The radius of curvature of the spherical surface. A positive value indicates that the center of curvature lies to the right of the vertex (following ISO 10110).\ndiameter::T: The clear (optical) aperture of the surface.\nmechanical_diameter::T: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.SphericalSurface-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R<:Real, D<:Real}","page":"Reference","title":"BeamletOptics.SphericalSurface","text":"SphericalSurface(radius, diameter)\n\nConstruct a SphericalSurface given the radius of curvature and the optical diameter. This constructor automatically sets the mechanical diameter equal to the optical diameter.\n\nArguments\n\nradius: The radius of curvature of the surface.\ndiameter: The clear (optical) diameter of the surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.Spotdetector","page":"Reference","title":"BeamletOptics.Spotdetector","text":"Spotdetector <: AbstractDetector\n\nSimple 2D screen that stores the intersection point of incoming Beams. The intersection points are stored in local coordinates of the detector with respect to the screen origin.\n\nFields\n\nshape: a 2D QuadraticFlatMesh that is aligned with the negative y-axis\ndata: stores the intersection points as Point2\nhw: half-width of the detector plane\n\nAdditional information\n\ninfo: Normal vector\nCheck the normal vector orientation of the detector plane if the spot diagram looks mirrored.\n\nwarning: Reset behavior\nSpot diagram data must be manually reset between traces via empty!\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.Spotdetector-Tuple{W} where W<:AbstractFloat","page":"Reference","title":"BeamletOptics.Spotdetector","text":"Spotdetector(width)\n\nGenerates a quadratic rectangular 2D Spotdetector that is aligned with the negative y-axis. Refer to the type docs for more information.\n\nInputs:\n\nwidth: edge length in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.StaticSystem","page":"Reference","title":"BeamletOptics.StaticSystem","text":"StaticSystem <: AbstractSystem\n\nA static container storing the optical elements of, i.e. a camera lens or lab setup. Compared to System this way defining the system is less flexible, i.e. no elements can be added or removed after construction but it allows for more performant ray-tracing.\n\nwarning: Warning\nThis type uses long tuples for storing the elements. This container should not be used for very large optical systems as it puts a lot of stress onto the compiler.\n\nFields\n\nobjects: vector containing the different objects that are part of the system (subtypes of AbstractObject)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.System","page":"Reference","title":"BeamletOptics.System","text":"System <: AbstractSystem\n\nA container storing the optical elements of, i.e. a camera lens or lab setup.\n\nFields\n\nobjects: vector containing the different objects that are part of the system (subtypes of AbstractObject)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ThinBeamsplitter","page":"Reference","title":"BeamletOptics.ThinBeamsplitter","text":"ThinBeamsplitter <: AbstractBeamsplitter\n\nRepresents a 2D beam-splitting device. \n\nFields\n\nshape: 2D AbstractShape at which the splitting process occurs (e.g. a 2D-Mesh)\nreflectance: scalar reflection factor\ntransmittance: scalar transmission factor\n\nwarning: Warning\nNote that the transmittance should be calculated from an input reflectance in order to ensure that R² + T² = 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BeamletOptics.ThinBeamsplitter-Tuple{Real, Real}","page":"Reference","title":"BeamletOptics.ThinBeamsplitter","text":"ThinBeamsplitter(width, height; reflectance=0.5)\n\nCreates a zero-thickness, lossless, non-polarizing 2D rectangular ThinBeamsplitter where\n\nwidth: is the x-dir. edge length in [m]\nheight: is the z-dir. edge length in [m]\nreflectance: kw-arg that determines how much light is reflected, i.e. 0.7 for a 70:30 splitter\n\nAdditional information\n\ninfo: Reflectance\nThe input value for the reflectance R is normed such that R² + T² = 1, where T is the transmittance. The transmittance is calculated via T = √(1 - R²).\n\nwarning: Reflection phase jump\nNote that the reflection phase jump θᵣ is implemented by the individual interact3d-methods. Refer to them for more information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.UnionSDF","page":"Reference","title":"BeamletOptics.UnionSDF","text":"UnionSDF{T, TT <: Tuple} <: AbstractSDF{T}\n\nThis SDF represents the merging of two or more SDFs. If the constituent SDFs do not overlap (they can and should touch) the resulting SDF should be still exact if the constituent SDFs are exact.\n\nThe intended way to construct these is not explicitely but by just adding two AbstractSDFs using the regular + operator.\n\ns1 = SphereSDF(1.0)\ntranslate3d!(s1, Point3(0, 1.0, 0.0))\n\ns2 = SphereSDF(1.0)\n\n# will result in a SDF with two spheres touching each other.\ns_merged = s1 + s2\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.empty!-Tuple{D} where D<:BeamletOptics.AbstractDetector","page":"Reference","title":"Base.empty!","text":"empty!(detector)\n\nResets the field data of the detector. Must be implemented for each concrete subtype of AbstractDetector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.empty!-Tuple{Spotdetector}","page":"Reference","title":"Base.empty!","text":"Resets the stored spot diagram data\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.empty!-Union{Tuple{Photodetector{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Reference","title":"Base.empty!","text":"Resets the values currently stored in pd.field to zero\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T","page":"Reference","title":"Base.length","text":"Base.length(ray::AbstractRay)\n\nReturns the geometric length of a ray between its start and intersection point. If no intersection exists, Inf is returned.\n\ntip: Tip\nUse optical_path_length to get the optical path length instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Union{Tuple{Beam{T, R} where R<:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T","page":"Reference","title":"Base.length","text":"Base.length(beam::Beam)\n\nCalculate the length of a beam up to the point of the last intersection.\n\ntip: Tip\nUse optical_path_length to get the optical path length instead.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.position-Tuple{BeamletOptics.AbstractObject}","page":"Reference","title":"Base.position","text":"position(object) -> Point3\n\nReturns the current position of the object in R³ as a Point3 where (x, y, z) in a right-hand coordinate system.\n\nIn general, position(object) returns position(shape(object)) unless specified otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.position-Tuple{BeamletOptics.AbstractShape}","page":"Reference","title":"Base.position","text":"Enforces that shape has to have the field pos or implement position().\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.BiConcaveLensSDF-Union{Tuple{MD}, Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N, O, MD}} where {L, M, N, O, MD}","page":"Reference","title":"BeamletOptics.BiConcaveLensSDF","text":"BiConcaveLensSDF(r1, r2, l, d=1inch)\n\nConstructs a bi-concave lens SDF with:\n\nr1 > 0: radius of concave front\nr2 > 0: radius of convex back\nl: lens thickness\nd: lens diameter, default value is one inch\nmd: mechanical lens diameter, adds an outer ring section to the lens, if md > d.\n\nThe spherical surfaces are constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.BiConvexLensSDF-Union{Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N}, Tuple{L, M, N, O}} where {L, M, N, O}","page":"Reference","title":"BeamletOptics.BiConvexLensSDF","text":"BiConvexLensSDF(r1, r2, l, d=1inch)\n\nConstructs a cylindrical bi-convex lens SDF with:\n\nr1 > 0: radius of convex front\nr2 > 0: radius of convex back\nl: lens thickness\nd: lens diameter, default value is one inch\n\nThe spherical surfaces are constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CircularFlatMesh-Union{Tuple{T}, Tuple{T, Int64}} where T<:Real","page":"Reference","title":"BeamletOptics.CircularFlatMesh","text":"CircularFlatMesh(radius, n)\n\nCreates a 2D rectangular Mesh that is centered around the origin and aligned with respect to the negative y-axis.\n\nInputs\n\nradius: of the mesh in [m]\nn: slice discretization factor (higher equals better resolution)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CubeMesh-Tuple{Real}","page":"Reference","title":"BeamletOptics.CubeMesh","text":"Refer to CuboidMesh.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.CuboidMesh-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}, Tuple{X, Y, Z, Real}} where {X<:Real, Y<:Real, Z<:Real}","page":"Reference","title":"BeamletOptics.CuboidMesh","text":"CuboidMesh(x, y, z, θ=π/2)\n\nConstructs the Mesh of a rectangular cuboid as per the dimensions specified by x, y and z. In addition, one side of the mesh can be tilted by an angle θ in order to generate the mesh of a rhomb. The mesh is initialized such that one corner of the cuboid lies at the origin.\n\nArguments\n\nx, y, z: dimensions for the cube in [m]\nθ: parallel tilt angle\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.MoellerTrumboreAlgorithm-Union{Tuple{T}, Tuple{Any, BeamletOptics.AbstractRay{T}}} where T","page":"Reference","title":"BeamletOptics.MoellerTrumboreAlgorithm","text":"MoellerTrumboreAlgorithm(face::Matrix, ray::Ray)\n\nA culling implementation of the Möller-Trumbore algorithm for ray-triangle-intersection. This algorithm evaluates the possible intersection between a ray and a face that is defined by three vertices. If no intersection occurs, Inf is returned. kϵ is the abort threshold for backfacing and non-intersecting triangles. lϵ is the threshold for negative values of t. This algorithm is fast due to multiple breakout conditions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PlanoConcaveAsphericalLensSDF-Union{Tuple{MD}, Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}, Tuple{R, L, D, K, AbstractVector{A}, MD}} where {R, L, D, K, A, MD}","page":"Reference","title":"BeamletOptics.PlanoConcaveAsphericalLensSDF","text":"PlanoConcaveAsphericalLensSDF(r, l, d=1inch)\n\nConstructs a plano-concave aspheric lens SDF with:\n\nr > 0: front radius\nl: lens thickness\nd: lens diameter\ncz: aspheric surface chip zone\nk : The conic constant of the surface\nα_coeffs : The (even) aspheric coefficients, starting with A4.\nmd: lens mechanical diameter (default: md = d)\n\nThe spherical surface is constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PlanoConcaveLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, MD}} where {R, L, D, MD}","page":"Reference","title":"BeamletOptics.PlanoConcaveLensSDF","text":"PlanoConcaveLensSDF(r, l, d=1inch)\n\nConstructs a plano-concave lens SDF with:\n\nr > 0: front radius\nl: lens thickness\nd: lens diameter, default value is one inch\nmd: mechanical lens diameter, must be > d\n\nThe spherical surface is constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PlanoConvexAsphericalLensSDF-Union{Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}} where {R, L, D, K, A}","page":"Reference","title":"BeamletOptics.PlanoConvexAsphericalLensSDF","text":"PlanoConvexAsphericalLensSDF(r, l, d=1inch)\n\nConstructs a plano-convex aspheric lens SDF with:\n\nr > 0: front radius\nl: lens thickness\nd: lens diameter\nk : The conic constant of the surface\nα_coeffs : The (even) aspheric coefficients, starting with A4.\n\nThe spherical surface is constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.PlanoConvexLensSDF-Union{Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L}, Tuple{R, L, D}} where {R, L, D}","page":"Reference","title":"BeamletOptics.PlanoConvexLensSDF","text":"PlanoConvexLensSDF(r, l, d=1inch)\n\nConstructs a plano-convex lens SDF with:\n\nr > 0: front radius\nl: lens thickness\nd: lens diameter, default value is one inch\n\nThe spherical surface is constructed flush with the cylinder surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.QuadraticFlatMesh-Tuple{Real}","page":"Reference","title":"BeamletOptics.QuadraticFlatMesh","text":"QuadraticFlatMesh(width)\n\nCreates a 2D quadratic Mesh. Refer to RectangularFlatMesh for more information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RectangularCompensatorPlate-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}} where {W<:Real, H<:Real, T<:Real}","page":"Reference","title":"BeamletOptics.RectangularCompensatorPlate","text":"RectangularCompensatorPlate(width, height, thickness, n)\n\nCreates a compensator plate (modeled as a Prism) that can be used to remove parallel beam offsets created by e.g. the RectangularPlateBeamsplitter. The compensator is aligned with the positive y-axis. The first surface lies at the origin.\n\nInputs\n\nwidth: compensator width along the x-axis in [m]\nheight: compensator height along the z-axis in [m]\nthickness: compensator thickness along the y-axis in [m]\nn: the RefractiveIndex of the substrate\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RectangularFlatMesh-Union{Tuple{H}, Tuple{W}, Tuple{W, H}} where {W<:Real, H<:Real}","page":"Reference","title":"BeamletOptics.RectangularFlatMesh","text":"RectangularFlatMesh(width, height)\n\nCreates a 2D rectangular Mesh that is centered around the origin and aligned with respect to the y-axis. Vertex normals are parallel to the positive y-axis.\n\nInputs\n\nwidth: width along the x-axis in [m]\nheight: height along the z-axis in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RectangularPlanoMirror-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T}} where {W<:Real, H<:Real, T<:Real}","page":"Reference","title":"BeamletOptics.RectangularPlanoMirror","text":"RectangularPlanoMirror(width, height, thickness)\n\nConstructs a rectangular plano Mirror based on the input dimensions. The front reflecting surface is normal to the y-axis and lies at the origin.\n\nInputs\n\nwidth:      of the mirror in x-direction [m] \nheight:     of the mirror in z-direction [m] \nthickness:  of the mirror in y-direction [m] \n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RetroMesh-Tuple{Real}","page":"Reference","title":"BeamletOptics.RetroMesh","text":"RetroMesh(scale::Real; T = Float64)\n\nCreates an open tetrahedral Mesh with edges derived from the vertices of a unit cube. Can be scaled with a scale factor. The data type for the vertices and internal computations can be adjusted using T (default: Float64).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.RightAnglePrism","text":"RightAnglePrism(leg_length, height, n)\n\nCreates a right angle symmetric Prism. The prism is not aligned with the y-axis.\n\nInputs\n\nleg_length: dimension in x- and y-direction in [m]\nheight: in [m]\nn: RefractiveIndex of the prism\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.RoundThinBeamsplitter-Tuple{Real}","page":"Reference","title":"BeamletOptics.RoundThinBeamsplitter","text":"RoundThinBeamsplitter(diameter; reflectance=0.5)\n\nCreates a zero-thickness, 2D round ThinBeamsplitter with the specified diameter in [m]. For more information, refer to the ThinBeamsplitter constructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.SphericalDoubletLens-NTuple{8, Any}","page":"Reference","title":"BeamletOptics.SphericalDoubletLens","text":"SphericalDoubletLens(r1, r2, r3, l1, l2, d, n1, n2)\n\nGenerates a two-component \"cemented\" doublet lens consisting of two spherical lenses. For radii sign definition, refer to the SphericalLens constructor.\n\nArguments\n\nr1: radius of curvature for first surface\nr2: radius of curvature for second (cemented) surface\nr3: radius of curvature for third surface\nl1: first lens thickness\nl2: second lens thickness\nd: lens diameter\nn1: first lens RefractiveIndex\nn1: second lens RefractiveIndex\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.SphericalLens","page":"Reference","title":"BeamletOptics.SphericalLens","text":"SphericalLens(r1, r2, l, d=1inch, n=λ->1.5)\n\nCreates a spherical Lens based on:\n\nr1: front radius\nr2: back radius\nl: lens thickness\nd: lens diameter, default is one inch\nn: RefractiveIndex as a function of λ, i.e. n = n(λ)\n\nNotes\n\ninfo: Radius of curvature (ROC) sign\nThe ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.\n\ninfo: Thin lenses\nIf l is set to zero, a ThinLens will be created. However, note that the actual lens thickness will be different from zero.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.SquarePlanoMirror-Union{Tuple{T}, Tuple{W}, Tuple{W, T}} where {W<:Real, T<:Real}","page":"Reference","title":"BeamletOptics.SquarePlanoMirror","text":"SquarePlanoMirror(width, thickness)\n\nConstructs a square plano Mirror with equal width and height. The front reflecting surface is normal to the y-axis and lies at the origin. See also RectangularPlanoMirror.\n\nInputs\n\nwidth: the side length of the square mirror in x- and y-direction [m]\nthickness: of the mirror in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.SquarePlanoMirror2D-Tuple{T} where T<:Real","page":"Reference","title":"BeamletOptics.SquarePlanoMirror2D","text":"SquarePlanoMirror2D(edge_length)\n\nConstructs a 2D square plano Mirror with a given edge_length. The reflecting surface is normal to the y-axis.\n\nInputs\n\nedge_length: the edge length of the square mirror in [m]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ThinLens-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex, SellmeierEquation}}","page":"Reference","title":"BeamletOptics.ThinLens","text":"ThinLens(R1::Real, R2::Real, d::Real, n::Function)\n\nDirectly creates an ideal spherical thin Lens with radii of curvature R1 and R2 and diameter d and RefractiveIndex n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.ThinLensSDF-Union{Tuple{O}, Tuple{M}, Tuple{L}, Tuple{L, M}, Tuple{L, M, O}} where {L, M, O}","page":"Reference","title":"BeamletOptics.ThinLensSDF","text":"ThinLensSDF(r1, r2, d=1inch)\n\nConstructs a bi-convex thin lens SDF-based shape with:\n\nr1 > 0: radius of convex front\nr2 > 0: radius of convex back\nd: lens diameter, default value is one inch\n\nThe spherical surfaces are constructed flush.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.UniformDiscSource-Union{Tuple{L}, Tuple{D2}, Tuple{D1}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D1}, D2}, Tuple{AbstractArray{P}, AbstractArray{D1}, D2, L}} where {P<:Real, D1<:Real, D2<:Real, L<:Real}","page":"Reference","title":"BeamletOptics.UniformDiscSource","text":"UniformDiscSource(pos, dir, diameter, λ; num_rays=1_000)\n\nGenerates a ray fan with equal area per ray across a circular pupil using the deterministic sunflower (Fibonacci) pattern.\n\nnote: Note\nThis is merely a CollimatedSource constructor which uses Fibonacci sampling instead of a linear grid.\n\nArguments\n\nThe following inputs and arguments can be used to configure the underlying CollimatedSource:\n\nInputs\n\npos: center beam starting position\ndir: center beam starting direction\ndiameter: outer beam bundle diameter in [m]\nλ = 1e-6: wavelength in [m]\n\nKeyword Arguments\n\nnum_rays=1000: total number of rays in the source\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._beams_hits_same_shape-Tuple{GaussianBeamlet, Int64}","page":"Reference","title":"BeamletOptics._beams_hits_same_shape","text":"_beams_hits_same_shape(gauss, id)\n\nTests if all rays at section id of gauss hit the same object shape. Returns true or false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._calculate_global_E0-Tuple{AbstractArray, AbstractArray, AbstractArray, BeamletOptics.LocalJonesBasis}","page":"Reference","title":"BeamletOptics._calculate_global_E0","text":"_calculate_global_E0(in_dir, out_dir, normal, J)\n\nCalculates the resulting polarization matrix as per the publication by Yun et al. for each surface interaction. If the normal- vector and the in- and out-directions of propagation are in parallel, an arbitrary basis is chosen for the s- and p-components.\n\nArguments\n\nin_dir: propagation direction before surface interaction\nout_dir: propagation direction after surface interaction\nnormal: surface normal at the point of intersection\nJ: Jones matrix extended to 3x3, e.g. [-rₛ 0 0; 0 rₚ 0; 0 0 1] for reflection\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._modify_beam_head!-Union{Tuple{R}, Tuple{T}, Tuple{Beam{T, R}, Beam{T, R}}} where {T<:Real, R<:PolarizedRay{T}}","page":"Reference","title":"BeamletOptics._modify_beam_head!","text":"Used mainly for retracing. Updates beam children data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._modify_beam_head!-Union{Tuple{R}, Tuple{T}, Tuple{Beam{T, R}, Beam{T, R}}} where {T<:Real, R<:Ray{T}}","page":"Reference","title":"BeamletOptics._modify_beam_head!","text":"Used mainly for retracing. Updates beam children data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._raymarch_inside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}","page":"Reference","title":"BeamletOptics._raymarch_inside","text":"_raymarch_inside(object::AbstractSDF, pos, dir; num_iter=1000, dl=0.1)\n\nPerform the ray marching algorithm if the starting pos is inside of object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._raymarch_outside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}","page":"Reference","title":"BeamletOptics._raymarch_outside","text":"_raymarch_outside(shape::AbstractSDF, pos, dir; num_iter=1000, eps=1e-10)\n\nPerform the ray marching algorithm if the starting pos is outside of shape.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics._world_to_sdf-Tuple{BeamletOptics.AbstractSDF, Any}","page":"Reference","title":"BeamletOptics._world_to_sdf","text":"_world_to_sdf(sdf, point)\n\nTransforms the coordinates of point into a reference frame where the sdf lies at the origin. Useful to represent translation and rotation. If rotations are applied, the rotation is applied around the local sdf coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractMesh, Any}","page":"Reference","title":"BeamletOptics.align3d!","text":"align3d!(mesh, target_axis)\n\nAligns the local mesh y-axis onto the target_axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractShape, Any}","page":"Reference","title":"BeamletOptics.align3d!","text":"align3d!(shape, target_axis)\n\nRotates the shape such that its local y-axis aligns with the target_axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.align3d-Union{Tuple{B}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{B}}} where {A, B}","page":"Reference","title":"BeamletOptics.align3d","text":"align3d(start::AbstractVector, target::AbstractVector)\n\nReturns the rotation matrix R that will align the start vector to be parallel to the target vector. Based on 'Avoiding Trigonometry' by Íñigo Quílez. The resulting matrix was transposed due to column/row major issues. Vector length is maintained. This function is very fast.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.angle3d","page":"Reference","title":"BeamletOptics.angle3d","text":"angle3d(ray::AbstractRay, intersect::Intersection=intersection(ray))\n\nCalculates the angle between a ray and its or some other intersection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.angle3d-Union{Tuple{R}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{R}}} where {T, R}","page":"Reference","title":"BeamletOptics.angle3d","text":"angle3d(target::AbstractVector, reference::AbstractVector)\n\nReturns the angle between the target and reference vector in rad.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.aspheric_equation-NTuple{4, Any}","page":"Reference","title":"BeamletOptics.aspheric_equation","text":"asphericequation(r, c, k, αcoeffs)\n\nThe aspheric surface equation. The asphere is defined by:\n\nc : The curvature (1/radius) of the surface\nk : The conic constant of the surface\nα_coeffs : The (even) aspheric coefficients, starting with A4.\n\nThis function returns NaN if the square root argument becomes negative.\n\nnote: Note\n\n\nOnly even aspheres are implemented at the moment. This will change soon.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.base_transform","page":"Reference","title":"BeamletOptics.base_transform","text":"base_transform(base, base2=I(3))\n\nReturn the base transformation matrix for transforming from vectors given relative to base2 into base.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.bounding_sphere-Tuple{BeamletOptics.AbstractSDF}","page":"Reference","title":"BeamletOptics.bounding_sphere","text":"bounding_sphere(sdf)\n\nReturns nothing or a center point and the radius of a sphere which encloses the shape of the SDF. This function is currently only used for rendering SDFs but might be used in the future to optimize the raymarching algorithm, by tracing against the bounding sphere of and SDF first, instead of calling the more costly complex SDF.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.calc_local_lims-Union{Tuple{PSFDetector{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.calc_local_lims","text":"calc_local_lims(psf; crop_factor=1, center=:centroid)\n\nCompute a symmetric [xmin,xmax]×[zmin,zmax] box around the PSF’s weighted centroid.\n\n• If center==:centroid (the default), uses     x0 = ∑ wᵢ·xᵢ / ∑ wᵢ,  z0 = ∑ wᵢ·yᵢ / ∑ wᵢ   with wᵢ = projection_factor. • If center==:bbox, falls back to the midpoint of [min,max].\n\nReturns (x_min, x_max, z_min, z_max).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.children!-Union{Tuple{B}, Tuple{B, B}} where B<:BeamletOptics.AbstractBeam","page":"Reference","title":"BeamletOptics.children!","text":"children!(beam::B, child::B) where {B<:AbstractBeam}\n\nHandles the inclusion of adding a single child to an existing beam. The function behaves as follows:\n\nIf no previous children exist, add child\nIf beam already has a single child, modify child beam starting ray (retracing)\nElse throw error\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.convex_aspheric_surface_distance-NTuple{7, Any}","page":"Reference","title":"BeamletOptics.convex_aspheric_surface_distance","text":"convex_aspheric_surface_distance(r, z, c, k, d, α_coeffs)\n\nCalculates the 2D distance field for an aspheric surface at radius r away from the optical axis position z. The asphere is defined by:\n\nc : The curvature (1/radius) of the surface\nk : The conic constant of the surface\nd : The diameter of the asphere\nα_coeffs : The (even) aspheric coefficients, starting with A2.\n\nNote that this is not just an infinite aspheric surface and also not a surface segment but a closed 2D perimeter.\n\nIt is intended to pair the SDF derived from this distance field with a cylinder SDF to build a real lens.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.countlines_in_dir-Tuple{String}","page":"Reference","title":"BeamletOptics.countlines_in_dir","text":"countlines_in_dir(dir)\n\nCounts the number of lines of all .jl files in dir.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.diameter-Tuple{BeamletOptics.AbstractLensSDF}","page":"Reference","title":"BeamletOptics.diameter","text":"Returns the outer bounding diameter of the AbstractLensSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}","page":"Reference","title":"BeamletOptics.diameter","text":"diameter(s::AbstractRotationallySymmetricSurface)\n\nReturns the clear optical diameter of the surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.edge_sag-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractSDF}","page":"Reference","title":"BeamletOptics.edge_sag","text":"Returns the sagitta of the surface at it edge, i.e. at diameter(s)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.electric_field","page":"Reference","title":"BeamletOptics.electric_field","text":"electric_field(I::Real, Z=Z_vacuum, ϕ=0)\n\nCalculates the E-field phasor in [V/m] for a given intensity I and phase ϕ. Vacuum wave impedance is assumed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.electric_field-Tuple{GaussianBeamlet, Any, Any}","page":"Reference","title":"BeamletOptics.electric_field","text":"electric_field(gauss::GaussianBeamlet, r, z)\n\nCalculates the electric field phasor [V/m] of the GaussianBeamlet at the radial and longitudinal positions r and z. This function also considers phase changes due to changes in the optical_path_length of the beamlet.\n\nwarning: Warning\nNote that z and r must be specified as cartesian distances. Using the optical path length for z can lead to false results.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.electric_field-Tuple{Real, Real, Vararg{Any, 6}}","page":"Reference","title":"BeamletOptics.electric_field","text":"electric_field(r, z, E0, w0, w, k, ψ, R) -> ComplexF64\n\nComputes the analytical complex electric field distribution of a stigmatic TEM₀₀ Gaussian beam which is described by:\n\nE(rz) = E_0fracw_0w(z)expleft(  - fracr^2w(z)^2 right)expleft(ileft kz + psi + frackr^22 R(z) right right)\n\nArguments\n\nr: radial distance from beam origin\nz: axial distance from beam origin\nE0: peak electric field amplitude\nw0: waist radius\nw: local beam radius\nk: wave number, equal to 2π/λ\nψ: Gouy phase shift (defined as -textatanleft(fraczz_rright) !)\nR: wavefront curvature, i.e. 1/r (radius of curvature)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.find_zero_bisection-Tuple{Any, Any, Any}","page":"Reference","title":"BeamletOptics.find_zero_bisection","text":"find_zero_bisection(f, a, b; tol=1e-10, max_iter=1000)\n\nFinds a root of the scalar function f on [a, b] using the bisection method. Requires sign(f(a)) ≠ sign(f(b)). Stops when abs(f(mid)) < tol or after max_iter iterations, returning the current midpoint.\n\nArguments\n\nf: function Real -> Real\na: lower interval bound\nb: upper interval bound\ntol: absolute function tolerance (default 1e-10)\nmax_iter: maximum iterations (default 1000)\n\nErrors\n\nThrows if there is no sign change on [a, b] or if convergence is not reached within max_iter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T","page":"Reference","title":"BeamletOptics.fresnel_coefficients","text":"fresnel_coefficients(θ, n)\n\nCalculates the complex Fresnel coefficients for reflection and transmission based on the incident angle θ in [rad] and the refractive index ratio n = n₂ / n₁. Returns rₛ, rₚ, tₛ and tₚ.\n\nSigns\n\ninfo: Info\nThe signs of rₛ, rₚ are based on the definition by Fowles (1975, 2nd Ed. p. 44) and Peatross (2015, 2023 Ed. p. 78)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.gauss_parameters-Tuple{GaussianBeamlet, Real}","page":"Reference","title":"BeamletOptics.gauss_parameters","text":"gauss_parameters(gauss::GaussianBeamlet, z; hint::Union{Nothing, Tuple{Int, Vector{<:Real}}}=nothing)\n\nCalculate the local waist radius and Gouy phase of an unastigmatic Gaussian beamlet at a specific cartesian distance z based on the method of J. Arnaud (1985) and D. DeJager (1992).\n\nArguments\n\ngauss: the GaussianBeamlet object for which parameters are to be calculated.\nz: the position along the beam at which to calculate the parameters.\nhint: an optional hint parameter for the relevant point/index of the appropriate beam segment. If not provided, the function will automatically select the ray.\n\nReturns\n\nw: local radius\nR: curvature, i.e. 1/r where r is the radius of curvature\nψ: Gouy phase (note that -atan definition is used)\nw0: local beam waist radius\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.gauss_parameters-Union{Tuple{G}, Tuple{GaussianBeamlet{G}, AbstractArray}} where G","page":"Reference","title":"BeamletOptics.gauss_parameters","text":"gauss_parameters(gauss::GaussianBeamlet, zs::AbstractArray)\n\nReturn the parameters of the GaussianBeamlet along the specified positions in zs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.height-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}","page":"Reference","title":"BeamletOptics.height","text":"Returns the cylindric height of the AbstractCylindricalSurfaceSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intensity","page":"Reference","title":"BeamletOptics.intensity","text":"Calculates the intensity in [W/m²] for a given complex electric field phasor E. Vacuum wave impedance is assumed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.intensity-Union{Tuple{PSFDetector{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.intensity","text":"intensity(psf::PSFDetector{T};\n          n::Int=100,\n          crop_factor::Real=1,\n          center::Symbol=:centroid,\n          x_min = Inf,\n          x_max = Inf,\n          z_min = Inf,\n          z_max = Inf,\n          x0_shift::Real=0,\n          z0_shift::Real=0) where T\n\nCompute the two‐dimensional point‐spread function (PSF) of an optical system as captured by a PSFDetector.  The returned intensity map is sampled on a regular n×n grid in the detector’s local (x,z)-plane.\n\nKeyword Arguments\n\nn::Int=100 Number of sample points per axis.\ncrop_factor::Real=1 Scales the half‐width of the sampling window returned by calc_local_lims; values >1 expand, <1 shrink.\ncenter::Symbol=:centroid How the sampling window is centred. :centroid uses the projection‑weighted centroid, :bbox uses the geometric mid‑point of the bounding box.\nx_min, x_max, z_min, z_max Manually override the sampling bounds in the local x or z directions. If left as Inf, the bounds from calc_local_lims are used.\nx0_shift::Real=0, z0_shift::Real=0 Apply a constant offset to the entire x or z coordinate arrays, useful for recentring or testing alignment.\n\nReturns\n\nA tuple (xs, zs, I) where\n\nxs::LinRange{T} and zs::LinRange{T} are the sampled coordinates in the detector’s local x and z axes,\nI::Matrix{T} is the corresponding raw/unscaled intensity map\n\nnote: Resetting detectors\nBe sure to call empty!(psf) before each new measurement if reusing the same detector.\n\nnote: Scaling\nThe returned values are raw/unscaled and not a Strehl ratio. This feature is not yet added. In future versions a pupil finder along with a Strehl estimator will be added.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(::AbstractSystem, pd::Photodetector, gauss::GaussianBeamlet, ray_id::Int)\n\nImplements the Photodetector interaction with a GaussianBeamlet. On hit, the scalar E-field of the gauss is added to the current PD field matrix. Tilt and tip between beam and PD surface are considered via projection factors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, ThinBeamsplitter, GaussianBeamlet, Int64}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(::AbstractSystem, bs::ThinBeamsplitter, gauss::GaussianBeamlet, ray_id::Int)\n\nModels the interaction between a ThinBeamsplitter and a GaussianBeamlet.\n\nReflection phase jump\n\nThe reflection phase jump is modeled here as θᵣ = π for simplicity. This is since in practice it will have only a relative effect on the signal at the detector for interferometric setups. The phase jump is applied to the reflected portion of any incoming beam that faces the ThinBeamsplitter normal vector, which assumes that the splitter has an unambigous normal, i.e. a 2D mesh. This is intended to model the effect of the Fresnel equations without full polarization calculus.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{RayType}, Tuple{ObjectType}, Tuple{BeamletOptics.AbstractSystem, ObjectType, BeamletOptics.AbstractBeam, RayType}} where {ObjectType<:BeamletOptics.AbstractObject, RayType<:BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(::AbstractSystem, object::AbstractObject, ::AbstractBeam)\n\nDefines the optical interaction between an incoming/outgoing beam/ray of light and an optical element, must return an AbstractInteraction or nothing. The default behavior is that no interaction occurs, i.e. return of nothing, which should stop the system tracing procedure. Refer to the AbstractInteraction typedocs for more information on the return type value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractObject, GaussianBeamlet{R}, Int64}} where R","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(system::AbstractSystem, object::AbstractObject, gauss::GaussianBeamlet{R}, ray_id::Int)\n\nGeneric dispatch for the interact3d method of a GaussianBeamlet with an AbstractObject. Unless a more concrete implementation exists, the interaction of the Gaussian is assumed to be the interaction of the chief, waist and divergence rays with an object.\n\nReturns\n\nThe interact3d method for the GaussianBeamlet must return a GaussianBeamletInteraction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T<:Real, R<:PolarizedRay{T}}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(AbstractReflectiveOptic, PolarizedRay)\n\nImplements the ideal reflection of a PolarizedRay via the normal at the intersection point on an optical surface. A Jones matrix of [-1 0 0; 0 1 0] is assumed as per Peatross (2015, 2023 Ed. p. 154) and Yun et al. (see PolarizedRay for more information).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T<:Real, R<:Ray{T}}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(AbstractReflectiveOptic, Ray)\n\nImplements the reflection of a Ray via the normal at the intersection point on an optical surface.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T<:Real, R<:PolarizedRay{T}}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(AbstractSystem, AbstractRefractiveOptic, Beam, PolarizedRay)\n\nImplements the refraction of a PolarizedRay at an uncoated optical surface. The \"outside\" ref. index is obtained from the system unless specified otherwise. Reflection and transmission values are calculated via the fresnel_coefficients. Stray light is not tracked. In the case of total internal reflection, only the reflected light is traced.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T<:Real, R<:Ray{T}}","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(AbstractSystem, AbstractRefractiveOptic, Beam, Ray)\n\nImplements the refraction of a Ray at an optical surface. The \"outside\" ref. index is obtained from the system unless specified otherwise. At the critical angle, total internal reflection occurs (see refraction3d).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.interact3d-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, PSFDetector, Beam{T, Ray{T}}, Ray{T}}} where T","page":"Reference","title":"BeamletOptics.interact3d","text":"interact3d(::AbstractSystem, psf::PSFDetector, beam::Beam{T, Ray{T}}, ray::Ray{T}) where T\n\nImplements the PSFDetector interaction with a Beam. On hit, the hit position, direction, optical path length, wavelength and projection factor are captured and stored with the data field of the detector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractObject, BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.intersect3d","text":"intersect3d(object::AbstractObject, ray::AbstractRay)\n\nIn general, the intersection logic between an AbstractObject and an AbstractRay depends on the AbstractShapeTrait. Refer to the respective documentation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractSDF, BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.intersect3d","text":"intersect3d(sphere::AbstractSphere, ray::Ray)\n\nIntersection algorithm for sdf based shapes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.intersect3d","text":"intersect3d(shape::AbstractShape, ::AbstractRay)\n\nDefines the intersection between an AbstractShape and an AbstractRay, must return an Intersection or nothing. The default behavior for concrete shapes and rays is to indicate no intersection, that is nothing, which will inform the tracing algorithm to stop. Refer to the Intersection documentation for more information on the return type value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intersect3d-Union{Tuple{R}, Tuple{M}, Tuple{BeamletOptics.AbstractMesh{M}, BeamletOptics.AbstractRay{R}}} where {M<:Real, R<:Real}","page":"Reference","title":"BeamletOptics.intersect3d","text":"intersect3d(mesh::Mesh, ray::Ray)\n\nThis function is a generic implementation to check if a ray intersects the shape mesh.\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.intersect3d-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, BeamletOptics.AbstractRay{T}}} where T","page":"Reference","title":"BeamletOptics.intersect3d","text":"intersect3d(plane_position, plane_normal, ray)\n\nReturns the intersection between a ray and an infinitely large plane which is characterized by its position and normal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.iscircular-Tuple{Any, Any}","page":"Reference","title":"BeamletOptics.iscircular","text":"iscircular\n\nTests if the polarization state is circular. Refer to Yun paper.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.iselliptical-Tuple{AbstractArray}","page":"Reference","title":"BeamletOptics.iselliptical","text":"iselliptical\n\nTests if the polarization state is elliptical.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isentering-Tuple{BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.isentering","text":"isentering(ray)\n\nTests whether the ray is entering a shape based on the orientation of the ray direction and surface normal. If no intersection is present, default behavior is to return false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isinfrontof-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Reference","title":"BeamletOptics.isinfrontof","text":"isinfrontof(point::AbstractVector, pos::AbstractVector, dir::AbstractVector)\n\nTests if a point is in front of the plane defined by the position and direction vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isinfrontof-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.isinfrontof","text":"isinfrontof(shape::AbstractShape, ray::AbstractRay)\n\nA simple test to check if a shape lies \"in front of\" a ray. The forward direction is here defined as the ray orientation. Only works well if ray is outside of the volume of shape. Can be dispatched to return more accurate results for subtypes of AbstractShape.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.islinear-Tuple{AbstractArray}","page":"Reference","title":"BeamletOptics.islinear","text":"islinear\n\nTests if the polarization state is linear. Refer to Yun paper.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isorthogonal3d-Tuple{AbstractArray, AbstractArray}","page":"Reference","title":"BeamletOptics.isorthogonal3d","text":"isorthogonal3d(v1, v2; atol=eps())\n\nTests if v1 and v2 are orthogonal. Additional abs. tolerance can be passed via atol\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isparallel3d-Tuple{AbstractArray, AbstractArray}","page":"Reference","title":"BeamletOptics.isparallel3d","text":"isparallel3d(v1, v2)\n\nTests if v1 is parallel to v2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.isparaxial","page":"Reference","title":"BeamletOptics.isparaxial","text":"isparaxial(system, gb::GaussianBeamlet, threshold=π/4)\n\nTests the angle between the waist and divergence beams and refractive surfaces. A target threshold of π/4 or 45° is assumed before abberations become dominant.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.isparaxial-2","page":"Reference","title":"BeamletOptics.isparaxial","text":"isparaxial(system, beam, threshold=π/4)\n\nTests the angle between the beam direction and surface normal at each intersection. Mainly intended as a check for GaussianBeamlet.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.isparentbeam-Tuple{Beam, BeamletOptics.AbstractRay}","page":"Reference","title":"BeamletOptics.isparentbeam","text":"isparentbeam(beam, ray)\n\nTests if the given beam contains the ray as a part of its solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.istilted-Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet}","page":"Reference","title":"BeamletOptics.istilted","text":"istilted(system::System, gb::GaussianBeamlet)\n\nTests if refractive elements are tilted with respect to the beamlet optical axis, i.e. introduce simple astigmatism.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.lensmakers_eq-Tuple{Any, Any, Any}","page":"Reference","title":"BeamletOptics.lensmakers_eq","text":"lensmakers_eq(R1, R2, n)\n\nCalculates the thin lens focal length based on the radius of curvature R1/R2 and the lens refractive index n. If center of sphere is on left then R < 0. If center of sphere is on right then R > 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.line_plane_distance3d-NTuple{4, AbstractArray}","page":"Reference","title":"BeamletOptics.line_plane_distance3d","text":"line_plane_distance3d(plane_position, plane_normal, line_position, line_direction)\n\nReturns the distance between a line and an infinitely large plane which are characterized by their position and normal/direction.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.line_point_distance3d-Tuple{Any, Any, Any}","page":"Reference","title":"BeamletOptics.line_point_distance3d","text":"line_point_distance3d(pos, dir, point)\n\nComputes the shortes distance between a line described by pos+t*dir and a point in 3D. This function is slow and should be used only for debugging purposes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.line_point_distance3d-Tuple{BeamletOptics.AbstractRay, Any}","page":"Reference","title":"BeamletOptics.line_point_distance3d","text":"line_point_distance3d(ray, point)\n\nReturns value for the shortest distance between the ray (extended to ∞) and point.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.list_subtypes","page":"Reference","title":"BeamletOptics.list_subtypes","text":"list_subtypes(T::Type; max_depth::Int=5)\n\nPrints a tree of all subtypes, e.g. list_subtypes(AbstractObject). Maximum exploration depth can be limited by passing max_depth. Returns the total number of types encountered.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.mechanical_diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}","page":"Reference","title":"BeamletOptics.mechanical_diameter","text":"mechanical_diameter(s::AbstractRotationallySymmetricSurface)\n\nReturns the mechanical diameter of the surface.\n\nnote: Note\n\n\nIt is assumed that mechanical_diameter(s) >= diameter(s) always holds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.normal3d-Tuple{AbstractArray}","page":"Reference","title":"BeamletOptics.normal3d","text":"normal3d(input)\n\nReturns a random vector with unit length that is perpendicular to the input vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.normal3d-Tuple{AbstractVector, AbstractVector}","page":"Reference","title":"BeamletOptics.normal3d","text":"normal3d(target, reference)\n\nReturns a vector with unit length that is perpendicular to the target and an additional reference vector. Vector orientation is determined according to right-hand rule.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.normal3d-Tuple{BeamletOptics.AbstractSDF, Any}","page":"Reference","title":"BeamletOptics.normal3d","text":"normal3d(s::AbstractSDF, pos)\n\nComputes the normal vector of s at pos.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.normal3d-Union{Tuple{T}, Tuple{BeamletOptics.AbstractMesh{T}, Int64}} where T","page":"Reference","title":"BeamletOptics.normal3d","text":"normal3d(mesh::AbstractMesh, fID::Int)\n\nReturns a vector with unit length that is perpendicular to the target face` according to the right-hand rule. The vertices must be listed row-wise within the face matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.numerical_aperture","page":"Reference","title":"BeamletOptics.numerical_aperture","text":"numerical_aperture(θ, n=1)\n\nReturns the NA for a opening half-angle θ and scalar ref. index n. For more information refer to this website.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BeamletOptics.objects-Tuple{ObjectGroup}","page":"Reference","title":"BeamletOptics.objects","text":"objects(group::ObjectGroup)\n\nExposes all objects/subgroups stored within the group.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.objects-Tuple{System}","page":"Reference","title":"BeamletOptics.objects","text":"objects(system::System)\n\nExposes all objects stored within the system. By exposing the Leaves of the tree only, it is ensured that AbstractObjectGroups are flattened into a regular vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.op_extrude_x-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T<:Real","page":"Reference","title":"BeamletOptics.op_extrude_x","text":"op_extrude_x(p, sdf2d::Function, height)\n\nCalculates the SDF at point p for the given 2D-SDF function and extrudes the shape to height along the x-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.op_extrude_z-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T<:Real","page":"Reference","title":"BeamletOptics.op_extrude_z","text":"op_extrude_z(p, sdf2d::Function, height)\n\nCalculates the SDF at point p for the given 2D-SDF function and extrudes the shape to height along the z-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.op_revolve_y-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T<:Real","page":"Reference","title":"BeamletOptics.op_revolve_y","text":"op_revolve_y(p, sdf2d::Function, offset)\n\nCalculates the SDF at point p for the given 2D-SDF function with offset by revolving the 2D shape around the y-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.op_revolve_z-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T<:Real","page":"Reference","title":"BeamletOptics.op_revolve_z","text":"op_revolve_z(p, sdf2d::Function, offset)\n\nCalculates the SDF at point p for the given 2D-SDF function with offset by revolving the 2D shape around the z-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.optical_path_length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.optical_path_length","text":"optical_path_length(ray::AbstractRay{T}) where {T}\n\nCalculate the optical path length of the ray, i.e. mathrmOPL = n cdot l.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.optical_path_length-Union{Tuple{Beam{T, R} where R<:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.optical_path_length","text":"optical_path_length(beam::Beam)\n\nCalculate the optical path length of the beam, i.e. mathrmOPL = n cdot l.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.optical_power-Tuple{Photodetector}","page":"Reference","title":"BeamletOptics.optical_power","text":"optical_power(pd::Photodetector)\n\nCalculates the total optical power on pd in [W] by integration over the local intensity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.orientation-Tuple{BeamletOptics.AbstractObject}","page":"Reference","title":"BeamletOptics.orientation","text":"orientation(object) -> Matrix\n\nReturns the current orientation of the object in R³ as a matrix. The matrix represents the local fixed-body coordinate system.\n\nIn general, orientation(object) returns orientation(shape(object)) unless specified otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.orientation-Tuple{BeamletOptics.AbstractShape}","page":"Reference","title":"BeamletOptics.orientation","text":"Enforces that shape has to have the field dir or implement orientation().\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.parent!-Tuple{GaussianBeamlet, GaussianBeamlet}","page":"Reference","title":"BeamletOptics.parent!","text":"parent!(beam::GaussianBeamlet, parent::GaussianBeamlet)\n\nEnsures that the GaussianBeamlet knows about its parent beam. In addition, links the chief beams of child and parent. Important for correct functioning of point_on_beam and length.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.photodetector_resolution!-Union{Tuple{S}, Tuple{T}, Tuple{Photodetector{T, S}, Int64}} where {T, S}","page":"Reference","title":"BeamletOptics.photodetector_resolution!","text":"photodetector_resolution!(pd::Photodetector, n::Int)\n\nSets the resolution of pd to n × n. Note that this resets the current pd.field.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.point_on_beam-Union{Tuple{B}, Tuple{R}, Tuple{T}, Tuple{B, Real}} where {T, R<:BeamletOptics.AbstractRay{T}, B<:Beam{T, R}}","page":"Reference","title":"BeamletOptics.point_on_beam","text":"point_on_beam(beam::Beam, t::Real)\n\nFunction to find a point given a specific distance t along the beam. Return the ray index aswell. For negative distances, assume first ray backwards.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.radius-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}","page":"Reference","title":"BeamletOptics.radius","text":"Returns the radius of the AbstractCylindricalSurfaceSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.radius-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}","page":"Reference","title":"BeamletOptics.radius","text":"radius(s::AbstractRotationallySymmetricSurface)\n\nReturns the radius of curvature of the surface. This might return Inf for planar surfaces or surfaces which cannot be described by just one curvature radius.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.radius-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}","page":"Reference","title":"BeamletOptics.radius","text":"Returns the radius of curvature of the AbstractSphericalSurfaceSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.rayleigh_range-Tuple{GaussianBeamlet}","page":"Reference","title":"BeamletOptics.rayleigh_range","text":"rayleigh_range(g::GaussianBeamlet; M2=1)\n\nReturns the Rayleigh range for the first beam section of the GaussianBeamlet g. Note: M2 is not stored in g during construction and must be specified by the user.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reflection3d-Tuple{Any, Any}","page":"Reference","title":"BeamletOptics.reflection3d","text":"reflection3d(dir, normal)\n\nCalculates the reflection between an input vector dir and surface normal vector in R³. Vectors dir and normal must have unit length!\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.refraction3d-Tuple{AbstractArray, AbstractArray, Real, Real}","page":"Reference","title":"BeamletOptics.refraction3d","text":"refraction3d(dir, normal, n1, n2)\n\nCalculates the refraction between an input vector dir and surface normal vector in R³. n1 is the \"outside\" refractive index and n2 is the \"inside\" refractive index. The function returns the new direction of propagation and a boolean flag to indicate if internal refraction has occured.\n\nVectors dir and normal must have unit length!\n\nTotal internal reflection\n\nIf the critical angle for n1, n2 and the incident angle is reached, the ray is reflected internally instead!\n\nArguments\n\ndir: direction vector of incoming ray\nnormal: surface normal at point of intersection\nn1: index of ref. before refraction\nn2: index of ref. after refraction\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.refraction3d-Tuple{BeamletOptics.AbstractRay, Any}","page":"Reference","title":"BeamletOptics.refraction3d","text":"refraction3d(ray, n2)\n\nCalculates the new direction of a ray entering into a new medium with ref. index n2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.render!-Tuple{Any, Union{BeamletOptics.AbstractSystem, BeamletOptics.AbstractBeam, BeamletOptics.AbstractObject, BeamletOptics.AbstractObjectGroup, BeamletOptics.AbstractRay, BeamletOptics.AbstractShape}, Vararg{Any}}","page":"Reference","title":"BeamletOptics.render!","text":"render!(axis, thing; kwargs...)\n\nThe render! function allows for the visualization of optical system and beams under the condition that a suitable backend is loaded. This means that either one of the following packages must be loaded in combination with BeamletOptics via using:\n\nGLMakie \npreferred for 3D viewing\nuse LScene or Axis3 environments\nCairoMakie \npreferred for the generation of high-quality .pngs\nonly Axis3 is supported\n\nIf no suitable backend is loaded, a MissingBackendError will be thrown.\n\nImplementations reqs.\n\nAll concrete implementations of render! must adhere to the following minimal interface:\n\nrender!(axis, thing; kwargs...)\n\naxis: an axis type of the union of LScene or Axis3\nthing: an abstract or concrete object or beam type\nkwargs: custom or Makie keyword arguments that are passed to the underlying backend\n\nRefer to the BeamletOptics extension docs for Makie for more information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.reset_rotation3d!","text":"reset_rotation3d!(mesh::AbstractMesh)\n\nResets all previous rotations around the current offset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.reset_rotation3d!","text":"Resets the shape rotation angles to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_rotation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S<:BeamletOptics.AbstractShape{T}}} where T","page":"Reference","title":"BeamletOptics.reset_rotation3d!","text":"reset_rotation3d!(::MultiShape, object)\n\nReset all applied rotations of the object, i.e. resets the local coordinate system to the standard base.\n\ninfo: Parts within parts\nSub-part relative rotations are not reset!\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.reset_translation3d!","text":"reset_translation3d!(mesh::AbstractMesh)\n\nResets all previous translations and returns the mesh back to the global origin.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.reset_translation3d!","text":"Returns the shape to the global origin.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.reset_translation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S<:BeamletOptics.AbstractShape{T}}} where T","page":"Reference","title":"BeamletOptics.reset_translation3d!","text":"reset_translation3d!(::MultiShape, object)\n\nResets all applied translations of the object, i.e. moves the center back to the origin.\n\ninfo: Parts within parts\nSub-part relative translations are not reset!\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.retrace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T<:Real, R<:BeamletOptics.AbstractRay{T}}","page":"Reference","title":"BeamletOptics.retrace_system!","text":"retrace_system!(system, beam)\n\nThis function tries to reuse data from a previous solution in order to solve the system using a sequential approach.\n\nRetracing\n\nThe retracing logic for an already solved beam loops over the rays and children and is as follows:\n\nBegin\n\nTest if current ray has a valid intersection\nIf not, mark beam tail for cleanup and go to End\nRecalculate the intersection\nIf a hint was provided by a previous interaction, use hinted object\nElse, test against previous intersection\nTest if the ray still has a valid intersection after recalculation\nIf no object is hit, mark beam tail for cleanup and go to End\n\nInteract\n\nRecalculate the optical interaction\nCatch hints provided for next ray\nIf no interaction occurs, mark beam tail for conditional cleanup and go to End\nAdd the interaction to the current beam\nIf another ray follows, modify the next starting position     - Go to Begin\nElse mark children for cleanup, push new ray to beam tail     - Go to End\n\nEnd\n\nIf cleanup is required, do conditionally\nremove all beam tail rays after current ray\nremove all beam children\nreset beam tail ray intersection to nothing\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.retrace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T<:Real","page":"Reference","title":"BeamletOptics.retrace_system!","text":"retrace_system!(system::System, gauss::GaussianBeamlet{T}) where {T <: Real}\n\nRetrace the beam stored in GaussianBeamlet through the optical system. Chief, waist and divergence ray intersections and interactions are recalculated. All rays must hit the same object, or the retracing step is aborted. If retracing is stopped before the end of the beam is reached, further rays are dropped.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractMesh, Any, Any}","page":"Reference","title":"BeamletOptics.rotate3d!","text":"rotate3d!(mesh, axis, θ)\n\nMutating function that rotates the mesh around the specified rotation axis by the angle θ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractShape, Any, Any}","page":"Reference","title":"BeamletOptics.rotate3d!","text":"rotate3d!(shape::AbstractShape, axis, θ)\n\nRotates the dir-matrix of shape around the reference-axis by an angle of θ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.rotate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any, Any}","page":"Reference","title":"BeamletOptics.rotate3d!","text":"rotate3d!(::MultiShape, object, axis, θ)\n\nAll parts of the MultiShape object are rotated around the pivot center via the specified angle θ and axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.rotate3d-Tuple{AbstractVector, Any}","page":"Reference","title":"BeamletOptics.rotate3d","text":"rotate3d(reference::Vector, θ)\n\nReturns the rotation matrix that will rotate a vector around the reference axis at an angle θ in radians. Vector length is maintained. Counter-clockwise rotation in a right-hand coord. system. \n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.sag-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}","page":"Reference","title":"BeamletOptics.sag","text":"Returns the sagitta of the AbstractSphericalSurfaceSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.sag-Tuple{Real, Real}","page":"Reference","title":"BeamletOptics.sag","text":"sag(r::Real, l::Real)\n\nCalculates the sag of a cut circle with radius r and chord length l\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.scale3d!-Tuple{BeamletOptics.AbstractMesh, Any}","page":"Reference","title":"BeamletOptics.scale3d!","text":"scale3d!(mesh::AbstractMesh, scale)\n\nAllows rescaling of mesh data around \"center of gravity\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.sd_line_segment-Tuple{Any, Any, Any}","page":"Reference","title":"BeamletOptics.sd_line_segment","text":"sd_line_segment(p, a, b)\n\nReturns the signed distance from point p to the line segment described by the points a and b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.sdf-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, Union{Nothing, BeamletOptics.AbstractOrientationType}}","page":"Reference","title":"BeamletOptics.sdf","text":"sdf(::AbstractRotationallySymmetricSurface, ::Union{Nothing, AbstractOrientationType})\n\nTakes the surface specification and an optional AbstractOrientationType as trait parameter and returns a corresponding AbstractSDF type.\n\nSurface vs. volume based tracing\n\nThis function is a mere convenience provider for users coming from other optic simulations frameworks which are surface oriented. The goal of this function is to return the best matching closed volume SDF which posesses a surface with the given specs on one side and most often a boundary and planar surface on the other side.\n\ninfo: Info\nAlways keep in mind that this package performs closed-volume baced ray tracing using either SDFs or meshes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.set_new_origin3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.set_new_origin3d!","text":"set_new_origin3d!(mesh::AbstractMesh)\n\nResets the mesh directional matrix and position vector to their initial values.\nWarning: this operation is non-reversible!\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.shape-Tuple{BeamletOptics.AbstractObject}","page":"Reference","title":"BeamletOptics.shape","text":"Dispatch the shape function based on the AbstractShapeTrait of the AbstractObject\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.shape_trait_of-Tuple{BeamletOptics.AbstractObject}","page":"Reference","title":"BeamletOptics.shape_trait_of","text":"Default trait\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.solve_system!-Union{Tuple{B}, Tuple{BeamletOptics.AbstractSystem, B}} where B<:BeamletOptics.AbstractBeam","page":"Reference","title":"BeamletOptics.solve_system!","text":"solve_system!(system::System, beam::AbstractBeam; r_max=100, retrace=true)\n\nManage the tracing of an AbstractBeam through an optical system. The function retraces the beam if possible and then proceeds to trace each leaf of the beam tree through the system. The condition to stop ray tracing is that the last beam intersection is nothing or the beam interaction is nothing. Then, the system is considered to be solved. A maximum number of rays per beam (r_max) can be specified in order to avoid infinite calculations under resonant conditions, i.e. two facing mirrors.\n\nArguments\n\nsystem::System: The optical system in which the beam will be traced.\nbeam::AbstractBeam: The beam object to be traced through the system.\nr_max::Int=100 (optional): Maximum number of tracing iterations for each leaf. Default is 100.\nretrace::Bool=true (optional): Flag to indicate if the system should be retraced. Default is true.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.static_data-Tuple{BeamletOptics.AbstractJonesMatrix}","page":"Reference","title":"BeamletOptics.static_data","text":"Getter fct. for the static array in the AbstractJonesMatrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.test_refractive_index_function-Tuple{Any}","page":"Reference","title":"BeamletOptics.test_refractive_index_function","text":"test_refractive_index_function(input)\n\nTests if input is callable with a single Real argument for the wavelength λ and returns a single Real value for the refractive index n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.test_refractive_index_function-Tuple{DiscreteRefractiveIndex}","page":"Reference","title":"BeamletOptics.test_refractive_index_function","text":"DiscreteRefractiveIndex passes test by default\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.thickness-Tuple{BeamletOptics.AbstractLensSDF}","page":"Reference","title":"BeamletOptics.thickness","text":"Returns the on-axis thickness of the AbstractLensSDF\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.thickness-Union{Tuple{BeamletOptics.UnionSDF{T, TT} where TT<:Tuple{Vararg{BeamletOptics.AbstractSDF{T}}}}, Tuple{T}} where T","page":"Reference","title":"BeamletOptics.thickness","text":"thickness(union)\n\nCalculates the thickness of a union of AbstractLensSDFs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.trace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T<:Real, R<:BeamletOptics.AbstractRay{T}}","page":"Reference","title":"BeamletOptics.trace_system!","text":"trace_system!(system::AbstractSystem, beam::Beam{T}; r_max::Int = 20) where {T <: Real}\n\nTrace a Beam through an optical system. Maximum number of tracing steps can be capped by r_max.\n\nTracing logic\n\nThe intersection of the last ray of the beam with any objects in the system is tested. If an object is hit, the optical interaction is analyzed and tracing continues. Else the tracing procedure is stopped.\n\nArguments\n\nsystem:: The optical system through which the Beam is traced.\nbeam: The Beam object to be traced.\nr_max: Maximum number of tracing iterations. Default is 20.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.trace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T<:Real","page":"Reference","title":"BeamletOptics.trace_system!","text":"trace_system!(system::System, gauss::GaussianBeamlet{T}; r_max::Int = 20) where {T <: Real}\n\nTrace a GaussianBeamlet through an optical system. Maximum number of tracing steps can be capped by r_max.\n\nTracing logic\n\nThe chief, waist and divergence beams are traced step-by-step through the system. For each intersection after a tracing_step!, the intersections are compared. If all rays hit the same target, the optical interaction is analyzed, else the tracing stops.\n\nArguments\n\nsystem: The optical system through which the GaussianBeamlet is traced.\ngauss: The GaussianBeamlet object to be traced.\nr_max: Maximum number of tracing iterations. Default is 20.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.tracing_step!-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRay{R}, BeamletOptics.Hint}} where R<:Real","page":"Reference","title":"BeamletOptics.tracing_step!","text":"tracing_step!(system::AbstractSystem, ray::AbstractRay{R}, hint::Hint)\n\nTests if the ray intersects an object in the optical system. Returns the closest intersection.\n\nHint\n\nAn optional Hint can be provided to test against a specific object (and shape) in the system first.\n\nwarning: Warning\nIf a hint is provided and the object intersection is valid, the intersection will be returned immediately. However, it is not guaranteed that this is the true closest intersection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}","page":"Reference","title":"BeamletOptics.translate3d!","text":"translate3d!(mesh::AbstractMesh, offset)\n\nMutating function that translates the vertices of an mesh in relation to the offset vector. In addition, the mesh position vector is overwritten to reflect the new \"center of gravity\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractShape, Any}","page":"Reference","title":"BeamletOptics.translate3d!","text":"translate3d!(shape::AbstractShape, offset)\n\nTranslates the position of shape by the offset-vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.translate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}","page":"Reference","title":"BeamletOptics.translate3d!","text":"translate3d!(::MultiShape, object, offset)\n\nMoves all parts of the MultiShape object along the specified offset vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.AbstractShape, Any}","page":"Reference","title":"BeamletOptics.translate_to3d!","text":"translate_to3d!(shape::AbstractShape, target)\n\nTranslates the shape to the target position. \n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}","page":"Reference","title":"BeamletOptics.translate_to3d!","text":"translate_to3d!(::MultiShape, object, target)\n\nTranslates all parts of the MultiShape object in parallel to the specified target position. The object center point will be equal to the target.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.visibility-Tuple{Any}","page":"Reference","title":"BeamletOptics.visibility","text":"visibility(opt_pwr)\n\nCalculates e.g. the interferometric contrast from a series of optical power measurements. For more information go here.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.xrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T","page":"Reference","title":"BeamletOptics.xrotate3d!","text":"Rotates the dir-matrix of shape around the global x-axis by an angle of θ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.yrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T","page":"Reference","title":"BeamletOptics.yrotate3d!","text":"Rotates the dir-matrix of shape around the global y-axis by an angle of θ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BeamletOptics.zrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T","page":"Reference","title":"BeamletOptics.zrotate3d!","text":"Rotates the dir-matrix of shape around the global z-axis by an angle of θ.\n\n\n\n\n\n","category":"method"},{"location":"basics/render/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"As mentioned in other sections of this documentation, the Makie backend can be used in order to generate 2D/3D renderings of optical systems and results generated with this package. Refer to the extensive Makie documentation and the Examples and the Tutorials sections of this package for a variety of showcases on how to visualize your simulation.","category":"page"},{"location":"basics/render/#Rendering-elements","page":"Visualization","title":"Rendering elements","text":"","category":"section"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"The main function provided for visualization purposes is the render! function. ","category":"page"},{"location":"basics/render/#BeamletOptics.render!-Tuple{Any, Union{BeamletOptics.AbstractSystem, BeamletOptics.AbstractBeam, BeamletOptics.AbstractObject, BeamletOptics.AbstractObjectGroup, BeamletOptics.AbstractRay, BeamletOptics.AbstractShape}}-basics-render","page":"Visualization","title":"BeamletOptics.render!","text":"render!(axis, thing; kwargs...)\n\nThe render! function allows for the visualization of optical system and beams under the condition that a suitable backend is loaded. This means that either one of the following packages must be loaded in combination with BeamletOptics via using:\n\nGLMakie \npreferred for 3D viewing\nuse LScene or Axis3 environments\nCairoMakie \npreferred for the generation of high-quality .pngs\nonly Axis3 is supported\n\nIf no suitable backend is loaded, a MissingBackendError will be thrown.\n\nImplementations reqs.\n\nAll concrete implementations of render! must adhere to the following minimal interface:\n\nrender!(axis, thing; kwargs...)\n\naxis: an axis type of the union of LScene or Axis3\nthing: an abstract or concrete object or beam type\nkwargs: custom or Makie keyword arguments that are passed to the underlying backend\n\nRefer to the BeamletOptics extension docs for Makie for more information.\n\n\n\n\n\n","category":"method"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"If a suitable backend is loaded, additional dispatched render! functions will become available. For instance, this allows the plotting of a GaussianBeamlet.","category":"page"},{"location":"basics/render/#Loading-the-extension","page":"Visualization","title":"Loading the extension","text":"","category":"section"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"Refer to the following snippet for an example on how the extension loading behaves. When only BMO is loaded, the render! function becomes available but will throw an BeamletOptics.MissingBackendError when trying to plot something.","category":"page"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"julia> using BeamletOptics\n\njulia> methods(render!)\n# 1 method for generic function \"render!\" from BeamletOptics:\n [1] render!(::Any, ::Union{BeamletOptics.AbstractSystem, BeamletOptics.AbstractBeam, BeamletOptics.AbstractObject, BeamletOptics.AbstractObjectGroup, BeamletOptics.AbstractRay, BeamletOptics.AbstractShape}, kwargs...)\n     @ C:\\Users\\anon\\.julia\\dev\\BeamletOptics\\src\\Render.jl:56\n\njulia> axis = nothing;\n\njulia> mirror = RoundPlanoMirror(25e-3, 5e-3);\n\njulia> render!(axis, mirror)\nERROR: It appears no suitable Makie backend is loaded in this session.\nStacktrace:\n [1] render!(::Nothing, ::RoundPlanoMirror{Float64})\n   @ BeamletOptics c:\\Users\\anon\\.julia\\dev\\BeamletOptics\\src\\Render.jl:46\n [2] top-level scope\n   @ REPL[5]:1","category":"page"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"Once a backend has been loaded, additional dispatched versions of render! become available.","category":"page"},{"location":"basics/render/","page":"Visualization","title":"Visualization","text":"julia> using GLMakie\n\njulia> methods(render!)\n# 21 methods for generic function \"render!\" from BeamletOptics:\n  [1] render!(ax::Union{Axis3, LScene}, s::BeamletOptics.UnionSDF; kwargs...)\n     @ BeamletOpticsMakieExt C:\\Users\\anon\\.julia\\dev\\BeamletOptics\\ext\\RenderSDF.jl:32\n  [2] render!(axis::Union{Axis3, LScene}, css::BeamletOptics.ConcaveSphericalSurfaceSDF; color, kwargs...)\n     @ BeamletOpticsMakieExt C:\\Users\\anon\\.julia\\dev\\BeamletOptics\\ext\\RenderLenses.jl:1\n  [3] render!(axis::Union{Axis3, LScene}, css::BeamletOptics.ConvexSphericalSurfaceSDF; color, kwargs...)\n     @ BeamletOpticsMakieExt C:\\Users\\anon\\.julia\\dev\\BeamletOptics\\ext\\RenderLenses.jl:31\n  [4] render!(axis::Union{Axis3, LScene}, acyl::BeamletOptics.AbstractAcylindricalSurfaceSDF; color, kwargs...)\n     @ BeamletOpticsMakieExt C:\\Users\\anon\\.julia\\dev\\BeamletOptics\\ext\\RenderCylinderLenses.jl:1\n  [5] etc...","category":"page"},{"location":"components/components/#Optical-components","page":"Overview","title":"Optical components","text":"","category":"section"},{"location":"components/components/","page":"Overview","title":"Overview","text":"A collection of basic optical elements is provided with this package as is. They are tested for the correctness of their optical interactions and are verified to work with reasonable fidelity. For detailed documentation, refer to the following table of contents. ","category":"page"},{"location":"components/components/#Component-overview","page":"Overview","title":"Component overview","text":"","category":"section"},{"location":"components/components/","page":"Overview","title":"Overview","text":"Pages = [\"mirrors.md\", \"lenses.md\", \"beamsplitters.md\", \"detectors.md\", \"polarizers.md\"]\nDepth = 2","category":"page"},{"location":"components/components/#Listing-available-components","page":"Overview","title":"Listing available components","text":"","category":"section"},{"location":"components/components/","page":"Overview","title":"Overview","text":"When using this package in the REPL, a tree view of all implemented BeamletOptics.AbstractObjects can be generated via the BeamletOptics.list_subtypes helper function. Note that this function is not able to determine all available constructors.","category":"page"},{"location":"components/components/","page":"Overview","title":"Overview","text":"using BeamletOptics # hide\nBeamletOptics.list_subtypes(BeamletOptics.AbstractObject);","category":"page"},{"location":"tutorials/expander/#Beam-expander","page":"Beam expander","title":"Beam expander","text":"","category":"section"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"This section will help you to run your first simulation using this package. We will start by modeling a simple Keplerian beam expander. You will learn how to:","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"Define a simple SphericalLens and spawn a Beam\nRotate and translate objects\nVisualize the optical arrangement \nSolve an optical system using geometrical optics","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"For this tutorial, we will use two thin spherical lenses to magnify a collimated beam. ","category":"page"},{"location":"tutorials/expander/#Defining-the-lenses","page":"Beam expander","title":"Defining the lenses","text":"","category":"section"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"We start by defining two lenses and calculating their analytical focal lengths f1 and f2, which will be required later. The focal length of an ideal thin lens (BeamletOptics.lensmakers_eq) can be calculated via","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"frac1f approx (n_L - 1) cdot left( frac1R_1 - frac1R_2 right)","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"where n_L is the lens refractive index and R_12 are the radii of curvature of the front and back spherical surface. In addition, the magnificant of a two lens system can be determined by M = f_2f_1.","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"using CairoMakie, BeamletOptics\n\n# Lens 1\nR11 = 20e-3\nR12 = 60e-3\nnl1 = 1.5\nd1 = BeamletOptics.inch\nf1 = BeamletOptics.lensmakers_eq(R11, -R12, nl1)\nl1 = SphericalLens(R11, R12, 0, d1, λ->nl1)\n\n# Lens 2\nR21 = 60e-3\nR22 = 90e-3\nnl2 = 1.5\nd2 = 2*BeamletOptics.inch\nf2 = BeamletOptics.lensmakers_eq(R21, -R22, nl2)\nl2 = SphericalLens(R21, R22, 0, d2, λ->nl1)\n\nM = f2/f1\n\n@info \"f1, f2, M\" f1 f2 M","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"where nl is the lens refractive index required for the lensmakers equation. Note that the lens cylinder section thickness is set to zero and that the first lens has a diameter of one inch, whereas the second lens has a diameter of two inches.","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"info: Info\nUnless specified otherwise, this package assumes SI-units for input parameters.i.e. R11 = 20e-3 corresponds to a radius of curvature of 20 mm.\nnl1 = 1.5 corresponds to a unitless refractive index","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"Further, we have specified constant refractive indices nl1 and nl2. Therefore, it will not matter which wavelength we chose for the ray/beam later on, since n_L(lambda) = 15. In general, however, a function  n(lambda) can be passed that models dispersion for different wavelengths, or a DiscreteRefractiveIndex.","category":"page"},{"location":"tutorials/expander/#Setting-up-the-system-and-moving-elements","page":"Beam expander","title":"Setting up the system and moving elements","text":"","category":"section"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"We then define that our optical system consists of the lens elements l1 and l2 and move the elements into position using the following translation and rotation commands:","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"# define system and move elements\nsystem = System([l1, l2])\n\nzrotate3d!(l1, deg2rad(180))\nzrotate3d!(l2, deg2rad(180))\n\ntranslate3d!(l2, [0, f1+f2, 0])","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"Note that the second lens has been moved by the combined focal length f1+f2 along the y-axis. To visualize what we have done so far, we will use the plotting helper functions that are based on the Makie package.","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"# Plot\nfig = Figure(size=(600,240))\naspect = (1,4,1)\nlimits = (-0.025, 0.025, -0.05, 0.15, -0.025, 0.025)\nax = Axis3(fig[1,1], aspect=aspect, limits=limits, azimuth=0., elevation=1e-3)\nhidedecorations!(ax)\n\nrender!(ax, system)\n\nsave(\"expander_no_beams.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"(Image: Beam Expander)","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"We can see that both lenses have been placed along the (optical) y-axis.   ","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"tip: 3D viewing\nIn practice it is recommend to replace Axis3 with a LScene and use GLMakie for a better viewing experience, i.e. ax = LScene(fig[1,1]).","category":"page"},{"location":"tutorials/expander/#Propagating-beams-through-the-system","page":"Beam expander","title":"Propagating beams through the system","text":"","category":"section"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"We will now define a single beam that propagates through our optical system. First, we start by defining a Ray with a starting position and direction that is used to generate a Beam. This beam can then be propagated through the expander using the solve_system! function:","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"# Propagate a single ray through the system\nstart_pos = [0, -0.15, 4e-3]\nstart_dir = [0, 1., 0]\n\nray = Ray(start_pos, start_dir)\n\nbeam = Beam(ray)\n\nsolve_system!(system, beam)\n\nrender!(ax, beam, show_pos=true)\n\nsave(\"expander_one_beam.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"Rendering the beam into the 3D-axis defined above will allow us to see the result:","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"(Image: Beam Expander)","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"If we perform this step for different z-values of the ray starting position, we can obtain a collimated ray bundle and look at the magnification of the beam expander:","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"# Propagate multiple rays through the system\nzs = -4e-3:2e-3:4e-3\nfor z in zs\n    b = Beam(Ray([0, -0.15, z], [0, 1., 0]))\n    solve_system!(system, b)\n    render!(ax, b)\nend\n\nsave(\"expander_all_beams.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"(Image: Beam Expander)","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"Let us also propagate some rays through the outer region of the magnifier. We will color them red.","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"# Propagate rays through edge region\nzs = 6e-3:2e-3:8e-3\nfor z in cat(-zs, zs; dims=1)\n    b = Beam(Ray([0, -0.15, z], [0, 1., 0]))\n    solve_system!(system, b)\n    render!(ax, b, color=:red)\nend\n\nsave(\"expander_abberations.png\", fig, px_per_unit=4); nothing # hide","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"(Image: Beam Expander)","category":"page"},{"location":"tutorials/expander/","page":"Beam expander","title":"Beam expander","text":"It can be observed that these beams are not collimated after the magnifier, but rather focused. This is due to the effect of spherical abberations. ","category":"page"},{"location":"basics/elements/#Optical-elements","page":"Optical elements","title":"Optical elements","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Optical elements serve as the building blocks for optical systems in the context of this package, representing components such as mirrors, lenses, filters, etc. Unlike the surface/interface based representation of optical elements in other tools, they are treated as volumetric bodies in this simulation framework. Optical interactions between rays/beams and elements are defined based on the type of the element and the type of the incident beam/ray. Note that optical elements will be referred to simply as objects moving forward. A more detailed look into the design philosophy behind this approach is given in the Objects and shapes section below.","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"To ensure compatibility with the API design, custom optical elements must adhere to the BeamletOptics.AbstractObject interface.","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"info: Normal vector direction definition\nEquations to calculate optical effects often rely on the normal vector at the ray intersection location to work correctly and point in a specific direction. It is important to ensure that this condition is fulfilled when spurious effects occur.","category":"page"},{"location":"basics/elements/#Objects-and-shapes","page":"Optical elements","title":"Objects and shapes","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"In BMO, the distinction between an object and its geometric representation (shape) is a central design principle. This separation is intended to ensure flexibility and modularity in modeling optical components.","category":"page"},{"location":"basics/elements/#Separation-of-geometry-and-optical-interactions","page":"Optical elements","title":"Separation of geometry and optical interactions","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Objects combine physical geometry with specific optical interactions. The geometry, represented by an BeamletOptics.AbstractShape, defines the physical boundaries of the element. Shapes can be represented in various forms, such as Meshes or Signed Distance Functions (SDFs). For more information, refer to the respective documentation.","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"On the other hand, the optical behavior — how light interacts with the element — is defined by the BeamletOptics.AbstractObject type. This decoupling allows for independent development and extension of geometry representations and optical interaction models.","category":"page"},{"location":"basics/elements/#Multi-shape-objects","page":"Optical elements","title":"Multi-shape objects","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"An BeamletOptics.AbstractObject can consist of multiple BeamletOptics.AbstractShapes or even multiple subsidiary BeamletOptics.AbstractObjects, facilitating the creation of composite optical elements. For example, a lens with an anti-reflective coating could be represented as the substrate and a seperate model for the coating, each with its own geometric and optical properties. In general, an object can be a BeamletOptics.SingleShape or a BeamletOptics.MultiShape. Refer to the Geometry representation section for more information. ","category":"page"},{"location":"basics/elements/#Types-of-elements","page":"Optical elements","title":"Types of elements","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Some optical elements are provided with this package, these include e.g.:","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Reflective optical elements\nRoundPlanoMirror\nRefractive optical elements\nSphericalLens\nMisc.\nPhotodetector\nThinBeamsplitter","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"For a detailed overview, refer to the Optical components section.","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"info: Custom optical elements\nIn order to implement custom geometries and optical elements, visit the API design section.","category":"page"},{"location":"basics/elements/#Moving-optical-elements","page":"Optical elements","title":"Moving optical elements","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Optical elements can move around freely in three-dimensional space, which enables the modeling of kinematics within optical setups. When objects are manipulated, they are translated and rotated around their self-defined center of gravity, which is represented as a mathbbR^3-vector and will be referred to as its position. Additionally, the orientation of an object, defined as its local fixed coordinate system, is represented by an orthonormal matrix in mathbbR^3. If the object is rotated, this matrix can be used to calculate the inverse transform into global coordinates. ","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"important: Optical system kinematics\nElements can be moved freely between each call of solve_system!. However, during tracing it is assumed that all elements remain static.","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"For elements that implement the BeamletOptics.AbstractObject interface, the following movement commands are provided:","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"Translation\ntranslate3d!\ntranslate_to3d!\nRotation\nrotate3d!\nxrotate3d!\nyrotate3d!\nzrotate3d!\nalign3d!\nReset commands\nreset_translation3d!\nreset_rotation3d!","category":"page"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"important: Relative motion\nUnless specified otherwise, the translation and rotation commands result in relative motions to the current position and orientation. This must be taken into account when trying to model a specific set of movements.","category":"page"},{"location":"basics/elements/#Groups-of-optical-elements","page":"Optical elements","title":"Groups of optical elements","text":"","category":"section"},{"location":"basics/elements/","page":"Optical elements","title":"Optical elements","text":"For the easier representation of a group of BeamletOptics.AbstractObjects that moves as one, the ObjectGroup can be used. Refer to the Lens groups example for more information.","category":"page"},{"location":"basics/elements/#BeamletOptics.ObjectGroup-basics-elements","page":"Optical elements","title":"BeamletOptics.ObjectGroup","text":"ObjectGroup <: AbstractObjectGroup\n\nA tree-like storage container for groups of objects. Can store individual objects and subgroups. Main purpose is handling of, i.e., groups of lenses.\n\nFields\n\ncenter: a point in 3D space which is regarded as the reference origin of the group\ndir: a 3x3 matrix that describes the common orientation of the group\nobjects: stores AbstractObject, can also store subgroups of type AbstractObjectGroup\n\nKinematic\n\nA ObjectGroup implements the kinematic functions of AbstractObject. The following logic is applied to\n\ntranslate3d!: all objects in the group are translated by the offset vector\ntranslate_to3d!: all objects are moved in parallel such that the group center is equal to the target position\nrotate3d!: all objects are rotated around the center point with respect to their relative position\n\n\n\n\n\n","category":"type"},{"location":"basics/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"basics/intro/","page":"Introduction","title":"Introduction","text":"This section of the documentation is intended for users that want to dive deeper into the functionality provided this package. A table of content is given below. If you want to develop the package or add your own optical elements, beam types or optical interactions, refer to the API design section. If you want to learn more about specific optical components, you can skip ahead to the Optical components section of the documentation.","category":"page"},{"location":"basics/intro/#Basics-overview","page":"Introduction","title":"Basics overview","text":"","category":"section"},{"location":"basics/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"rays.md\", \"beams.md\", \"elements.md\", \"systems.md\"]\nDepth = 3","category":"page"},{"location":"basics/systems/#Optical-systems","page":"Optical systems","title":"Optical systems","text":"","category":"section"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"A collection of optical elements is referred to as a system in the context of this package. Optical systems are used together with beams for the solve_system! function. In general, optical systems must fulfill the BeamletOptics.AbstractSystem interface in order to be compatible with the standard solvers in this package:","category":"page"},{"location":"basics/systems/#BeamletOptics.AbstractSystem-basics-systems","page":"Optical systems","title":"BeamletOptics.AbstractSystem","text":"AbstractSystem\n\nA generic representation of a system of optical elements.\n\nImplementation reqs.\n\nSubtypes of AbstractSystem must implement the following:\n\nFields:\n\nobjects: a vector or tuple of AbstractObjects that make up the system\nn: (optional) RefractiveIndex of the surrounding medium, default value is 1.0\n\nFunctions:\n\nrefractive_index: returns the RefractiveIndex n of the system medium, see above\n\n\n\n\n\n","category":"type"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"As is, the package provides two basic system types: System and StaticSystem. Refer to the Beam expander tutorial for an example on how to define a simple optical system.","category":"page"},{"location":"basics/systems/#Tracing-logic","page":"Optical systems","title":"Tracing logic","text":"","category":"section"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"In order to solve optical systems, this package uses a hybrid sequential and non-sequential mode. Which mode is being used is determined automatically by the solve_system! function. This will be explained in more detail below.","category":"page"},{"location":"basics/systems/#BeamletOptics.solve_system!-basics-systems","page":"Optical systems","title":"BeamletOptics.solve_system!","text":"solve_system!(system::System, beam::AbstractBeam; r_max=100, retrace=true)\n\nManage the tracing of an AbstractBeam through an optical system. The function retraces the beam if possible and then proceeds to trace each leaf of the beam tree through the system. The condition to stop ray tracing is that the last beam intersection is nothing or the beam interaction is nothing. Then, the system is considered to be solved. A maximum number of rays per beam (r_max) can be specified in order to avoid infinite calculations under resonant conditions, i.e. two facing mirrors.\n\nArguments\n\nsystem::System: The optical system in which the beam will be traced.\nbeam::AbstractBeam: The beam object to be traced through the system.\nr_max::Int=100 (optional): Maximum number of tracing iterations for each leaf. Default is 100.\nretrace::Bool=true (optional): Flag to indicate if the system should be retraced. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"basics/systems/#Tracing-systems","page":"Optical systems","title":"Tracing systems","text":"","category":"section"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"In the initial state, is is assumed that the problem consists of objects <: BeamletOptics.AbstractObjects (in a system) and a beam <: BeamletOptics.AbstractBeam with a defined starting position and direction. No additional information is provided, and the specific path of the beam is not known beforehand. Consequently, brute force tracing of the optical system is required, involving testing against each individual element to determine the trajectory of the beam.","category":"page"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"This non-sequential mode is comparatively safe in determining the \"true\" beam path, but will scale suboptimally in time-complexity with the amount of optical elements. After solving the system, the beam path is known and can be potentially reused in the future.","category":"page"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"info: Object order\nUnlike with classic, surface-based ray tracers, the order in which objects are listed in the System object vector/tuple is not considered for the purpose of tracing or retracing.","category":"page"},{"location":"basics/systems/#Retracing-systems","page":"Optical systems","title":"Retracing systems","text":"","category":"section"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"Once a system has been traced for the first time, the system and beam can be solved again. However, this time the solver will try to reuse as much information from the previous run as possible by testing if the previous beam trajectory is still valid in a sequential tracing mode. Retracing systems assumes that the kinematic changes (e.g. optomechanical aligment) between the current tracing procedure and the previous one are small. If an intersection along the beam trajectory becomes invalid, the solver will perform a non-sequential trace for all invalidated parts of the beam.","category":"page"},{"location":"basics/systems/","page":"Optical systems","title":"Optical systems","text":"warning: Retracing blocked beam paths\nThe  implemented standard retracing procedure can handle beam path invalidations under certain conditions. However, one case that will lead to a silent error is if an element in the system is moved such that it blocks the beam path between two other elements. The retracer will not be able to detect this, since the testing of the previous intersection will return a valid intersection.If this kind of situation must be modeled, e.g. in the case of an optical chopper wheel, retracing should be disabled.","category":"page"},{"location":"#BeamletOptics","page":"Home","title":"BeamletOptics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Building optical setups in a laboratory environment – for instance a laser interferometer – is a common task for optical engineers and physicists. This package is intended to provide a simulation environment in which the user can quickly analyze and layout simple optical components like lenses or beamsplitters before committing to a breadboard setup.  ","category":"page"},{"location":"#What-is-the-purpose-of-this-package","page":"Home","title":"What is the purpose of this package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package mainly tries to provide a simple Gaussian beamlet propagation tool for coherent, monochromatic and directed light sources. It also offers a convenient kinematic API that allows for the easy placing of optical elements and straight-forward simulation of moving or vibrating components. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this purpose, the package implements a traditional ray tracing solver. This forms the backbone of the Gaussian beamlet tracing scheme that has been implemented to model the propagation of laser beams.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: What this package is not\nThis package does not include tools for optimizing optical systems, such as fine-tuning lens surfaces to minimize specific aberrations in multi-lens setups. Instead, the package is designed as a digital laboratory where you can play around with stuff before buying it.","category":"page"},{"location":"#Features-list","page":"Home","title":"Features list","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hybrid sequential and non-sequential 3D ray tracing without paraxial approximation\nTEM₀₀ Gaussian beamlet models\nVarious optical components\nMirrors\nLenses\nBeamsplitters\nDetectors\nSurface-like modeling of rotationally symmetrical lens systems\nExtendable API design for the implementation of custom optical interactions\nEasy visualization via the Makie package","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Refer to the sections below if this is your first time using this package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package requires Julia ≥ 1.9.4","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can add this package to your project by entering the package manager (press ] in the REPL) and typing add BeamletOptics. It is also recommended that you add GLMakie. You can include this package into your current scope via using BeamletOptics. If a Makie version is loaded before or after the inclusion of this package, the extension provided as part of this package will enable additional visualization functions. ","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Follow the Beam expander and Michelson interferometer tutorials for a quick start into the package interface.","category":"page"},{"location":"#Citation-and-license","page":"Home","title":"Citation and license","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The BeamletOptics package is made available under the MIT license. If you use this package for your research, we encourage you to cite it. For your convenience, a BibTeX entry is provided as part of the package (CITATION.bib) or on Zenodo.","category":"page"},{"location":"#Similar-packages","page":"Home","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A variety of packages and tools exist that implement similar approaches or offer optics modeling capabilities. Within the Julia ecosystem, the following packages need to be mentioned:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpticSim.jl\nABCDMatrixOptics.jl\nWaveOpticsPropagation.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"More broadly speaking, have a look at these packages as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynamicalBilliards.jl\nRayTracer.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"There also exists a plethora of commercial and non-commercial simulation frameworks outside of the Julia ecosystem. For specific examples regarding the beamlet method used in this package, refer to the Complex ray tracing section. ","category":"page"},{"location":"#Development-roadmap","page":"Home","title":"Development roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to warrant a 1.0.0 release tag, the following features will need to be implemented. This definition is arbitrary. The exact timeframe for this development effort is not specified, but will be on the order of 1-2 years.","category":"page"},{"location":"","page":"Home","title":"Home","text":"🔳 TODO\n🟩 WIP\n✅ DONE","category":"page"},{"location":"#Additional-features","page":"Home","title":"Additional features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🔳 Beamlet tracing\n🟩 Implementation of the full polarized astigmatic Gaussian beamlet formalism\nrefer to Worku et al. (2017/2020), Greynolds (1985)\n🔳 Support for (trivial) forms of 2D-field decomposition, e.g. tophat\n🔳 Modeling of the coherence length and contrast influence\n🔳 Components\n🟩 Polarizing optics (based on Jones formalism)\n🔳 Wave plates (λ/2 and λ/4)\n🔳 Retarders\n🔳 Faraday rotators\n✅ Polarizing thin-film filters\n🔳 Isolators\n🔳 Modulators\n🔳 AOM\n🔳 EOM\n🔳 Visualization\n🔳 automatic Makie plot updates (e.g. some form of \"interactive\" mode)\n🔳 Better Lens surface plots based on multiple dispatch","category":"page"}]
}
