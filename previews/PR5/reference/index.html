<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · BeamletOptics.jl</title><meta name="title" content="Reference · BeamletOptics.jl"/><meta property="og:title" content="Reference · BeamletOptics.jl"/><meta property="twitter:title" content="Reference · BeamletOptics.jl"/><meta name="description" content="Documentation for BeamletOptics.jl."/><meta property="og:description" content="Documentation for BeamletOptics.jl."/><meta property="twitter:description" content="Documentation for BeamletOptics.jl."/><meta property="og:url" content="https://StackEnjoyer.github.io/BeamletOptics.jl/reference/"/><meta property="twitter:url" content="https://StackEnjoyer.github.io/BeamletOptics.jl/reference/"/><link rel="canonical" href="https://StackEnjoyer.github.io/BeamletOptics.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="BeamletOptics.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="BeamletOptics.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/expander/">Beam expander</a></li><li><a class="tocitem" href="../tutorials/michelson/">Michelson interferometer</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/spherical_lenses/">Spherical lenses</a></li><li><a class="tocitem" href="../examples/aspherical_lenses/">Aspherical lenses</a></li><li><a class="tocitem" href="../examples/double_gauss/">Double Gauss lens</a></li><li><a class="tocitem" href="../examples/lens_groups/">Lens groups</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../basics/intro/">Introduction</a></li><li><a class="tocitem" href="../basics/rays/">Rays</a></li><li><a class="tocitem" href="../basics/beams/">Beams</a></li><li><a class="tocitem" href="../basics/elements/">Optical elements</a></li><li><a class="tocitem" href="../basics/systems/">Optical systems</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="../components/components/">Overview</a></li><li><a class="tocitem" href="../components/mirrors/">Mirrors</a></li><li><a class="tocitem" href="../components/lenses/">Lenses</a></li><li><a class="tocitem" href="../components/beamsplitters/">Beamsplitters</a></li><li><a class="tocitem" href="../components/detectors/">Detectors</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../guide/">Dev. guide</a></li><li><a class="tocitem" href="../design/">API design</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Literature"><span>Literature</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/StackEnjoyer/BeamletOptics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>This page contains the full source code documentation and the literature referenced througout this website.</p><ul><li><a href="#Reference">Reference</a></li><li><a href="#Literature">Literature</a></li><li><a href="#Index">Index</a></li></ul><h1 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h1><div class="citation canonical"><dl><dt>[1]</dt><dd><div id="Manny">A. Manny. <a href="https://elib.dlr.de/211867/"><em>Simulation of the contrast mechanisms of a heterodyne two-color interferometer</em></a>. Master&#39;s thesis, Faculty of Aerospace Engineering and Geodesy, University of Stuttgart (Dec 2024).</div></dd><dt>[2]</dt><dd><div id="Yun2011_1">G. Yun, K. Crabtree and R. A. Chipman. <a href="https://opg.optica.org/ao/abstract.cfm?URI=ao-50-18-2855"><em>Three-dimensional polarization ray-tracing calculus I: definition and diattenuation</em></a>. <a href="https://doi.org/10.1364/AO.50.002855">Appl. Opt. <strong>50</strong>, 2855–2865</a> (2011).</div></dd><dt>[3]</dt><dd><div id="Yun2011_2">G. Yun, S. C. McClain and R. A. Chipman. <a href="https://opg.optica.org/ao/abstract.cfm?URI=ao-50-18-2866"><em>Three-dimensional polarization ray-tracing calculus II: retardance</em></a>. <a href="https://doi.org/10.1364/AO.50.002866">Appl. Opt. <strong>50</strong>, 2866–2874</a> (2011).</div></dd><dt>[4]</dt><dd><div id="Fowles1989">G. Fowles. <a href="https://books.google.de/books?id=SL1n9TuJ5YMC"><em>Introduction to Modern Optics</em></a>. <em>Dover Books on Physics Series</em> (Dover Publications, 1989).</div></dd><dt>[5]</dt><dd><div id="Peatross2015">M. Ware and J. Peatross. <a href="https://optics.byu.edu/textbook"><em>Physics of Light and Optics (Black &amp; White)</em></a> (Brigham Young University, Department of Physics, 2015).</div></dd><dt>[6]</dt><dd><div id="Saleh2019">B. Saleh and M. Teich. <a href="https://books.google.de/books?id=rcqKDwAAQBAJ"><em>Fundamentals of Photonics</em></a>. <em>Wiley Series in Pure and Applied Optics</em> (Wiley, 2019).</div></dd><dt>[7]</dt><dd><div id="Arnaud1968">J. Arnaud. <a href="https://opg.optica.org/ao/abstract.cfm?URI=ao-24-4-538"><em>Representation of Gaussian beams by complex rays</em></a>. <a href="https://doi.org/10.1364/AO.24.000538">Appl. Opt. <strong>24</strong>, 538–543</a> (1985).</div></dd><dt>[8]</dt><dd><div id="Ashcraft">J. Ashcraft, <a href="https://doi.org/10.5281/zenodo.7117214"><em>poke v0.1.0</em></a>, https://zenodo.org/10.5281/zenodo.7117214 (Sep 2022).</div></dd><dt>[9]</dt><dd><div id="Herloski1983">R. Herloski, S. Marshall and R. Antos. <a href="https://opg.optica.org/ao/abstract.cfm?URI=ao-22-8-1168"><em>Gaussian beam ray-equivalent modeling and optical design</em></a>. <a href="https://doi.org/10.1364/AO.22.001168">Appl. Opt. <strong>22</strong>, 1168–1174</a> (1983).</div></dd><dt>[10]</dt><dd><div id="DeJager1992">D. DeJager and M. Noethen. <a href="https://opg.optica.org/ao/abstract.cfm?URI=ao-31-13-2199"><em>Gaussian beam parameters that use Coddington-based Y–NU paraprincipal ray tracing</em></a>. <a href="https://doi.org/10.1364/AO.31.002199">Appl. Opt. <strong>31</strong>, 2199–2205</a> (1992).</div></dd></dl></div><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Nullable" href="#BeamletOptics.Nullable"><code>BeamletOptics.Nullable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nullable{T}</code></pre><p>An alias which results in <code>Union{T, Nothing}</code> to provide a shorter notation for struct fields which can containing nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.NullableVector" href="#BeamletOptics.NullableVector"><code>BeamletOptics.NullableVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullableVector{T}</code></pre><p>An alias which results in <code>Union{Vector{T}, Nothing}</code> to provide a shorter notation for struct fields which can containing nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RefractiveIndex" href="#BeamletOptics.RefractiveIndex"><code>BeamletOptics.RefractiveIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefractiveIndex</code></pre><p>Union type that represents valid means to pass a refractive index <code>n</code> to e.g. <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>s. The core assumption is that:</p><ol><li>the refractive index is callable with a <strong>single</strong> <code>Number</code> argument <code>λ</code> to represent the wavelength in [m]</li><li>the return value is a <strong>single</strong> <code>Number</code> value for the refractive index</li></ol><p>Refer to e.g. <a href="#BeamletOptics.DiscreteRefractiveIndex"><code>DiscreteRefractiveIndex</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L377-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractBeam" href="#BeamletOptics.AbstractBeam"><code>BeamletOptics.AbstractBeam</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBeam{T &lt;: Real, R &lt;: AbstractRay{T}}</code></pre><p>A generic type for a container type which holds rays, beams etc.</p><p><strong>Parametrization:</strong></p><p>A subtype of <code>AbstractBeam</code> is parameterized by its main data type <code>T &lt;: Real</code>, as well as the underlying ray representation <code>R &lt;: AbstractRay{T}</code>. If a beam is to be compatible with different <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a> implementations, it must be parameterized by <code>T</code> and <code>R</code>. However, it can also be set to a fixed type for <code>T</code> and <code>R</code>, i.e. <code>MyBeam &lt;: AbstractBeam{Float32, MyRay}</code>.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractBeam</code> must implement the following:</p><p><strong>Fields:</strong></p><ul><li><code>parent</code>: a <a href="#BeamletOptics.Nullable"><code>Nullable</code></a> field that holds the same type as the subtype, used for tree navigation</li><li><code>children</code>: a vector that holds the same type as the subtype, used for sub-beam tracking, i.e. beamsplitting</li></ul><p><strong>Functions:</strong></p><ul><li><code>_modify_beam_head!</code>: modifies the beam path for retracing purposes</li><li><code>_last_beam_intersection</code>: returns the last <code>Beam</code> intersection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractBeam.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractBeamsplitter" href="#BeamletOptics.AbstractBeamsplitter"><code>BeamletOptics.AbstractBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBeamsplitter &lt;: AbstractObject</code></pre><p>A generic type to represent an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> that splits incoming beams by reflection and transmission.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractBeamsplitter</code> should implement all supertype requirements.</p><p><strong>Interaction logic</strong></p><p>After intersection with the <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> at which the beam splitting occurs, the <code>interact3d</code> function  should appended the transmitted and reflected sub-beams to the parent beam via the <a href="#BeamletOptics.children!-Union{Tuple{B}, Tuple{B, B}} where B&lt;:BeamletOptics.AbstractBeam"><code>children!</code></a> function. The <code>interact3d</code> function should then return <code>nothing</code> in order to stop the tracing of the parent beam.</p><div class="admonition is-info"><header class="admonition-header">Appending convention</header><div class="admonition-body"><p>As a convention, when splitting an incoming beam, the order of <code>children</code> appended to the parent beam should be</p><ol><li>transmitted beam</li><li>reflected beam</li></ol></div></div><p><strong>Functions</strong></p><ul><li><code>interact3d</code>: see above</li><li><code>_beamsplitter_transmitted_beam</code>: optional helper function</li><li><code>_beamsplitter_reflected_beam</code>: optical helper function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/Beamsplitters.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractCylindricalSurfaceSDF" href="#BeamletOptics.AbstractCylindricalSurfaceSDF"><code>BeamletOptics.AbstractCylindricalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCylindricalSurfaceSDF &lt;: AbstractLensSDF{T}</code></pre><p>A class of <a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>s that can be used to represent cylindric non-rotationally symmetric lens surfaces. It is implicity assumed that all surfaces are represented by <strong>closed volumes</strong> for ray-tracing correctness.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractCylindricalSurfaceSDF</code> must implement the following additional methods.</p><p><strong>Functions:</strong></p><ul><li><code>height</code>: this function returns the height of the cylinder part of the surface</li><li><code>radius</code>: this function returns the radius of the cylinder surface curvature</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractDetector" href="#BeamletOptics.AbstractDetector"><code>BeamletOptics.AbstractDetector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDetector &lt;: AbstractObject</code></pre><p>A generic representation of a detector that evaluates <a href="#BeamletOptics.AbstractBeam"><code>AbstractBeam</code></a> data during interaction. Refer to <a href="#BeamletOptics.Photodetector"><code>Photodetector</code></a> for more information.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractDetector</code> should implement all supertype requirements as well as:</p><p><strong>Functions</strong></p><ul><li><code>interact3d</code>: see e.g. <a href="#BeamletOptics.Photodetector"><code>Photodetector</code></a> for reference</li><li><code>reset_detector!</code>: resets data stored in the detector, see below</li></ul><p><strong>Additional information</strong></p><p>The information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.</p><p><strong>Data mutability</strong></p><p>In order to model field superposition effects, the concrete implementation of an <code>AbstractDetector</code> should be a <strong>mutable struct</strong> with a <code>const</code>ant <code>shape</code> field. This is necessary, since (sub-)beams will interact sequentially with the detector during <a href="../basics/systems/#BeamletOptics.solve_system!-basics-systems"><code>solve_system!</code></a>. Only if the data can be accumulated sequentially, multiple beam interactions can be captured for a complex system, e.g. an interferometer.</p><p><strong>Data reset</strong></p><p>Since e.g. E-field data is supposed to be accumulated by mutability of the detector data, the burden of resetting the data for a new solver call is placed on the user. This function should be called <code>reset_detector!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Detectors.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractInteraction" href="#BeamletOptics.AbstractInteraction"><code>BeamletOptics.AbstractInteraction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractInteraction</code></pre><p>Describes how an <a href="#BeamletOptics.AbstractBeam"><code>AbstractBeam</code></a> and an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> interact with each other. This data type stores information from the <a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a> function and provides it to the solver. The solver can use this data to extend the <a href="#BeamletOptics.AbstractBeam"><code>AbstractBeam</code></a>.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractInteraction</code> must implement the following:</p><p><strong>Fields</strong></p><ul><li><code>hint</code>: a nullable <a href="#BeamletOptics.Hint"><code>Hint</code></a> for the solver (optional but recommended)</li></ul><p><strong>Beam data</strong></p><p>It is required that concrete implementations of this type provide some form of data on how to extend the beam. For instance, refer to <a href="#BeamletOptics.BeamInteraction"><code>BeamInteraction</code></a> and <a href="#BeamletOptics.GaussianBeamletInteraction"><code>GaussianBeamletInteraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractSystem.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractLensSDF" href="#BeamletOptics.AbstractLensSDF"><code>BeamletOptics.AbstractLensSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLensSDF</code></pre><p>A class of <a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>s that can be used to represent rotationally symmetric lens surfaces. It is implicity assumed that all surfaces are represented by <strong>closed volumes</strong> for ray-tracing correctness.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractLensSDF</code> must implement the following:</p><p><strong>Functions:</strong></p><ul><li><code>thickness</code>: this function returns the material thickness of the element along its symmetry axis</li><li><code>diameter</code>: this function returns the outer diameter of the element</li></ul><div class="admonition is-info"><header class="admonition-header">Shape orientation</header><div class="admonition-body"><p>For easy compatibility between subtypes, the follwing requirements should be fulfilled:</p><ol><li>Symmetry axis aligned onto the y-axis</li><li>Surface contour aligned towards negative y-values</li><li>Surface point with <code>min(y)</code> should satisfy <code>min(y) = 0</code> on the symmetry axis</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractMesh" href="#BeamletOptics.AbstractMesh"><code>BeamletOptics.AbstractMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMesh &lt;: AbstractShape</code></pre><p>A generic type for an shape whose volume can be described by a mesh. Must have a field <code>mesh</code> of type <code>Mesh</code>. See also <code>Mesh{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractObject" href="#BeamletOptics.AbstractObject"><code>BeamletOptics.AbstractObject</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractObject</code></pre><p>A generic type for 2D/3D objects that can be used to model optical elements. The geometry of the object is represented via a <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a>. The optical effect that occurs between the object and an incoming ray/beam of light is modeled via its <a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a> method.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractObject</code> must implement the following:</p><p><strong>Shape trait</strong></p><p>An <code>AbstractObject</code> can consist of a single <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a>, e.g. a lens element, or a collection of functionally dependant shapes, e.g. a cube beamsplitter. In order to model this, the API implementation of an <code>AbstractObject</code> requires the definition of the <strong>shape trait</strong>. This trait allows the dispatch onto specialized methods to handle the kinematic interface and tracing methods for objects consisting of one or more shapes.</p><ul><li><code>shape_trait_of</code>: defines the shape type of the <code>AbstractObject</code>, refer to <a href="#BeamletOptics.AbstractShapeTrait"><code>AbstractShapeTrait</code></a> for more information</li></ul><div class="admonition is-info"><header class="admonition-header">Default shape trait</header><div class="admonition-body"><p>Unless specified otherwise, the <code>shape_trait_of</code> an <code>AbstractObject</code> is defined as <a href="#BeamletOptics.SingleShape"><code>SingleShape</code></a>. This requires <code>object.shape</code> as a dedicated field. For <a href="#BeamletOptics.MultiShape"><code>MultiShape</code></a>s the getter function <code>shape(object)</code> must return a tuple of all shapes that make up the object.</p></div></div><p><strong>Getters/setters</strong></p><p>All kinematic functions defined for the <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> can also be called for a <code>AbstractObject</code>. In this case, the shape trait will define how the specific movement function is dispatched.</p><p><strong>Functions:</strong></p><ul><li><a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a>: defines the optical interaction, the return type must be <code>Nothing</code> or an <a href="#BeamletOptics.AbstractInteraction"><code>AbstractInteraction</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractObjectGroup" href="#BeamletOptics.AbstractObjectGroup"><code>BeamletOptics.AbstractObjectGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractObjectGroup &lt;: AbstractObject</code></pre><p>Container type for groups of optical elements, based on a tree-like data structure. Intended for easier kinematic handling of connected elements. See also <a href="#BeamletOptics.ObjectGroup"><code>ObjectGroup</code></a> for a concrete implementation.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractObjectGroup</code> must implement the following:</p><p><strong>Fields:</strong></p><ul><li><code>objects</code>: stores objects or additional subgroups of objects, allows for hierarchical structures</li></ul><p><strong>Functions:</strong></p><ul><li>for the kinematic API, all corresponding functions of <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> must be implemented</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractPlateBeamsplitter" href="#BeamletOptics.AbstractPlateBeamsplitter"><code>BeamletOptics.AbstractPlateBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractPlateBeamsplitter &lt;: AbstractBeamsplitter</code></pre><p>A generic type to represent an <a href="#BeamletOptics.AbstractBeamsplitter"><code>AbstractBeamsplitter</code></a> that consists of a substrate with a  single coated face at which a beam splitting interaction occurs.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractPlateBeamsplitter</code> should implement all supertype reqs. as well as:</p><p><strong>Fields</strong></p><ul><li><code>coating</code>: a <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> that represents the splitter coating</li><li><code>substrate</code>: a <a href="#BeamletOptics.Prism"><code>Prism</code></a> that represents the substrate</li></ul><p><strong>Getters/setters</strong></p><p>If the concrete implementation does not define the above fields, the following getters must be defined:</p><ul><li><code>coating</code>: returns a <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a></li><li><code>substrate</code>: returns a <a href="#BeamletOptics.Prism"><code>Prism</code></a></li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Object orientation</header><div class="admonition-body"><p>This <code>interact3d</code> method of this type strongly assumes that the coating is positioned directly upon a single face of the substrate with a 100% fill factor.</p></div></div><div class="admonition is-info"><header class="admonition-header">Interaction logic</header><div class="admonition-body"><p>This type uses the <a href="#BeamletOptics.Hint"><code>Hint</code></a>-API in order to ensure that the splitting interaction is correctly triggered at the coating.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractRay" href="#BeamletOptics.AbstractRay"><code>BeamletOptics.AbstractRay</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRay{T&lt;:Real}</code></pre><p>An implementation for a geometrical optics ray in R³. In general, a <code>AbstractRay</code> is described by <span>$\vec{p} + t\cdot\vec{d}$</span> with <span>$t\in(0,\infty)$</span>. <code>AbstractRay</code>s are intended to model the propagation of light between optical interactions according to the laws of geometrical optics. To store the result of a ray tracing solution, refer to <a href="#BeamletOptics.AbstractBeam"><code>AbstractBeam</code></a>.</p><p><strong>Intersections:</strong></p><p>Since the length of a ray can not be known before solving an optical system, the <a href="#BeamletOptics.Intersection"><code>Intersection</code></a>-type is used. This <a href="#BeamletOptics.Nullable"><code>Nullable</code></a> type can represent the intersection with an optical element, or lack thereof.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractBeam</code> must implement the following:</p><p><strong>Fields:</strong></p><ul><li><code>pos</code>: a R³-vector that stores the current position <span>$\vec{p}$</span></li><li><code>dir</code>: a R³-vector that stores the current direction <span>$\vec{d}$</span></li><li><code>intersection</code>: a <code>Nullable</code> field that stores the current [<code>Intersection</code>] or <code>nothing</code></li><li><code>λ</code>: wavelength in [m]</li><li><code>n</code>: refractive index along the ray path</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Ray length</header><div class="admonition-body"><p>Base.<code>length</code>: this function is used to return the length of the <code>AbstractRay</code> (if no intersection exists, the ray length is <code>Inf</code>). The <code>opl</code> keyword can be used to obtain the optical path length instead.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Ray direction</header><div class="admonition-body"><p>Many functions assume that the <code>dir</code>ection vector has unit length (i.e. <span>$|\vec{p}| = 1$</span>). Violating this assumption might lead to spurious results.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L43-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractReflectiveOptic" href="#BeamletOptics.AbstractReflectiveOptic"><code>BeamletOptics.AbstractReflectiveOptic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReflectiveOptic &lt;: AbstractObject</code></pre><p>A generic type to represent an [<code>AbstractObject</code>] which reflects incoming rays.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractReflectiveOptic</code> should implement all supertype reqs. as well as:</p><p><strong>Fields</strong></p><ul><li>no specific fields required</li></ul><p><strong>Getters/setters</strong></p><ul><li>none required</li></ul><p><strong>Functions</strong></p><ul><li><code>interact3d</code>:  the interaction logic should be akin to <a href="#BeamletOptics.reflection3d-Tuple{Any, Any}"><code>reflection3d</code></a> for each surface crossing</li></ul><p><strong>Additional information</strong></p><p>The information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.</p><div class="admonition is-info"><header class="admonition-header">Polarization ray tracing</header><div class="admonition-body"><p>Fresnel coefficients during reflection are set such that no reflection losses occur (i.e. <code>|rₚ| = |rₛ| = 1</code>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractRefractiveOptic" href="#BeamletOptics.AbstractRefractiveOptic"><code>BeamletOptics.AbstractRefractiveOptic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRefractiveOptic &lt;: AbstractObject</code></pre><p>A generic type to represent an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> that refracts incoming rays.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractRefractiveOptic</code> should implement all supertype reqs. as well as:</p><p><strong>Fields</strong></p><ul><li><code>n</code>: a callable field which returns the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> for a wavelength <code>λ</code></li></ul><p><strong>Getters/setters</strong></p><ul><li><code>refractive_index</code>: gets the ref. index data of the optic</li></ul><p><strong>Functions</strong></p><ul><li><code>interact3d</code>: the interaction logic should be akin to <a href="#BeamletOptics.refraction3d-Tuple{AbstractArray, AbstractArray, Real, Real}"><code>refraction3d</code></a> for each surface crossing</li></ul><p><strong>Additional information</strong></p><p>The information provided below applies to the standard functional implementation of this type and may be overwritten by specialized subtypes.</p><div class="admonition is-info"><header class="admonition-header">Uniform ref. index</header><div class="admonition-body"><p>It is assumed that the optic consists of a single transparent material with a homogeneous refractive index <code>n</code>. It does not consider coated surfaces.</p></div></div><div class="admonition is-info"><header class="admonition-header">Polarization ray tracing</header><div class="admonition-body"><p>Fresnel coefficients at the point of refraction are calculated via the <a href="#BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T"><code>fresnel_coefficients</code></a> function with the refractive index data of the substrate and the previous medium.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractRotationallySymmetricSurface" href="#BeamletOptics.AbstractRotationallySymmetricSurface"><code>BeamletOptics.AbstractRotationallySymmetricSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRotationallySymmetricSurface{T} &lt;: AbstractSurface{T}</code></pre><p>A surface type which is rotationally symmetric around one axis.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractShape</code> should implement the following:</p><p><strong>Getters/setters</strong></p><ul><li><a href="#BeamletOptics.radius-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}"><code>radius</code></a> : Returns the radius of curvature of the <code>AbstractRotationallySymmetricSurface</code></li><li><a href="#BeamletOptics.diameter-Tuple{BeamletOptics.AbstractLensSDF}"><code>diameter</code></a> : Returns the clear optical diameter of the <code>AbstractRotationallySymmetricSurface</code></li><li><a href="#BeamletOptics.mechanical_diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}"><code>mechanical_diameter</code></a> : Returns the mechanical diameter of the <code>AbstractRotationallySymmetricSurface</code></li><li><a href="#BeamletOptics.edge_sag-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractSDF}"><code>edge_sag</code></a> : Returns the edge sagitta of the <code>AbstractRotationallySymmetricSurface</code></li></ul><p><strong>Functions:</strong></p><ul><li><a href="#BeamletOptics.sdf-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, Union{Nothing, BeamletOptics.AbstractOrientationType}}"><code>sdf(::AbstractRotationallySymmetricSurface, ::Union{Nothing, AbstractOrientationType})</code></a> :   Converts the surface specification of <code>AbstractRotationallySymmetricSurface</code> into an <code>AbstractSDF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L9-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractSDF" href="#BeamletOptics.AbstractSDF"><code>BeamletOptics.AbstractSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSDF &lt;: AbstractShape</code></pre><p>Provides a shape function based on signed distance functions. See https://iquilezles.org/articles/distfunctions/ for more information.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractSDF</code> should implement all reqs. of <code>AbstractShape</code> as well as the following:</p><p><strong>Functions</strong></p><ul><li><code>sdf(::AbstractSDF, point)</code>: a function that returns the signed distance for a point in 3D space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractShape" href="#BeamletOptics.AbstractShape"><code>BeamletOptics.AbstractShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractShape{T&lt;:Real}</code></pre><p>A generic type for a shape that exists in 3D-space. Must have a <code>pos</code>ition and orientation.<br/>Types used to describe the geometry of a shape should be subtypes of <code>Real</code>.<br/></p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractShape</code> should implement the following:</p><p><strong>Fields:</strong></p><ul><li><code>pos</code>: a 3D-vector that stores the current <code>position</code> of the object-specific coordinate system</li><li><code>dir</code>: a 3x3-matrix that represents the orthonormal basis of the object and therefore, the <code>orientation</code></li></ul><p><strong>Getters/setters</strong></p><ul><li><a href="#BeamletOptics.position-Tuple{BeamletOptics.AbstractObject}"><code>position</code></a> / <code>position!</code>: gets or sets the <code>pos</code>ition vector of the <code>AbstractShape</code></li><li><a href="#BeamletOptics.orientation-Tuple{BeamletOptics.AbstractObject}"><code>orientation</code></a> / <code>orientation!</code>: gets or sets the orientation matrix of the <code>AbstractShape</code></li></ul><p><strong>Kinematic:</strong></p><ul><li><a href="#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>translate3d!</code></a>: the object is moved by a translation vector relative to its current position</li><li><a href="#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.AbstractShape, Any}"><code>translate_to3d!</code></a>: the object is moved towards the target position</li><li><a href="#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractMesh, Any, Any}"><code>rotate3d!</code></a>: the object is rotated by an angle around a reference vector</li><li><a href="#BeamletOptics.xrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>xrotate3d!</code></a>: rotation around the x-axis</li><li><a href="#BeamletOptics.yrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>yrotate3d!</code></a>: rotation around the y-axis</li><li><a href="#BeamletOptics.zrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>zrotate3d!</code></a>: rotation around the z-axis</li><li><a href="#BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>align3d!</code></a>: align local shape y-axis with target vector</li><li><a href="#BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T"><code>reset_translation3d!</code></a>: return the <code>object</code> to the global origin</li><li><a href="#BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T"><code>reset_rotation3d!</code></a>: rotate the <code>object</code> back into its original state</li></ul><p><strong>Ray Tracing:</strong></p><ul><li><a href="#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractObject, BeamletOptics.AbstractRay}"><code>intersect3d</code></a>: returns the intersection between an <code>AbstractShape</code> and <code>AbstractRay</code>, or lack thereof. See also <a href="#BeamletOptics.Intersection"><code>Intersection</code></a></li></ul><p><strong>Rendering (with Makie):</strong></p><ul><li><code>render_shape!</code>: plot the <code>shape</code> into an <code>Axis3</code> or <code>LScene</code> environment</li><li><code>render_shape_normals!</code>: plot the <code>shape</code> surface normals into an <code>Axis3</code> environment (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractShapeTrait" href="#BeamletOptics.AbstractShapeTrait"><code>BeamletOptics.AbstractShapeTrait</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractShapeTrait</code></pre><p>The shape trait defines how many shapes an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> consists of.  Two different traits are defined:</p><ol><li><a href="#BeamletOptics.SingleShape"><code>SingleShape</code></a>: the <code>AbstractObject</code> consists of a single <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a></li><li><a href="#BeamletOptics.MultiShape"><code>MultiShape</code></a>: the <code>AbstractObject</code> consists of two or more <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a>s</li></ol><p>Refer to the respective documentation for more information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractSphericalSurfaceSDF" href="#BeamletOptics.AbstractSphericalSurfaceSDF"><code>BeamletOptics.AbstractSphericalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSphericalSurfaceSDF{T} &lt;: AbstractSDF{T}</code></pre><p>An abstract type for SDF-based volumes which represent spherical lens surfaces, i.e. <a href="#BeamletOptics.ConvexSphericalSurfaceSDF"><code>ConvexSphericalSurfaceSDF</code></a> or <a href="#BeamletOptics.ConcaveSphericalSurfaceSDF"><code>ConcaveSphericalSurfaceSDF</code></a>.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractSphericalSurfaceSDF</code> should implement all supertype reqs. as well as the following:</p><p><strong>Fields:</strong></p><ul><li><code>radius</code>: the radius of curvature</li><li><code>diameter</code>: the lens outer diameter</li><li><code>sag</code>: the lens sagitta</li></ul><p><strong>Lens construction</strong></p><p>It is intended that practical lens shapes are constructed from <code>AbstractSphericalSurfaceSDF</code>s using the <a href="#BeamletOptics.UnionSDF"><code>UnionSDF</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractSurface" href="#BeamletOptics.AbstractSurface"><code>BeamletOptics.AbstractSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSurface{T}</code></pre><p>A generic type for a surface which is basically an information storage type in order to build shapes (volumes) from a combination of surfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AbstractSystem" href="#BeamletOptics.AbstractSystem"><code>BeamletOptics.AbstractSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSystem</code></pre><p>A generic representation of a system of optical elements.</p><p><strong>Implementation reqs.</strong></p><p>Subtypes of <code>AbstractSystem</code> must implement the following:</p><p><strong>Fields:</strong></p><ul><li><code>objects</code>: a vector or tuple of <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>s that make up the system</li><li><code>n</code>: (optional) <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the surrounding medium, default value is 1.0</li></ul><p><strong>Functions:</strong></p><ul><li><code>refractive_index</code>: returns the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> <code>n</code> of the system medium, see above</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractSystem.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AconcaveCylinderSDF" href="#BeamletOptics.AconcaveCylinderSDF"><code>BeamletOptics.AconcaveCylinderSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AconcaveCylinderSDF{T} &lt;: AbstractAcylindricalSurfaceSDF{T}</code></pre><p>Implements the <code>SDF</code> of a concave cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AconcaveCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}" href="#BeamletOptics.AconcaveCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}"><code>BeamletOptics.AconcaveCylinderSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AconcaveCylinderSDF(radius, diameter, height)</code></pre><p>Constructs an aconcave cylinder cutout with radius <code>r</code>, diameter <code>d</code> and height <code>h</code> in [m]. The acylindric shape is defined by its <code>conic_constant</code> and the <code>coefficients</code> for the even aspheric polynomoial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AconvexCylinderSDF" href="#BeamletOptics.AconvexCylinderSDF"><code>BeamletOptics.AconvexCylinderSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AconvexCylinderSDF{T} &lt;: AbstractAcylindricalSurfaceSDF{T}</code></pre><p>Implements the <code>SDF</code> of a cut cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AconvexCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}" href="#BeamletOptics.AconvexCylinderSDF-Union{Tuple{TT}, Tuple{CC}, Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H, CC, AbstractVector{TT}}} where {R, D, H, CC, TT}"><code>BeamletOptics.AconvexCylinderSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AconvexCylinderSDF(radius, diameter, height)</code></pre><p>Constructs an aconvex cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code> in [m]. The acylindric shape is defined by its <code>conic_constant</code> and the <code>coefficients</code> for the even aspheric polynomoial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AcylindricalSurface" href="#BeamletOptics.AcylindricalSurface"><code>BeamletOptics.AcylindricalSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AcylindricalSurface{T} &lt;: AbstractAcylindricalSurface{T}</code></pre><p>A type representing an acylindric optical surface defined by its radius of curvature, diameter, height, mechanical diameter, conic constant and even aspheric coefficients. It is therefore a cylindric surface with a deviation from the perfect cylindric shape.</p><p><strong>Fields</strong></p><ul><li><code>radius::T</code>: The radius of curvature of the curved surface.</li><li><code>diameter::T</code>: The clear (optical) aperture of the surface.</li><li><code>height::T</code> : The height/length of the uncurved surface direction</li><li><code>conic_constant::T</code> : The conic_constant of the curved surface</li><li><code>coefficients::Vector{T}</code> : The coefficients of the even aspherical equation for the curved surface.</li><li><code>mechanical_diameter::T</code>: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.AcylindricalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, T4, AbstractVector{T5}}} where {T1, T2, T3, T4, T5}" href="#BeamletOptics.AcylindricalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, T4, AbstractVector{T5}}} where {T1, T2, T3, T4, T5}"><code>BeamletOptics.AcylindricalSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AcylindricalSurface(radius, diameter, height, conic_constant, coefficients)</code></pre><p>Construct a <code>CylindricalSurface</code> given the radius of curvature, optical diameter and height. This constructor automatically sets the mechanical diameter equal to the optical diameter.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: The radius of curvature of the curved surface.</li><li><code>diameter</code>: The clear (optical) diameter of the surface.</li><li><code>height</code>: The height/length of the uncurved surface direction.</li><li><code>conic_constant::T</code> : The conic_constant of the curved surface</li><li><code>coefficients::Vector{T}</code> : The coefficients of the even aspherical equation for the curved surface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AcylindricalSDF.jl#L176-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Beam" href="#BeamletOptics.Beam"><code>BeamletOptics.Beam</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Beam{T, R &lt;: AbstractRay{T}} &lt;: AbstractBeam{T, R}</code></pre><p>Stores the rays that are calculated from geometric optics when propagating through an optical system. The <code>Beam</code> type is parametrically defined by the <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a> subtype that it stores.</p><p><strong>Fields</strong></p><ul><li><code>rays</code>: vector of <code>AbstractRay</code> objects, representing the rays that make up the beam</li><li><code>parent</code>: reference to the parent beam, if any (<a href="#BeamletOptics.Nullable"><code>Nullable</code></a> to account for the root beam which has no parent)</li><li><code>children</code>: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.BeamInteraction" href="#BeamletOptics.BeamInteraction"><code>BeamletOptics.BeamInteraction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BeamInteraction &lt;: AbstractInteraction</code></pre><p>This type is used to store the new <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a> resulting from on optical interaction between a <a href="#BeamletOptics.Beam"><code>Beam</code></a> and some <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>hint</code>: optional <a href="#BeamletOptics.Hint"><code>Hint</code></a> for the solver</li><li><code>ray</code>: new <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a> resulting from the interaction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.BoxSDF" href="#BeamletOptics.BoxSDF"><code>BeamletOptics.BoxSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxSDF &lt;: AbstractSDF</code></pre><p>Implements the box SDF with edge lengths <code>x</code>, <code>y</code>, and <code>z</code>. Note that these values are stored in the <code>dimensions</code> field as:</p><ul><li><code>dimensions</code>::Point3 = (   len<em>in</em>x/2,   len<em>in</em>y/2,   len<em>in</em>z/2,</li></ul><p>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.BoxSDF-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}} where {X&lt;:Real, Y&lt;:Real, Z&lt;:Real}" href="#BeamletOptics.BoxSDF-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}} where {X&lt;:Real, Y&lt;:Real, Z&lt;:Real}"><code>BeamletOptics.BoxSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxSDF(x, y, z)</code></pre><p>Creates a <a href="#BeamletOptics.BoxSDF"><code>BoxSDF</code></a> with:</p><ul><li><code>x</code>: x-dir. edge length in [m]</li><li><code>y</code>: y-dir. edge length in [m]</li><li><code>z</code>: z-dir. edge length in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CircularFlatSurface" href="#BeamletOptics.CircularFlatSurface"><code>BeamletOptics.CircularFlatSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularFlatSurface{T} &lt;: AbstractRotationallySurface{T}</code></pre><p>A type representing a planar circular surface, which is only parametrized by its <code>diameter</code>.</p><p><strong>Fields</strong></p><ul><li><code>diameter::T</code>: The diameter of the planar surface</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveAsphericalSurfaceSDF" href="#BeamletOptics.ConcaveAsphericalSurfaceSDF"><code>BeamletOptics.ConcaveAsphericalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveAsphericalSurfaceSDF</code></pre><p>Constructs an aspheric lens with a concave-like surface according to ISO10110.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, it is assumed that the aspheric surface is concave if the radius is negative. There might be unexpected effects for complex shapes which do not show a generally concave behavior.</p></div></div><ul><li><code>coefficients</code> : (even) coefficients of the asphere.</li><li><code>radius</code> : radius of the lens (negative!)</li><li><code>conic_constant</code> : conic constant of the lens surface</li><li><code>diameter</code>: lens diameter</li><li><code>mechanical_diameter</code>: mechanical lens diameter, defaults to be identical to the lens diameter, Otherwise       an outer ring section will be added to the lens, if <code>mechanical_diameter</code> &gt; <code>diameter</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveCylinderSDF" href="#BeamletOptics.ConcaveCylinderSDF"><code>BeamletOptics.ConcaveCylinderSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveCylinderSDF &lt;: AbstractSDF</code></pre><p>Implements the <code>SDF</code> of a concave cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}" href="#BeamletOptics.ConcaveCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}"><code>BeamletOptics.ConcaveCylinderSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveCylinderSDF(radius, diameter, height)</code></pre><p>Constructs a concave cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code> in [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveSphericalMirror" href="#BeamletOptics.ConcaveSphericalMirror"><code>BeamletOptics.ConcaveSphericalMirror</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveSphericalMirror &lt;: AbstractReflectiveOptic</code></pre><p>An ideal concave mirror with spherical reflecting surface, e.g. R = 1. See also <a href="#BeamletOptics.RoundPlanoMirror"><code>RoundPlanoMirror</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: a <a href="#BeamletOptics.ConcaveSphericalMirrorShape"><code>ConcaveSphericalMirrorShape</code></a> that represents the substrate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L169-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveSphericalMirror-Tuple{Real, Real, Real}" href="#BeamletOptics.ConcaveSphericalMirror-Tuple{Real, Real, Real}"><code>BeamletOptics.ConcaveSphericalMirror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveSphericalMirror(radius, thickness, diameter)</code></pre><p>Constructor for a spherical mirror with a concave reflecting surface. The component is aligned with the positive y-axis. See also <a href="#BeamletOptics.ConcaveSphericalMirror"><code>ConcaveSphericalMirror</code></a>. </p><p><strong>Inputs</strong></p><ul><li><code>radius</code>: the spherical surface radius of curvature in [m]</li><li><code>thickness</code>: substrate thickness in [m]</li><li><code>diameter</code>: mirror outer diameter in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveSphericalMirrorShape" href="#BeamletOptics.ConcaveSphericalMirrorShape"><code>BeamletOptics.ConcaveSphericalMirrorShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><a href="#BeamletOptics.ConcaveSphericalMirror"><code>ConcaveSphericalMirror</code></a> shape type based on a <a href="#BeamletOptics.UnionSDF"><code>UnionSDF</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveSphericalSurfaceSDF" href="#BeamletOptics.ConcaveSphericalSurfaceSDF"><code>BeamletOptics.ConcaveSphericalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveSphericalSurfaceSDF</code></pre><p><a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>-based representation of a concave spherical lens surface. When constructed, it is assumed that the plano-surface lies at the origin and the optical axis is aligned with the <code>y</code>-axis. The concave surface is orientated towards negative y-values for <code>R &gt; 0</code> and vice versa.</p><p><strong>Fields:</strong></p><ul><li><code>radius</code>: the radius of curvature of the convex spherical surface.</li><li><code>diameter</code>: the outer diameter of the lens surface</li><li><code>sag</code>: the sagitta of the opposing convex shape</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L118-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConcaveSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}" href="#BeamletOptics.ConcaveSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}"><code>BeamletOptics.ConcaveSphericalSurfaceSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConcaveSphericalSurfaceSDF(radius, diameter)</code></pre><p>Constructs a <a href="#BeamletOptics.ConcaveSphericalSurfaceSDF"><code>ConcaveSphericalSurfaceSDF</code></a> with a specific <code>radius</code> of curvature and lens outer <code>diameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConvexAsphericalSurfaceSDF" href="#BeamletOptics.ConvexAsphericalSurfaceSDF"><code>BeamletOptics.ConvexAsphericalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexAsphericalSurfaceSDF</code></pre><p>Constructs an aspheric lens with a convex-like surface according to ISO10110.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, it is assumed that the aspheric surface is convex if the radius is positive. There might be unexpected effects for complex shapes which do not show a generally convex behavior.</p></div></div><ul><li><code>coefficients</code> : (even) coefficients of the asphere.</li><li><code>radius</code> : radius of the lens</li><li><code>conic_constant</code> : conic constant of the lens surface</li><li><code>diameter</code>: lens diameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConvexCylinderSDF" href="#BeamletOptics.ConvexCylinderSDF"><code>BeamletOptics.ConvexCylinderSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexCylinderSDF &lt;: AbstractSDF</code></pre><p>Implements the <code>SDF</code> of a cut cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConvexCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}" href="#BeamletOptics.ConvexCylinderSDF-Union{Tuple{H}, Tuple{D}, Tuple{R}, Tuple{R, D, H}} where {R, D, H}"><code>BeamletOptics.ConvexCylinderSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexCylinderSDF(radius, diameter, height)</code></pre><p>Constructs a cut cylinder with radius <code>r</code>, diameter <code>d</code> and height <code>h</code> in [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConvexSphericalSurfaceSDF" href="#BeamletOptics.ConvexSphericalSurfaceSDF"><code>BeamletOptics.ConvexSphericalSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexSphericalSurfaceSDF</code></pre><p><a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>-based representation of a convex spherical lens surface. When constructed, it is assumed that the plano-surface lies at the origin and the optical axis is aligned with the <code>y</code>-axis. The convex surface is orientated towards negative y-values for <code>R &gt; 0</code> and vice versa.</p><p><strong>Fields:</strong></p><ul><li><code>radius</code>: the radius of curvature of the concave spherical surface.</li><li><code>diameter</code>: the outer diameter of the lens surface</li><li><code>sag</code>: the sagitta of the convex shape</li><li><code>height</code>: the sphere cutoff height, see also <a href="#BeamletOptics.CutSphereSDF"><code>CutSphereSDF</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L172-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ConvexSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}" href="#BeamletOptics.ConvexSphericalSurfaceSDF-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R, D}"><code>BeamletOptics.ConvexSphericalSurfaceSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ConvexSphericalSurfaceSDF(radius, diameter)</code></pre><p>Constructs a <a href="#BeamletOptics.ConvexSphericalSurfaceSDF"><code>ConvexSphericalSurfaceSDF</code></a> with a specific <code>radius</code> of curvature and lens outer <code>diameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CubeBeamsplitter" href="#BeamletOptics.CubeBeamsplitter"><code>BeamletOptics.CubeBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubeBeamsplitter &lt;: AbstractBeamsplitter</code></pre><p>A cuboid beamsplitter where the splitting interaction occurs between two <a href="#BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>RightAnglePrism</code></a>s. For more information refer to the <a href="#BeamletOptics.AbstractPlateBeamsplitter"><code>AbstractPlateBeamsplitter</code></a> docs.</p><p><strong>Fields</strong></p><ul><li><code>front</code>: the forward facing substrate, represented by a <a href="#BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>RightAnglePrism</code></a></li><li><code>back</code>: the backward facing substrate, represented by a <a href="#BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>RightAnglePrism</code></a></li><li><code>coating</code>: a rectangular <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> that represents the splitting interface</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Hints and interaction logic</header><div class="admonition-body"><p>In order to model gap-free beam propagation, the <code>interact3d</code> model relies heavily on the <a href="#BeamletOptics.Hint"><code>Hint</code></a>-API. If the <code>front</code> or <code>back</code> substrate is hit, the <code>Hint</code> will ensure that the beam intersects the <code>coating</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/CubeBeamsplitter.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CubeBeamsplitter-Tuple{Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.CubeBeamsplitter-Tuple{Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.CubeBeamsplitter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubeBeamsplitter(leg_length, n; reflectance=0.5)</code></pre><p>Creates a <a href="#BeamletOptics.CubeBeamsplitter"><code>CubeBeamsplitter</code></a>. The cuboid is centered at the origin. The splitter  coating is orientated at a 45° angle with respect to the y-axis.</p><p><strong>Inputs</strong></p><ul><li><code>leg_length</code>: the x-, y- and z-edge length in [m]</li><li><code>n</code>: the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the front and back prism</li></ul><p><strong>Keywords</strong></p><ul><li><code>reflectance</code>: defines the splitting ratio in [-], i.e. R = 0 ... 1.0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/CubeBeamsplitter.jl#L34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CubeBeamsplitterShape" href="#BeamletOptics.CubeBeamsplitterShape"><code>BeamletOptics.CubeBeamsplitterShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Placeholder type for the  shape of a <a href="#BeamletOptics.CubeBeamsplitter"><code>CubeBeamsplitter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/CubeBeamsplitter.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CutSphereSDF" href="#BeamletOptics.CutSphereSDF"><code>BeamletOptics.CutSphereSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CutSphereSDF &lt;: AbstractSDF</code></pre><p>Implements SDF of a sphere which is cut off in the x-z-plane at some point along the y-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CutSphereSDF-Union{Tuple{H}, Tuple{R}, Tuple{R, H}} where {R, H}" href="#BeamletOptics.CutSphereSDF-Union{Tuple{H}, Tuple{R}, Tuple{R, H}} where {R, H}"><code>BeamletOptics.CutSphereSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CutSphereSDF(pos, radius, height)</code></pre><p>Constructs a sphere with <code>radius</code> which is cut off along the y-axis at <code>height</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CylinderSDF" href="#BeamletOptics.CylinderSDF"><code>BeamletOptics.CylinderSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CylinderSDF &lt;: AbstractSDF</code></pre><p>Implements cylinder SDF. Cylinder is initially orientated along the y-axis and symmetrical in x-z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CylindricalSurface" href="#BeamletOptics.CylindricalSurface"><code>BeamletOptics.CylindricalSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CylindricalSurface{T} &lt;: AbstractCylindricalSurface{T}</code></pre><p>A type representing a cylindric optical surface defined by its radius of curvature, diameter, height and mechanical diameter</p><p><strong>Fields</strong></p><ul><li><code>radius::T</code>: The radius of curvature of the curved surface.</li><li><code>diameter::T</code>: The clear (optical) aperture of the surface.</li><li><code>height::T</code> : The height/length of the uncurved surface direction</li><li><code>mechanical_diameter::T</code>: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L150-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CylindricalSurface-Union{Tuple{T}, Tuple{T, T, T}} where T" href="#BeamletOptics.CylindricalSurface-Union{Tuple{T}, Tuple{T, T, T}} where T"><code>BeamletOptics.CylindricalSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CylindricalSurface(radius::T, diameter::T, height::T) where T</code></pre><p>Construct a <code>CylindricalSurface</code> given the radius of curvature, optical diameter and height. This constructor automatically sets the mechanical diameter equal to the optical diameter.</p><p><strong>Arguments</strong></p><ul><li><code>radius::T</code>: The radius of curvature of the curved surface.</li><li><code>diameter::T</code>: The clear (optical) diameter of the surface.</li><li><code>height::T</code>: The height/length of the uncurved surface direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L171-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.DiscreteRefractiveIndex" href="#BeamletOptics.DiscreteRefractiveIndex"><code>BeamletOptics.DiscreteRefractiveIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteRefractiveIndex{T}</code></pre><p>Represents a incomplete set of dispersion data where for each exact wavelength one refractive index value is stored in the <code>data</code> field. Can be called like a function <code>n = n(λ)</code>. Does not interpolate between data points. Refer to <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L317-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.DiscreteRefractiveIndex-Union{Tuple{N}, Tuple{L}, Tuple{AbstractArray{L}, AbstractArray{N}}} where {L, N}" href="#BeamletOptics.DiscreteRefractiveIndex-Union{Tuple{N}, Tuple{L}, Tuple{AbstractArray{L}, AbstractArray{N}}} where {L, N}"><code>BeamletOptics.DiscreteRefractiveIndex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteRefractiveIndex(λs, n)</code></pre><p>Creates a <a href="#BeamletOptics.DiscreteRefractiveIndex"><code>DiscreteRefractiveIndex</code></a> dictionary where each wavelength in <code>λs</code> is mapped onto an exact exact refractive index in <code>ns</code>.</p><p><strong>Inputs</strong></p><ul><li><code>λs</code>: array of wavelengths</li><li><code>ns</code>: array of refractive indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L328-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.DoubletLens" href="#BeamletOptics.DoubletLens"><code>BeamletOptics.DoubletLens</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoubletLens</code></pre><p>Represents a two-component cemented doublet lens with two respective refractive indices <code>n = n(λ)</code>. See also <a href="../components/lenses/#BeamletOptics.SphericalDoubletLens-NTuple{8, Any}-components-lenses"><code>SphericalDoubletLens</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>front</code>: front <a href="#BeamletOptics.Lens"><code>Lens</code></a> component</li><li><code>back</code>: back <a href="#BeamletOptics.Lens"><code>Lens</code></a> component</li></ul><p><strong>Additional information</strong></p><div class="admonition is-warning"><header class="admonition-header">Air gap</header><div class="admonition-body"><p>This component type strongly assumes that both lenses are mounted fully flush with respect to each other.  Gaps between the components might lead to incorrect results.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/DoubletLenses.jl#L9-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.EvenAsphericalSurface" href="#BeamletOptics.EvenAsphericalSurface"><code>BeamletOptics.EvenAsphericalSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvenAsphericalSurface{T} &lt;: AbstractRotationallySymmetricSurface{T}</code></pre><p>A type representing an aspherical optical surface defined by its radius of curvature, clear (optical) diameter, conic constant, aspheric coefficients and mechanical diameter. This surface is rotationally symmetric about its optical axis.</p><p><strong>Fields</strong></p><ul><li><code>spherical::SphericalSurface{T}</code>: The base spherical surface portion of the asphere.</li><li><code>conic_constant::T</code>: The conic constant defining the deviation from a spherical shape.</li><li><code>coefficients::AbstractVector{T}</code>: A vector of even aspheric coefficients for higher-order corrections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L441-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.EvenAsphericalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, AbstractVector{T4}}, Tuple{T1, T2, T3, AbstractVector{T4}, T5}} where {T1, T2, T3, T4, T5}" href="#BeamletOptics.EvenAsphericalSurface-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3, AbstractVector{T4}}, Tuple{T1, T2, T3, AbstractVector{T4}, T5}} where {T1, T2, T3, T4, T5}"><code>BeamletOptics.EvenAsphericalSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvenAsphericalSurface(radius, diameter, conic_constant, coefficients::AbstractVector, mechanical_diameter = diameter)</code></pre><p>Construct a <code>EvenAsphericalSurface</code> given the radius of curvature, the optical diameter, conic constant, the aspheric coefficients and optionally the mechanical diameter. This constructor automatically sets the mechanical diameter equal to the optical diameter.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: The radius of curvature of the base spherical surface.</li><li><code>diameter</code>: The clear (optical) diameter of the surface.</li><li><code>conic_constant</code>: The conic constant defining the deviation from a spherical shape.</li><li><code>coefficients::AbstractVector</code>: A vector of even aspheric coefficients for higher-order corrections.</li><li><code>mechanical_diameter</code>: The mechanical diameter of the surface; if not provided, it defaults to <code>diameter</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L460-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.GaussianBeamlet" href="#BeamletOptics.GaussianBeamlet"><code>BeamletOptics.GaussianBeamlet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianBeamlet{T} &lt;: AbstractBeam{T, Ray{T}}</code></pre><p>Ray representation of the <strong>stigmatic</strong> Gaussian beam as per J. Arnaud (1985). The beam quality <code>M2</code> is fully considered via the divergence angle. Formalism for beam parameter calculation based on publications:</p><p><strong>Jacques Arnaud, &quot;Representation of Gaussian beams by complex rays,&quot; Appl. Opt. 24, 538-543 (1985)</strong></p><p>and</p><p><strong>Donald DeJager and Mark Noethen, &quot;Gaussian beam parameters that use Coddington-based Y-NU paraprincipal ray tracing,&quot; Appl. Opt. 31, 2199-2205 (1992)</strong></p><p><strong>Fields</strong></p><ul><li><code>chief</code>: a <a href="#BeamletOptics.Beam"><code>Beam</code></a> of <a href="#BeamletOptics.Ray"><code>Ray</code></a>s to store the chief ray</li><li><code>waist</code>: a <a href="#BeamletOptics.Beam"><code>Beam</code></a> of <a href="#BeamletOptics.Ray"><code>Ray</code></a>s to store the waist ray</li><li><code>divergence</code>: a <a href="#BeamletOptics.Beam"><code>Beam</code></a> of <a href="#BeamletOptics.Ray"><code>Ray</code></a>s to store the divergence ray</li><li><code>λ</code>: beam wavelength in [m]</li><li><code>w0</code>: local beam waist radius in [m]</li><li><code>E0</code>: complex field value in [V/m]</li><li><code>parent</code>: reference to the parent beam, if any (<a href="#BeamletOptics.Nullable"><code>Nullable</code></a> to account for the root beam which has no parent)</li><li><code>children</code>: vector of child beams, each child beam represents a branching or bifurcation of the original beam, i.e. beam-splitting</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Beam parameters</header><div class="admonition-body"><p>Parameters of the beam, e.g. <span>$w(z)$</span> or <span>$R(z)$</span>, can be obtained through the <a href="#BeamletOptics.gauss_parameters-Tuple{GaussianBeamlet, Real}"><code>gauss_parameters</code></a> function.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Astigmatism and abberations</header><div class="admonition-body"><p>It is assumed, but not forbidden, that the optical system contains non-symmetric optical elements that cause the beam to obtain astigmatism or higher-order abberations. These can not be represented by the <code>GaussianBeamlet</code>. Refer to <strong>FIXME</strong> for more information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.GaussianBeamlet-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}, Tuple{AbstractArray{P}, AbstractArray{D}, L, Real}} where {P&lt;:Real, D&lt;:Real, L&lt;:Real}" href="#BeamletOptics.GaussianBeamlet-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}, Tuple{AbstractArray{P}, AbstractArray{D}, L, Real}} where {P&lt;:Real, D&lt;:Real, L&lt;:Real}"><code>BeamletOptics.GaussianBeamlet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianBeamlet(position, direction, λ, w0; kwargs...)</code></pre><p>Constructs a Gaussian beamlet at its waist with the specified beam parameters.</p><p><strong>Arguments</strong></p><p>The following inputs and arguments can be used to configure the beamlet:</p><p><strong>Inputs</strong></p><ul><li><code>position</code>: origin of the beamlet</li><li><code>direction</code>: direction of the beamlet</li><li><code>λ</code>: wavelength of the beamlet in [m]. Default value is 1000 nm.</li><li><code>w0</code>: beam waist (radius) in [m]. Default value is 1 mm.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>M2</code>: beam quality factor. Default is 1</li><li><code>P0</code>: beam total power in [W]. Default is 1 mW</li><li><code>z0</code>: beam waist offset in [m]. Default is 0 m</li><li><code>support</code>: <a href="#BeamletOptics.Nullable"><code>Nullable</code></a> support vector for the construction of the waist and div rays</li></ul><p><strong>Additional information</strong></p><div class="admonition is-success"><header class="admonition-header">Waist offset</header><div class="admonition-body"><p>The <code>z0</code> keyword arg. can be used in order to spawn a beam where the waist is not located at the specified <code>position</code>, but rather at an offset <code>z0</code> in [m] along the chief ray axis.</p></div></div><div class="admonition is-info"><header class="admonition-header">Support vector</header><div class="admonition-body"><p>In order to calculate the basis vectors required for the beamlet construction, a random orthogonal vector is chosen. If results fluctuate due to the randomness of this vector, make sure to specify a fixed orthogonal <code>support</code> vector.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L179-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.GaussianBeamletInteraction" href="#BeamletOptics.GaussianBeamletInteraction"><code>BeamletOptics.GaussianBeamletInteraction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianBeamletInteraction &lt;: AbstractInteraction</code></pre><p>This type is used to store the new beamlet section resulting from on optical interaction between a <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> and some <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>. Uses the hint of the <code>chief</code> beam.</p><p><strong>Fields</strong></p><ul><li><code>chief</code>: <a href="#BeamletOptics.Beam"><code>Beam</code></a> interaction</li><li><code>waist</code>: <a href="#BeamletOptics.Beam"><code>Beam</code></a> interaction</li><li><code>divergence</code>: <a href="#BeamletOptics.Beam"><code>Beam</code></a> interaction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L62-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Hint" href="#BeamletOptics.Hint"><code>BeamletOptics.Hint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hint</code></pre><p>A <code>Hint</code> can be passed as part of an <a href="#BeamletOptics.AbstractInteraction"><code>AbstractInteraction</code></a> and will inform the tracing algorithm about which <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> in the <a href="#BeamletOptics.AbstractSystem"><code>AbstractSystem</code></a> will be hit next.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The hint does not need to result in a guaranteed <a href="#BeamletOptics.Intersection"><code>Intersection</code></a>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>object</code>: the object that might or will be intersected as next</li><li><code>shape</code>: the underlying shape that will be intersected next, i.e. <code>shape(object)</code>, relevant for multi-shape objects</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractSystem.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.IntersectableObject" href="#BeamletOptics.IntersectableObject"><code>BeamletOptics.IntersectableObject</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntersectableObject</code></pre><p>A passive <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> which can be hit by a beam. In this case, the object acts like a hard target and blocks the beam path.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: an <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Intersectable.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Intersection" href="#BeamletOptics.Intersection"><code>BeamletOptics.Intersection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Intersection{T}</code></pre><p>Stores data calculated by the <a href="#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractObject, BeamletOptics.AbstractRay}"><code>intersect3d</code></a> method. This information can be reused, i.e. for retracing.</p><p><strong>Fields:</strong></p><ul><li><code>object</code>: a <a href="#BeamletOptics.Nullable"><code>Nullable</code></a> reference to the <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> that has been hit (optional but recommended)</li><li><code>shape</code>: a <a href="#BeamletOptics.Nullable"><code>Nullable</code></a> reference to the <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> of the <code>object</code> that has been hit (optional but recommended)</li><li><code>t</code>: length of the ray parametrization in [m]</li><li><code>n</code>: normal vector at the point of intersection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Lens" href="#BeamletOptics.Lens"><code>BeamletOptics.Lens</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lens{T, S &lt;: AbstractShape{T}, N &lt;: RefractiveIndex} &lt;: AbstractRefractiveOptic{T, S, N}</code></pre><p>Represents an uncoated <code>Lens</code> with a homogeneous <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> <code>n = n(λ)</code>. Refer to the <a href="#BeamletOptics.Lens"><code>Lens</code></a> and <a href="../components/lenses/#BeamletOptics.SphericalLens-components-lenses"><code>SphericalLens</code></a> constructors for more information on how to generate lenses.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: geometry of the lens, refer to <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> for more information</li><li><code>n</code>: <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> function that returns n(λ)</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Refractive index</header><div class="admonition-body"><p>The chromatic dispersion of the lens is represented by a λ-dependent function for <code>n</code> and must be provided by the user. For testing purposes, an anonymous function, e.g. λ -&gt; 1.5 can be passed such that the lens has the same refractive index for all wavelengths.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L128-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Lens-Tuple{BeamletOptics.AbstractCylindricalSurface, BeamletOptics.AbstractCylindricalSurface, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.Lens-Tuple{BeamletOptics.AbstractCylindricalSurface, BeamletOptics.AbstractCylindricalSurface, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.Lens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Lens(front_surface::AbstractCylindricalSurface, back_surface::AbstractCylindricalSurface, center_thickness::Real, n::RefractiveIndex)</code></pre><p>Constructs a new <a href="#BeamletOptics.Lens"><code>Lens</code></a> object using the cylindric surface specifications <code>front_surface</code> and <code>back_surface</code> and the <code>center_thickness</code>. These inputs are used to construct a <a href="#BeamletOptics.UnionSDF"><code>UnionSDF</code></a> that consists of the appropriate sub-SDFs to represent the shape of the lens.</p><p>This method of <code>Lens</code> is specific for cylindric lenses and has some limitations:     - The cylinder height of both surfaces has to be identical     - No mixture with non-cylindric surfaces is supported at the moment</p><p>The material properties are supplied via the <code>n</code> parameter.</p><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Radius of curvature (ROC) sign definition</header><div class="admonition-body"><p>The ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L266-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Lens-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractRotationallySymmetricSurface, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.Lens-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractRotationallySymmetricSurface, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.Lens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Lens(front_surface::AbstractRotationallySymmetricSurface, back_surface::AbstractRotationallySymmetricSurface, center_thickness::Real, n::RefractiveIndex)</code></pre><p>Constructs a new <a href="#BeamletOptics.Lens"><code>Lens</code></a> object using the surface specifications <code>front_surface</code> and <code>back_surface</code> and the <code>center_thickness</code>. These inputs are used to construct a <a href="#BeamletOptics.UnionSDF"><code>UnionSDF</code></a> that consists of the appropriate sub-SDFs to represent the shape of the lens.</p><p>The material properties are supplied via the <code>n</code> parameter.</p><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Radius of curvature (ROC) sign definition</header><div class="admonition-body"><p>The ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Meniscus</header><div class="admonition-body"><p>If your specification results in a meniscus lens, only spherical meniscus lenses are supported at the moment.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L159-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.MeniscusLensSDF" href="#BeamletOptics.MeniscusLensSDF"><code>BeamletOptics.MeniscusLensSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeniscusLensSDF</code></pre><p><a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>-based representation of a positive or negative meniscus lens. When constructed, it is assumed that the lens lies at the origin and the optical axis is aligned with the <code>y</code>-axis. Parameters that lead to a sharp lens edge will cause an error.</p><p><strong>Notes</strong></p><div class="admonition is-info"><header class="admonition-header">Radius of curvature sign convention</header><div class="admonition-body"><p>The ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.</p></div></div><p><strong>Fields:</strong></p><ul><li><code>convex</code>: the convex part of the lens composite SDF</li><li><code>cylinder</code>: the cylindrical part of the lens composite SDF</li><li><code>concave</code>: the concave part of the lens composite SDF</li><li><code>thickness</code>: lens thickness on the optical axis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/MeniscusLensSDF.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.MeniscusLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R2}, Tuple{R1}, Tuple{R1, R2, L, D, MD}} where {R1, R2, L, D, MD}" href="#BeamletOptics.MeniscusLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R2}, Tuple{R1}, Tuple{R1, R2, L, D, MD}} where {R1, R2, L, D, MD}"><code>BeamletOptics.MeniscusLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeniscusLensSDF(r1::R1, r2::R2, l::L, d::D, md::MD)</code></pre><p>Constructs a positive or negative <a href="#BeamletOptics.MeniscusLensSDF"><code>MeniscusLensSDF</code></a> with:</p><ul><li><code>r1</code>: front surface radis or curvature</li><li><code>r2</code>: back surface radis or curvature</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default value is one inch</li><li><code>md</code>: mechanical lens diameter, must be &gt; d</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/MeniscusLensSDF.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Mesh" href="#BeamletOptics.Mesh"><code>BeamletOptics.Mesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mesh &lt;: AbstractMesh</code></pre><p>Contains the STL mesh information for an arbitrary shape, that is the <code>vertices</code> that make up the mesh and a matrix of <code>faces</code>, i.e. the connectivity matrix of the mesh. The data is read in using the <code>FileIO.jl</code> and <code>MeshIO.jl</code> packages. Translations and rotations of the mesh are directly saved in absolute coordinates in the vertex matrix. For orientation and translation tracking, a <code>pos</code>itional and <code>dir</code>ectional matrix are stored.</p><p><strong>Fields</strong></p><ul><li><code>vertices</code>: (m x 3)-matrix that stores the edge points of all triangles</li><li><code>faces</code>: (n x 3)-matrix that stores the connectivity data for all faces</li><li><code>dir</code>: (3 x 3)-matrix that represents the current orientation of the mesh</li><li><code>pos</code>: 3-element vector that is used as the mesh location reference</li><li><code>scale</code>: scalar value that represents the current scale of the original mesh</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L17-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Mesh-Tuple{Any}" href="#BeamletOptics.Mesh-Tuple{Any}"><code>BeamletOptics.Mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mesh(mesh)</code></pre><p>Parametric type constructor for struct Mesh. Takes data of type <code>GeometryBasics.Mesh</code> and extracts the vertices and faces. The mesh is initialized at the global origin. Data type of Mesh is variably selected based on type of vertex data (i.e <code>Float32</code>). Mesh data is scaled by factor 1e-3, assuming m scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Mirror" href="#BeamletOptics.Mirror"><code>BeamletOptics.Mirror</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mirror{S &lt;: AbstractShape} &lt;: AbstractReflectiveOptic</code></pre><p>Concrete implementation of a perfect mirror (R = 1) with arbitrary shape.</p><div class="admonition is-warning"><header class="admonition-header">Reflecting surfaces</header><div class="admonition-body"><p>It is important to consider that <strong>all</strong> surfaces of this mirror type are reflecting!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.MultiShape" href="#BeamletOptics.MultiShape"><code>BeamletOptics.MultiShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiShape &lt;: AbstractShapeTrait</code></pre><p>Represents that the <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> consists of a two or more <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a>s.</p><p><strong>AbstractObject implementation reqs.</strong></p><p>If <code>shape_trait_of(::Foo) = MultiShape()</code> is defined, <code>Foo</code> must implement the following: </p><p><strong>Functions</strong></p><ul><li><code>shape(::Foo)</code>: a getter function that returns a <code>Tuple</code> of all relevant shapes, e.g. <code>(foo.front, foo.middle, foo.back)</code></li></ul><p><strong>Additional information</strong></p><div class="admonition is-category-warn"><header class="admonition-header">Kinematic center</header><div class="admonition-body"><p>Unless specified otherwise by dispatching <code>position</code> / <code>position!</code> and <code>orientation</code> / <code>orientation!</code> onto custom <code>pos</code> and <code>dir</code> data fields, the <strong>position and orientation of the first element</strong> returned by <code>shape(object)</code> will be used as the <strong>kinematic center</strong> for e.g. <code>translate3d!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L53-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.NonInteractableObject" href="#BeamletOptics.NonInteractableObject"><code>BeamletOptics.NonInteractableObject</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonInteractableObject</code></pre><p>A passive <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> which does not interact with the ray tracing simulation but can be moved via the kinematic API.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: an <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Usage</header><div class="admonition-body"><p>This type is intended mainly for visualization purposes, e.g. kinematic mount <a href="#BeamletOptics.Mesh"><code>Mesh</code></a>s, or similar applications. In essence, this object behaves fully transparent. The <code>intersect3d</code> and <code>interact3d</code> methods default to <code>nothing</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/NonInteractable.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ObjectGroup" href="#BeamletOptics.ObjectGroup"><code>BeamletOptics.ObjectGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ObjectGroup &lt;: AbstractObjectGroup</code></pre><p>A tree-like storage container for groups of objects. Can store individual objects and subgroups. Main purpose is handling of, i.e., groups of lenses.</p><p><strong>Fields</strong></p><ul><li><code>center</code>: a point in 3D space which is regarded as the reference origin of the group</li><li><code>dir</code>: a 3x3 matrix that describes the common <code>orientation</code> of the group</li><li><code>objects</code>: stores <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>, can also store subgroups of type <a href="#BeamletOptics.AbstractObjectGroup"><code>AbstractObjectGroup</code></a></li></ul><p><strong>Kinematic</strong></p><p>A <code>ObjectGroup</code> implements the kinematic functions of <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>. The following logic is applied to</p><ul><li><a href="#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>translate3d!</code></a>: all objects in the group are translated by the offset vector</li><li><a href="#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.AbstractShape, Any}"><code>translate_to3d!</code></a>: all objects are moved in parallel such that the group <code>center</code> is equal to the target position</li><li><a href="#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractMesh, Any, Any}"><code>rotate3d!</code></a>: all objects are rotated around the <code>center</code> point with respect to their relative position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Groups.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Photodetector" href="#BeamletOptics.Photodetector"><code>BeamletOptics.Photodetector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Photodetector{T, S &lt;: AbstractShape{T}} &lt;: AbstractDetector{T, S}</code></pre><p>Represents a <strong>flat</strong> rectangular or quadratic surface in R³ that is the active surface of a photodetector. The active surface is discretized in the local R² x-y-coordinate system. Field contributions Eᵢ are added by the corresponding <a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a> method.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: geometry of the active surface, must represent 2D-<code>field</code> in <code>x</code> any <code>y</code> dimensions</li><li><code>x</code>: linear range of local x-coordinates</li><li><code>y</code>: linear range of local y-coordinates</li><li><code>field</code>: <code>size(x)</code> by <code>size(y)</code> matrix of complex values to store superposition E₀</li></ul><p><strong>Additional information</strong></p><div class="admonition is-warning"><header class="admonition-header">Reset behavior</header><div class="admonition-body"><p>The <code>Photodetector</code> must be reset between each call of <a href="../basics/systems/#BeamletOptics.solve_system!-basics-systems"><code>solve_system!</code></a> in order to overwrite previous results using the <a href="#BeamletOptics.reset_detector!-Tuple{D} where D&lt;:BeamletOptics.AbstractDetector"><code>reset_detector!</code></a> function. Otherwise, the current result will be added onto the previous result.</p></div></div><div class="admonition is-info"><header class="admonition-header">Supported beams</header><div class="admonition-body"><p>Currently, only the <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> is supported.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Photodetector-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real" href="#BeamletOptics.Photodetector-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>BeamletOptics.Photodetector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Photodetector(width, n)</code></pre><p>Spawns a quadratic rectangular 2D <a href="#BeamletOptics.Photodetector"><code>Photodetector</code></a> that is aligned with the <strong>positive y-axis</strong>. Refer to the type docs for more information.</p><p><strong>Inputs:</strong></p><ul><li><code>width</code>: edge length in [m]</li><li><code>n</code>: field discretization factor, higher results in more computational cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PlanoSurfaceSDF" href="#BeamletOptics.PlanoSurfaceSDF"><code>BeamletOptics.PlanoSurfaceSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanoSurfaceSDF</code></pre><p><a href="#BeamletOptics.AbstractSDF"><code>AbstractSDF</code></a>-based representation of two flat optical surfaces, i.e. equivalent to the <a href="#BeamletOptics.CylinderSDF"><code>CylinderSDF</code></a>. When constructed, it is assumed that the first flat surface lies at the origin and the optical axis is aligned with the positive <code>y</code>-axis.</p><p><strong>Fields:</strong></p><ul><li><code>diameter</code>: the outer diameter of the circular flat lens surface</li><li><code>thickness</code>: the distance between the flat surfaces</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PolarizedRay" href="#BeamletOptics.PolarizedRay"><code>BeamletOptics.PolarizedRay</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarizedRay{T} &lt;: AbstractRay{T}</code></pre><p>A ray type to model the propagation of an electric field vector based on the publication:</p><p><strong>Yun, Garam, Karlton Crabtree, and Russell A. Chipman. &quot;Three-dimensional polarization ray-tracing calculus I: definition and diattenuation.&quot; Applied optics 50.18 (2011): 2855-2865.</strong></p><p>The geometrical ray description is identical to the standard <a href="#BeamletOptics.Ray"><code>Ray</code></a>. The polarization interaction can be described in local s-p-coordinates but must be transformed into global coordinates using the method described in the publication above, see also <a href="#BeamletOptics._calculate_global_E0-NTuple{4, AbstractArray}"><code>_calculate_global_E0</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>pos</code>: a point in R³ that describes the <code>Ray</code> origin</li><li><code>dir</code>: a normalized vector in R³ that describes the <code>Ray</code> direction</li><li><code>intersection</code>: refer to <a href="#BeamletOptics.Intersection"><code>Intersection</code></a></li><li><code>λ</code>: wavelength in [m]</li><li><code>n</code>: refractive index along the beam path</li><li><code>E0</code>: complex-valued 3-tuple to represent the electric field in global coordinates</li></ul><p><strong>Jones matrices</strong></p><p>In local coordinates the Jones matrices in the case of reflection/refraction are defined as</p><ul><li>reflection: [-rₛ 0; 0 rₚ]</li><li>transmission: [tₛ 0; 0 tₚ]</li></ul><p>where r and t are the complex-valued Fresnel coefficients (see also <a href="#BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T"><code>fresnel_coefficients</code></a>).</p><p><strong>Additional information</strong></p><div class="admonition is-warning"><header class="admonition-header">Field vector</header><div class="admonition-body"><p>It is assumed that the electric field vector <span>$E_0$</span> stays orthogonal to the direction of propagation throughout the optical system.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Intensity</header><div class="admonition-body"><p>E0 can not be converted into an <a href="#BeamletOptics.intensity"><code>intensity</code></a> value, since a single <code>PolarizedRay</code> can not directly model the change in intensity during imaging by an optical system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/PolarizedRays.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PolarizedRay-Union{Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, Any}, Tuple{AbstractArray{P}, AbstractArray{D}, Any, Any}} where {P&lt;:Real, D&lt;:Real}" href="#BeamletOptics.PolarizedRay-Union{Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, Any}, Tuple{AbstractArray{P}, AbstractArray{D}, Any, Any}} where {P&lt;:Real, D&lt;:Real}"><code>BeamletOptics.PolarizedRay</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarizedRay(pos, dir, λ = 1000e-9, E0 = [1, 0, 0])</code></pre><p>1 V/m in x-dir.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/PolarizedRays.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Prism" href="#BeamletOptics.Prism"><code>BeamletOptics.Prism</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prism{T, S &lt;: AbstractShape{T}, N &lt;: RefractiveIndex} &lt;: AbstractRefractiveOptic{T, S, N}</code></pre><p>Essentially represents the same functionality as <a href="#BeamletOptics.Lens"><code>Lens</code></a>. Refer to its documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Prisms.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Ray" href="#BeamletOptics.Ray"><code>BeamletOptics.Ray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ray{T} &lt;: AbstractRay{T}</code></pre><p>Mutable struct to store ray information.</p><p><strong>Fields</strong></p><ul><li><code>pos</code>: a point in R³ that describes the <code>Ray</code> origin</li><li><code>dir</code>: a normalized vector in R³ that describes the <code>Ray</code> direction</li><li><code>intersection</code>: refer to <a href="#BeamletOptics.Intersection"><code>Intersection</code></a></li><li><code>λ</code>: wavelength in [m]</li><li><code>n</code>: refractive index along the beam path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Rays.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Ray-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}} where {P&lt;:Real, D&lt;:Real, L&lt;:Real}" href="#BeamletOptics.Ray-Union{Tuple{L}, Tuple{D}, Tuple{P}, Tuple{AbstractArray{P}, AbstractArray{D}}, Tuple{AbstractArray{P}, AbstractArray{D}, L}} where {P&lt;:Real, D&lt;:Real, L&lt;:Real}"><code>BeamletOptics.Ray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ray(pos, dir, λ=1000e-9)</code></pre><p>Constructs a <code>Ray</code> where:</p><ul><li><code>pos</code>: is the <code>Ray</code> origin</li><li><code>dir</code>: is the <code>Ray</code> direction of propagation, normalized to unit length</li></ul><p>Optionally, a wavelength <code>λ</code> can be specified. The start refractive index is assumed to be in vacuum (n = 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Rays.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularFlatSurface" href="#BeamletOptics.RectangularFlatSurface"><code>BeamletOptics.RectangularFlatSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularFlatSurface{T} &lt;: AbstracCylindricalSurface{T}</code></pre><p>A type representing a planar rectangular surface, which is only parametrized by its <code>size</code>.</p><p><strong>Fields</strong></p><ul><li><code>size::T</code>: The size of the planar surface</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L214-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularPlateBeamsplitter" href="#BeamletOptics.RectangularPlateBeamsplitter"><code>BeamletOptics.RectangularPlateBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularPlateBeamsplitter &lt;: AbstractPlateBeamsplitter</code></pre><p>A plate beamsplitter with rectangular substrate and a single coated face. For more information refer to the <a href="#BeamletOptics.AbstractPlateBeamsplitter"><code>AbstractPlateBeamsplitter</code></a> docs.</p><p><strong>Fields</strong></p><ul><li><code>substrate</code>: a rectangular <a href="#BeamletOptics.Prism"><code>Prism</code></a> that acts as the substrate</li><li><code>coating</code>: a <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> that acts as the coating</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Kinematic center</header><div class="admonition-body"><p>The center of kinematics of this splitter lies at the center of the coating.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularPlateBeamsplitter-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.RectangularPlateBeamsplitter-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.RectangularPlateBeamsplitter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularPlateBeamsplitter(width, height, thickness, n; reflectance=0.5)</code></pre><p>Creates a <a href="#BeamletOptics.RectangularPlateBeamsplitter"><code>RectangularPlateBeamsplitter</code></a>. The splitter is aligned with the negative y-axis. The splitter coating is centered at the origin. See also <a href="#BeamletOptics.RoundPlateBeamsplitter"><code>RoundPlateBeamsplitter</code></a>.</p><p><strong>Inputs</strong></p><ul><li><code>width</code>: substrate width along the x-axis in [m]</li><li><code>height</code>: substrate height along the z-axis in [m]</li><li><code>thickness</code>: substrate thickness along the y-axis in [m]</li><li><code>n</code>: the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the substrate</li></ul><p><strong>Keywords</strong></p><ul><li><code>reflectance</code>: defines the splitting ratio in [-], i.e. R = 0 ... 1.0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L72-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularPlateBeamsplitterShape" href="#BeamletOptics.RectangularPlateBeamsplitterShape"><code>BeamletOptics.RectangularPlateBeamsplitterShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Placeholder type for the  shape of a <a href="#BeamletOptics.RectangularPlateBeamsplitter"><code>RectangularPlateBeamsplitter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Retroreflector" href="#BeamletOptics.Retroreflector"><code>BeamletOptics.Retroreflector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Retroreflector</code></pre><p>A <code>Retroreflector</code> reflects incoming rays back toward their source, independent of the incident angle. The shape is represented by a tetrahedral <a href="#BeamletOptics.Mesh"><code>Mesh</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>mesh</code>: shape of the <code>Retroreflector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Misc.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Retroreflector-Tuple{Real}" href="#BeamletOptics.Retroreflector-Tuple{Real}"><code>BeamletOptics.Retroreflector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Retroreflector(scale)</code></pre><p>Spawns a <a href="#BeamletOptics.Retroreflector"><code>Retroreflector</code></a>.</p><p><strong>Inputs</strong></p><ul><li><code>scale</code>: a scaling factor for the size of the retroreflector, e.g. <code>1e-3</code> for 1 mm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Misc.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RightAnglePrismMirror" href="#BeamletOptics.RightAnglePrismMirror"><code>BeamletOptics.RightAnglePrismMirror</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightAnglePrismMirror &lt;: AbstractReflectiveOptic</code></pre><p>An ideal right angle prism mirror with planar reflecting surface, i.e. R = 1. See also <a href="#BeamletOptics.Mirror"><code>Mirror</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: a <a href="#BeamletOptics.RightAnglePrismSDF"><code>RightAnglePrismSDF</code></a> that represents the substrate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RightAnglePrismMirror-Tuple{Real, Real}" href="#BeamletOptics.RightAnglePrismMirror-Tuple{Real, Real}"><code>BeamletOptics.RightAnglePrismMirror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightAnglePrismMirror(leg_length, height)</code></pre><p>Constructs a right angle prism mirror. The primary surface is aligned with the pos. y-axis.</p><p><strong>Inputs</strong></p><ul><li><code>leg_length</code>: edge length in x and y in [m] </li><li><code>height</code>: in z-axis in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L216-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RightAnglePrismSDF" href="#BeamletOptics.RightAnglePrismSDF"><code>BeamletOptics.RightAnglePrismSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightAnglePrismSDF &lt;: AbstractSDF</code></pre><p>Implements the <code>SDF</code> of a right angle prism with symmetric leg length <code>l</code> and height <code>h</code>. Note that these values are stored in the <code>dimensions</code> field as:</p><p>dimensions::Point3 = (     leg<em>length,     # dim in x     leg</em>length,     # dim in y     height,         # dim in z )</p><div class="admonition is-info"><header class="admonition-header">Alignment</header><div class="admonition-body"><p>Note that the prism is not aligned with the positive y-axis!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RightAnglePrismSDF-Union{Tuple{H}, Tuple{L}, Tuple{L, H}} where {L, H}" href="#BeamletOptics.RightAnglePrismSDF-Union{Tuple{H}, Tuple{L}, Tuple{L, H}} where {L, H}"><code>BeamletOptics.RightAnglePrismSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightAnglePrismSDF(leg_length, height)</code></pre><p>Constructs a symmetric right angle prism with <code>leg_length</code> in x and y and <code>height</code> z in [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RingSDF" href="#BeamletOptics.RingSDF"><code>BeamletOptics.RingSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RingSDF &lt;: AbstractSDF</code></pre><p>Implements the SDF of a ring in the x-z-plane for some distance in the y axis. This allows to add planar outer sections to any SDF which fits inside of the ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RingSDF-Union{Tuple{T}, Tuple{W}, Tuple{R}, Tuple{R, W, T}} where {R, W, T}" href="#BeamletOptics.RingSDF-Union{Tuple{T}, Tuple{W}, Tuple{R}, Tuple{R, W, T}} where {R, W, T}"><code>BeamletOptics.RingSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RingSDF(inner_radius, width, thickness)</code></pre><p>Constructs a ring with <code>inner_radius</code> with a <code>width</code> and some thickness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/PrimitiveSDF.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundPlanoMirror" href="#BeamletOptics.RoundPlanoMirror"><code>BeamletOptics.RoundPlanoMirror</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RoundPlanoMirror &lt;: AbstractReflectiveOptic</code></pre><p>An ideal cylindrical mirror with planar reflecting surface, e.g. R = 1. See also <a href="#BeamletOptics.Mirror"><code>Mirror</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: a <a href="#BeamletOptics.PlanoSurfaceSDF"><code>PlanoSurfaceSDF</code></a> that represents the substrate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundPlanoMirror-Union{Tuple{T}, Tuple{D}, Tuple{D, T}} where {D&lt;:Real, T&lt;:Real}" href="#BeamletOptics.RoundPlanoMirror-Union{Tuple{T}, Tuple{D}, Tuple{D, T}} where {D&lt;:Real, T&lt;:Real}"><code>BeamletOptics.RoundPlanoMirror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RoundPlanoMirror(diameter, thickness)</code></pre><p>Returns a cylindrical, flat <a href="#BeamletOptics.RoundPlanoMirror"><code>RoundPlanoMirror</code></a> with perfect reflectivity based on:</p><p><strong>Inputs</strong></p><ul><li><code>diameter</code>: mirror diameter in [m]</li><li><code>thickness</code>: mirror substrate thickness in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L151-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundPlateBeamsplitter" href="#BeamletOptics.RoundPlateBeamsplitter"><code>BeamletOptics.RoundPlateBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RoundPlateBeamsplitter &lt;: AbstractPlateBeamsplitter</code></pre><p>A plate beamsplitter with cylindrical substrate and a single coated face. For more information refer to the <a href="#BeamletOptics.AbstractPlateBeamsplitter"><code>AbstractPlateBeamsplitter</code></a> docs.</p><p><strong>Fields</strong></p><ul><li><code>substrate</code>: a cylindrical <a href="#BeamletOptics.Prism"><code>Prism</code></a> that acts as the substrate</li><li><code>coating</code>: a <a href="#BeamletOptics.RoundThinBeamsplitter-Tuple{Real}"><code>RoundThinBeamsplitter</code></a> that acts as the coating</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Kinematic center</header><div class="admonition-body"><p>The center of kinematics of this splitter lies at the center of the coating.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L109-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundPlateBeamsplitter-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.RoundPlateBeamsplitter-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.RoundPlateBeamsplitter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RoundPlateBeamsplitter(diameter, thickness, n; reflectance=0.5)</code></pre><p>Creates a <a href="#BeamletOptics.RoundPlateBeamsplitter"><code>RoundPlateBeamsplitter</code></a>. The splitter is aligned with the negative y-axis. The coating is centered at the origin. See also <a href="#BeamletOptics.RectangularPlateBeamsplitter"><code>RectangularPlateBeamsplitter</code></a>.</p><p><strong>Inputs</strong></p><ul><li><code>diameter</code>: x-z-plane substrate diameter in [m]</li><li><code>thickness</code>: substrate thickness along the z-axis in [m]</li><li><code>n</code>: the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the substrate</li></ul><p><strong>Keywords</strong></p><ul><li><code>reflectance</code>: defines the splitting ratio in [-], i.e. R = 0 ... 1.0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundPlateBeamsplitterShape" href="#BeamletOptics.RoundPlateBeamsplitterShape"><code>BeamletOptics.RoundPlateBeamsplitterShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Placeholder type for the  shape of a <a href="#BeamletOptics.RoundPlateBeamsplitterShape"><code>RoundPlateBeamsplitterShape</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/PlateBeamsplitter.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SingleShape" href="#BeamletOptics.SingleShape"><code>BeamletOptics.SingleShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleShape &lt;: AbstractShapeTrait</code></pre><p>Represents that the <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> consists of a single underlying shape.</p><p><strong>AbstractObject implementation reqs.</strong></p><p>If <code>shape_trait_of(::Foo) = SingleShape()</code> is defined, <code>Foo</code> must implement the following: </p><p><strong>Fields</strong></p><ul><li><code>shape</code>: a single concrete <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a>, e.g. a <a href="#BeamletOptics.CylinderSDF"><code>CylinderSDF</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L18-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SphereSDF" href="#BeamletOptics.SphereSDF"><code>BeamletOptics.SphereSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphereSDF</code></pre><p>Implements the SDF of a perfect sphere. Orientation is fixed to unity matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SphericalSurface" href="#BeamletOptics.SphericalSurface"><code>BeamletOptics.SphericalSurface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalSurface{T} &lt;: AbstractRotationallySymmetricSurface{T}</code></pre><p>A type representing a spherical optical surface defined by its radius of curvature, clear (optical) diameter, and mechanical diameter. This surface is rotationally symmetric about its optical axis.</p><p><strong>Fields</strong></p><ul><li><code>radius::T</code>: The radius of curvature of the spherical surface. A positive value indicates that the center of curvature lies to the right of the vertex (following ISO 10110).</li><li><code>diameter::T</code>: The clear (optical) aperture of the surface.</li><li><code>mechanical_diameter::T</code>: The overall mechanical diameter of the surface. In many cases, this is equal to the optical diameter, but it can be set independently if the mechanical mount requires a larger dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SphericalSurface-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R&lt;:Real, D&lt;:Real}" href="#BeamletOptics.SphericalSurface-Union{Tuple{D}, Tuple{R}, Tuple{R, D}} where {R&lt;:Real, D&lt;:Real}"><code>BeamletOptics.SphericalSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalSurface(radius, diameter)</code></pre><p>Construct a <code>SphericalSurface</code> given the radius of curvature and the optical diameter. This constructor automatically sets the mechanical diameter equal to the optical diameter.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: The radius of curvature of the surface.</li><li><code>diameter</code>: The clear (optical) diameter of the surface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L450-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Spotdetector" href="#BeamletOptics.Spotdetector"><code>BeamletOptics.Spotdetector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spotdetector &lt;: AbstractDetector</code></pre><p>Simple 2D screen that stores the intersection point of incoming <a href="#BeamletOptics.Beam"><code>Beam</code></a>s. The intersection points are stored in local coordinates of the detector with respect to the screen origin.</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: a 2D <a href="#BeamletOptics.QuadraticFlatMesh-Tuple{Real}"><code>QuadraticFlatMesh</code></a> that is <strong>aligned with the negative y-axis</strong></li><li><code>data</code>: stores the intersection points as <code>Point2</code></li><li><code>hw</code>: half-width of the detector plane</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Normal vector</header><div class="admonition-body"><p>Check the normal vector orientation of the detector plane if the spot diagram looks mirrored.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Reset behavior</header><div class="admonition-body"><p>Spot diagram data must be manually reset between traces via <a href="#BeamletOptics.reset_detector!-Tuple{D} where D&lt;:BeamletOptics.AbstractDetector"><code>reset_detector!</code></a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Spotdetector.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.Spotdetector-Tuple{W} where W&lt;:AbstractFloat" href="#BeamletOptics.Spotdetector-Tuple{W} where W&lt;:AbstractFloat"><code>BeamletOptics.Spotdetector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Spotdetector(width)</code></pre><p>Generates a quadratic rectangular 2D <a href="#BeamletOptics.Spotdetector"><code>Spotdetector</code></a> that is aligned with the <strong>negative y-axis</strong>. Refer to the type docs for more information.</p><p><strong>Inputs:</strong></p><ul><li><code>width</code>: edge length in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Spotdetector.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.StaticSystem" href="#BeamletOptics.StaticSystem"><code>BeamletOptics.StaticSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticSystem &lt;: AbstractSystem</code></pre><p>A static container storing the optical elements of, i.e. a camera lens or lab setup. Compared to <code>System</code> this way defining the system is less flexible, i.e. no elements can be added or removed after construction but it allows for more performant ray-tracing.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This type uses long tuples for storing the elements. This container should not be used for very large optical systems as it puts a lot of stress onto the compiler.</p></div></div><p><strong>Fields</strong></p><ul><li><code>objects</code>: vector containing the different objects that are part of the system (subtypes of <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.System" href="#BeamletOptics.System"><code>BeamletOptics.System</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">System &lt;: AbstractSystem</code></pre><p>A container storing the optical elements of, i.e. a camera lens or lab setup.</p><p><strong>Fields</strong></p><ul><li><code>objects</code>: vector containing the different objects that are part of the system (subtypes of <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ThinBeamsplitter" href="#BeamletOptics.ThinBeamsplitter"><code>BeamletOptics.ThinBeamsplitter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinBeamsplitter &lt;: AbstractBeamsplitter</code></pre><p>Represents a 2D beam-splitting device. </p><p><strong>Fields</strong></p><ul><li><code>shape</code>: 2D <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> at which the splitting process occurs (e.g. a 2D-<a href="#BeamletOptics.Mesh"><code>Mesh</code></a>)</li><li><code>reflectance</code>: scalar reflection factor</li><li><code>transmittance</code>: scalar transmission factor</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that the <code>transmittance</code> should be calculated from an input <code>reflectance</code> in order to ensure that R² + T² = 1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/ThinBeamsplitter.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ThinBeamsplitter-Tuple{Real, Real}" href="#BeamletOptics.ThinBeamsplitter-Tuple{Real, Real}"><code>BeamletOptics.ThinBeamsplitter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinBeamsplitter(width, height; reflectance=0.5)</code></pre><p>Creates a zero-thickness, lossless, non-polarizing 2D rectangular <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> where</p><ul><li><code>width</code>: is the x-dir. edge length in [m]</li><li><code>height</code>: is the z-dir. edge length in [m]</li><li><code>reflectance</code>: kw-arg that determines how much light is <strong>reflected</strong>, i.e. 0.7 for a 70:30 splitter</li></ul><p><strong>Additional information</strong></p><div class="admonition is-info"><header class="admonition-header">Reflectance</header><div class="admonition-body"><p>The input value for the <code>reflectance</code> R is normed such that R² + T² = 1, where T is the <code>transmittance</code>. The transmittance is calculated via T = √(1 - R²).</p></div></div><div class="admonition is-warning"><header class="admonition-header">Reflection phase jump</header><div class="admonition-body"><p>Note that the reflection phase jump θᵣ is implemented by the individual <a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a>-methods. Refer to them for more information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/ThinBeamsplitter.jl#L25-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.UnionSDF" href="#BeamletOptics.UnionSDF"><code>BeamletOptics.UnionSDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnionSDF{T, TT &lt;: Tuple} &lt;: AbstractSDF{T}</code></pre><p>This SDF represents the merging of two or more SDFs. If the constituent SDFs do not overlap (they can and should touch) the resulting SDF should be still exact if the constituent SDFs are exact.</p><p>The intended way to construct these is not explicitely but by just adding two <code>AbstractSDFs</code> using the regular <code>+</code> operator.</p><pre><code class="language- hljs">s1 = SphereSDF(1.0)
translate3d!(s1, Point3(0, 1.0, 0.0))

s2 = SphereSDF(1.0)

# will result in a SDF with two spheres touching each other.
s_merged = s1 + s2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/UnionSDF.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T" href="#Base.length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.length(ray::AbstractRay)</code></pre><p>Returns the geometric length of a <code>ray</code> between its start and intersection point. If no intersection exists, <code>Inf</code> is returned.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"></div></div><p>Use <code>optical_path_length(ray)</code> to get the optical path length instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L188-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Union{Tuple{Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T" href="#Base.length-Union{Tuple{Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.length(beam::Beam)</code></pre><p>Calculate the length of a beam up to the point of the last intersection.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"></div></div><p>Use <code>optical_path_length(bream)</code> to get the optical path length instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.BiConcaveLensSDF-Union{Tuple{MD}, Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N, O, MD}} where {L, M, N, O, MD}" href="#BeamletOptics.BiConcaveLensSDF-Union{Tuple{MD}, Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N, O, MD}} where {L, M, N, O, MD}"><code>BeamletOptics.BiConcaveLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiConcaveLensSDF(r1, r2, l, d=1inch)</code></pre><p>Constructs a bi-concave lens SDF with:</p><ul><li><code>r1</code> &gt; 0: radius of concave front</li><li><code>r2</code> &gt; 0: radius of convex back</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default value is one inch</li><li><code>md</code>: mechanical lens diameter, adds an outer ring section to the lens, if <code>md</code> &gt; <code>d</code>.</li></ul><p>The spherical surfaces are constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L302-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.BiConvexLensSDF-Union{Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N}, Tuple{L, M, N, O}} where {L, M, N, O}" href="#BeamletOptics.BiConvexLensSDF-Union{Tuple{O}, Tuple{N}, Tuple{M}, Tuple{L}, Tuple{L, M, N}, Tuple{L, M, N, O}} where {L, M, N, O}"><code>BeamletOptics.BiConvexLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiConvexLensSDF(r1, r2, l, d=1inch)</code></pre><p>Constructs a cylindrical bi-convex lens SDF with:</p><ul><li><code>r1</code> &gt; 0: radius of convex front</li><li><code>r2</code> &gt; 0: radius of convex back</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default value is one inch</li></ul><p>The spherical surfaces are constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L255-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CircularFlatMesh-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real" href="#BeamletOptics.CircularFlatMesh-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>BeamletOptics.CircularFlatMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularFlatMesh(radius, n)</code></pre><p>Creates a 2D rectangular <a href="#BeamletOptics.Mesh"><code>Mesh</code></a> that is centered around the origin and aligned with respect to the <strong>negative y-axis</strong>.</p><p><strong>Inputs</strong></p><ul><li><code>radius</code>: of the mesh in [m]</li><li><code>n</code>: slice discretization factor (higher equals better resolution)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L312-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CubeMesh-Tuple{Real}" href="#BeamletOptics.CubeMesh-Tuple{Real}"><code>BeamletOptics.CubeMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Refer to <a href="#BeamletOptics.CuboidMesh-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}, Tuple{X, Y, Z, Real}} where {X&lt;:Real, Y&lt;:Real, Z&lt;:Real}"><code>CuboidMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.CuboidMesh-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}, Tuple{X, Y, Z, Real}} where {X&lt;:Real, Y&lt;:Real, Z&lt;:Real}" href="#BeamletOptics.CuboidMesh-Union{Tuple{Z}, Tuple{Y}, Tuple{X}, Tuple{X, Y, Z}, Tuple{X, Y, Z, Real}} where {X&lt;:Real, Y&lt;:Real, Z&lt;:Real}"><code>BeamletOptics.CuboidMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuboidMesh(x, y, z, θ=π/2)</code></pre><p>Constructs the <a href="#BeamletOptics.Mesh"><code>Mesh</code></a> of a rectangular cuboid as per the dimensions specified by <code>x</code>, <code>y</code> and <code>z</code>. In addition, one side of the mesh can be tilted by an angle <code>θ</code> in order to generate the mesh of a rhomb. The mesh is initialized such that one corner of the cuboid lies at the origin.</p><p><strong>Arguments</strong></p><ul><li><code>x, y, z</code>: dimensions for the cube in [m]</li><li><code>θ</code>: parallel tilt angle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L350-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.MoellerTrumboreAlgorithm-Union{Tuple{T}, Tuple{Any, BeamletOptics.AbstractRay{T}}} where T" href="#BeamletOptics.MoellerTrumboreAlgorithm-Union{Tuple{T}, Tuple{Any, BeamletOptics.AbstractRay{T}}} where T"><code>BeamletOptics.MoellerTrumboreAlgorithm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MoellerTrumboreAlgorithm(face::Matrix, ray::Ray)</code></pre><p>A culling implementation of the <strong>Möller-Trumbore algorithm</strong> for ray-triangle-intersection. This algorithm evaluates the possible intersection between a <code>ray</code> and a <code>face</code> that is defined by three vertices. If no intersection occurs, <code>Inf</code> is returned. <code>kϵ</code> is the abort threshold for backfacing and non-intersecting triangles. <code>lϵ</code> is the threshold for negative values of <code>t</code>. This algorithm is fast due to multiple breakout conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L194-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PlanoConcaveAsphericalLensSDF-Union{Tuple{MD}, Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}, Tuple{R, L, D, K, AbstractVector{A}, MD}} where {R, L, D, K, A, MD}" href="#BeamletOptics.PlanoConcaveAsphericalLensSDF-Union{Tuple{MD}, Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}, Tuple{R, L, D, K, AbstractVector{A}, MD}} where {R, L, D, K, A, MD}"><code>BeamletOptics.PlanoConcaveAsphericalLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanoConcaveAsphericalLensSDF(r, l, d=1inch)</code></pre><p>Constructs a plano-concave aspheric lens SDF with:</p><ul><li><code>r</code> &gt; 0: front radius</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter</li><li><code>cz</code>: aspheric surface chip zone</li><li><code>k</code> : The conic constant of the surface</li><li><code>α_coeffs</code> : The (even) aspheric coefficients, starting with A4.</li><li><code>md</code>: lens mechanical diameter (default: md = d)</li></ul><p>The spherical surface is constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L403-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PlanoConcaveLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, MD}} where {R, L, D, MD}" href="#BeamletOptics.PlanoConcaveLensSDF-Union{Tuple{MD}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, MD}} where {R, L, D, MD}"><code>BeamletOptics.PlanoConcaveLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanoConcaveLensSDF(r, l, d=1inch)</code></pre><p>Constructs a plano-concave lens SDF with:</p><ul><li><code>r</code> &gt; 0: front radius</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default value is one inch</li><li><code>md</code>: mechanical lens diameter, must be &gt; d</li></ul><p>The spherical surface is constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L358-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PlanoConvexAsphericalLensSDF-Union{Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}} where {R, L, D, K, A}" href="#BeamletOptics.PlanoConvexAsphericalLensSDF-Union{Tuple{A}, Tuple{K}, Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L, D, K, AbstractVector{A}}} where {R, L, D, K, A}"><code>BeamletOptics.PlanoConvexAsphericalLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanoConvexAsphericalLensSDF(r, l, d=1inch)</code></pre><p>Constructs a plano-convex aspheric lens SDF with:</p><ul><li><code>r</code> &gt; 0: front radius</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter</li><li><code>k</code> : The conic constant of the surface</li><li><code>α_coeffs</code> : The (even) aspheric coefficients, starting with A4.</li></ul><p>The spherical surface is constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L377-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.PlanoConvexLensSDF-Union{Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L}, Tuple{R, L, D}} where {R, L, D}" href="#BeamletOptics.PlanoConvexLensSDF-Union{Tuple{D}, Tuple{L}, Tuple{R}, Tuple{R, L}, Tuple{R, L, D}} where {R, L, D}"><code>BeamletOptics.PlanoConvexLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanoConvexLensSDF(r, l, d=1inch)</code></pre><p>Constructs a plano-convex lens SDF with:</p><ul><li><code>r</code> &gt; 0: front radius</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default value is one inch</li></ul><p>The spherical surface is constructed flush with the cylinder surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L327-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.QuadraticFlatMesh-Tuple{Real}" href="#BeamletOptics.QuadraticFlatMesh-Tuple{Real}"><code>BeamletOptics.QuadraticFlatMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadraticFlatMesh(width)</code></pre><p>Creates a 2D quadratic <a href="#BeamletOptics.Mesh"><code>Mesh</code></a>. Refer to <a href="#BeamletOptics.RectangularFlatMesh-Union{Tuple{H}, Tuple{W}, Tuple{W, H}} where {W&lt;:Real, H&lt;:Real}"><code>RectangularFlatMesh</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularCompensatorPlate-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T, Union{Function, DiscreteRefractiveIndex}}} where {W&lt;:Real, H&lt;:Real, T&lt;:Real}" href="#BeamletOptics.RectangularCompensatorPlate-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T, Union{Function, DiscreteRefractiveIndex}}} where {W&lt;:Real, H&lt;:Real, T&lt;:Real}"><code>BeamletOptics.RectangularCompensatorPlate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularCompensatorPlate(width, height, thickness, n)</code></pre><p>Creates a compensator plate (modeled as a <a href="#BeamletOptics.Prism"><code>Prism</code></a>) that can be used to remove parallel beam offsets created by e.g. the <a href="#BeamletOptics.RectangularPlateBeamsplitter"><code>RectangularPlateBeamsplitter</code></a>. The compensator is aligned with the positive y-axis. The first surface lies at the origin.</p><p><strong>Inputs</strong></p><ul><li><code>width</code>: compensator width along the x-axis in [m]</li><li><code>height</code>: compensator height along the z-axis in [m]</li><li><code>thickness</code>: compensator thickness along the y-axis in [m]</li><li><code>n</code>: the <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the substrate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/Compensators.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularFlatMesh-Union{Tuple{H}, Tuple{W}, Tuple{W, H}} where {W&lt;:Real, H&lt;:Real}" href="#BeamletOptics.RectangularFlatMesh-Union{Tuple{H}, Tuple{W}, Tuple{W, H}} where {W&lt;:Real, H&lt;:Real}"><code>BeamletOptics.RectangularFlatMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularFlatMesh(width, height)</code></pre><p>Creates a 2D rectangular <a href="#BeamletOptics.Mesh"><code>Mesh</code></a> that is centered around the origin and aligned with respect to the <strong>y-axis</strong>. <strong>Vertex normals are parallel to the positive y-axis.</strong></p><p><strong>Inputs</strong></p><ul><li><code>width</code>: width along the x-axis in [m]</li><li><code>height</code>: height along the z-axis in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L271-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RectangularPlanoMirror-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T}} where {W&lt;:Real, H&lt;:Real, T&lt;:Real}" href="#BeamletOptics.RectangularPlanoMirror-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T}} where {W&lt;:Real, H&lt;:Real, T&lt;:Real}"><code>BeamletOptics.RectangularPlanoMirror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RectangularPlanoMirror(width, height, thickness)</code></pre><p>Constructs a rectangular plano <a href="#BeamletOptics.Mirror"><code>Mirror</code></a> based on the input dimensions. The front reflecting surface is normal to the y-axis and lies at the origin.</p><p><strong>Inputs</strong></p><ul><li><code>width</code>:      of the mirror in x-direction [m] </li><li><code>height</code>:     of the mirror in z-direction [m] </li><li><code>thickness</code>:  of the mirror in y-direction [m] </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RetroMesh-Tuple{Real}" href="#BeamletOptics.RetroMesh-Tuple{Real}"><code>BeamletOptics.RetroMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RetroMesh(scale::Real; T = Float64)</code></pre><p>Creates an open tetrahedral <a href="#BeamletOptics.Mesh">Mesh</a> with edges derived from the vertices of a unit cube. Can be scaled with a <code>scale</code> factor. The data type for the vertices and internal computations can be adjusted using <code>T</code> (default: Float64).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Misc.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.RightAnglePrism-Tuple{Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.RightAnglePrism</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RightAnglePrism(leg_length, height, n)</code></pre><p>Creates a right angle symmetric <a href="#BeamletOptics.Prism"><code>Prism</code></a>. The prism is <em>not aligned</em> with the y-axis.</p><p><strong>Inputs</strong></p><ul><li><code>leg_length</code>: dimension in x- and y-direction in [m]</li><li><code>height</code>: in [m]</li><li><code>n</code>: <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> of the prism</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Prisms.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.RoundThinBeamsplitter-Tuple{Real}" href="#BeamletOptics.RoundThinBeamsplitter-Tuple{Real}"><code>BeamletOptics.RoundThinBeamsplitter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RoundThinBeamsplitter(diameter; reflectance=0.5)</code></pre><p>Creates a zero-thickness, 2D round <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> with the specified <code>diameter</code> in [m]. For more information, refer to the <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/ThinBeamsplitter.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SphericalDoubletLens-NTuple{8, Any}" href="#BeamletOptics.SphericalDoubletLens-NTuple{8, Any}"><code>BeamletOptics.SphericalDoubletLens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalDoubletLens(r1, r2, r3, l1, l2, d, n1, n2)</code></pre><p>Generates a two-component &quot;cemented&quot; doublet lens consisting of two spherical lenses. For radii sign definition, refer to the <a href="../components/lenses/#BeamletOptics.SphericalLens-components-lenses"><code>SphericalLens</code></a> constructor.</p><p><strong>Arguments</strong></p><ul><li><code>r1</code>: radius of curvature for first surface</li><li><code>r2</code>: radius of curvature for second (cemented) surface</li><li><code>r3</code>: radius of curvature for third surface</li><li><code>l1</code>: first lens thickness</li><li><code>l2</code>: second lens thickness</li><li><code>d</code>: lens diameter</li><li><code>n1</code>: first lens <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a></li><li><code>n1</code>: second lens <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/DoubletLenses.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SphericalLens" href="#BeamletOptics.SphericalLens"><code>BeamletOptics.SphericalLens</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalLens(r1, r2, l, d=1inch, n=λ-&gt;1.5)</code></pre><p>Creates a spherical <a href="#BeamletOptics.Lens"><code>Lens</code></a> based on:</p><ul><li><code>r1</code>: front radius</li><li><code>r2</code>: back radius</li><li><code>l</code>: lens thickness</li><li><code>d</code>: lens diameter, default is one inch</li><li><code>n</code>: <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> as a function of λ, i.e. <code>n = n(λ)</code></li></ul><p><strong>Notes</strong></p><div class="admonition is-info"><header class="admonition-header">Radius of curvature (ROC) sign</header><div class="admonition-body"><p>The ROC is defined to be positive if the center is to the right of the surface. Otherwise it is negative.</p></div></div><div class="admonition is-info"><header class="admonition-header">Thin lenses</header><div class="admonition-body"><p>If <code>l</code> is set to zero, a <a href="#BeamletOptics.ThinLens-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>ThinLens</code></a> will be created. However, note that the actual lens thickness will be different from zero.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/SphericalLenses.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SquarePlanoMirror-Union{Tuple{T}, Tuple{W}, Tuple{W, T}} where {W&lt;:Real, T&lt;:Real}" href="#BeamletOptics.SquarePlanoMirror-Union{Tuple{T}, Tuple{W}, Tuple{W, T}} where {W&lt;:Real, T&lt;:Real}"><code>BeamletOptics.SquarePlanoMirror</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SquarePlanoMirror(width, thickness)</code></pre><p>Constructs a square plano <a href="#BeamletOptics.Mirror"><code>Mirror</code></a> with equal width and height. The front reflecting surface is normal to the y-axis and lies at the origin. See also <a href="#BeamletOptics.RectangularPlanoMirror-Union{Tuple{T}, Tuple{H}, Tuple{W}, Tuple{W, H, T}} where {W&lt;:Real, H&lt;:Real, T&lt;:Real}"><code>RectangularPlanoMirror</code></a>.</p><p><strong>Inputs</strong></p><ul><li><code>width</code>: the side length of the square mirror in x- and y-direction [m]</li><li><code>thickness</code>: of the mirror in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.SquarePlanoMirror2D-Tuple{T} where T&lt;:Real" href="#BeamletOptics.SquarePlanoMirror2D-Tuple{T} where T&lt;:Real"><code>BeamletOptics.SquarePlanoMirror2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SquarePlanoMirror2D(edge_length)</code></pre><p>Constructs a 2D square plano <a href="#BeamletOptics.Mirror"><code>Mirror</code></a> with a given <code>edge_length</code>. The reflecting surface is normal to the y-axis.</p><p><strong>Inputs</strong></p><ul><li><code>edge_length</code>: the edge length of the square mirror in [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ThinLens-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex}}" href="#BeamletOptics.ThinLens-Tuple{Real, Real, Real, Union{Function, DiscreteRefractiveIndex}}"><code>BeamletOptics.ThinLens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinLens(R1::Real, R2::Real, d::Real, n::Function)</code></pre><p>Directly creates an ideal spherical thin <a href="#BeamletOptics.Lens"><code>Lens</code></a> with radii of curvature <code>R1</code> and <code>R2</code> and diameter <code>d</code> and <a href="#BeamletOptics.RefractiveIndex"><code>RefractiveIndex</code></a> <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/SphericalLenses.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.ThinLensSDF-Union{Tuple{O}, Tuple{M}, Tuple{L}, Tuple{L, M}, Tuple{L, M, O}} where {L, M, O}" href="#BeamletOptics.ThinLensSDF-Union{Tuple{O}, Tuple{M}, Tuple{L}, Tuple{L, M}, Tuple{L, M, O}} where {L, M, O}"><code>BeamletOptics.ThinLensSDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ThinLensSDF(r1, r2, d=1inch)</code></pre><p>Constructs a bi-convex thin lens SDF-based shape with:</p><ul><li><code>r1 &gt; 0</code>: radius of convex front</li><li><code>r2 &gt; 0</code>: radius of convex back</li><li><code>d</code>: lens diameter, default value is one inch</li></ul><p>The spherical surfaces are constructed flush.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics._beams_hits_same_shape-Tuple{GaussianBeamlet, Int64}" href="#BeamletOptics._beams_hits_same_shape-Tuple{GaussianBeamlet, Int64}"><code>BeamletOptics._beams_hits_same_shape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_beams_hits_same_shape(gauss, id)</code></pre><p>Tests if all rays at section <code>id</code> of <code>gauss</code> hit the same object shape. Returns <code>true</code> or <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics._calculate_global_E0-NTuple{4, AbstractArray}" href="#BeamletOptics._calculate_global_E0-NTuple{4, AbstractArray}"><code>BeamletOptics._calculate_global_E0</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_calculate_global_E0(in_dir, out_dir, J, E0)</code></pre><p>Calculates the resulting polarization vector as per the publication by Yun et al. for each surface interaction. If the <code>in</code>- and <code>out</code>-directions of propagation are parallel, an arbitrary basis is chosen for the s- and p-components.</p><p><strong>Arguments</strong></p><ul><li><code>in_dir</code>: propagation direction before surface interaction</li><li><code>out_dir</code>: propagation direction after surface interaction</li><li><code>J</code>: Jones matrix extended to 3x3, e.g. [-rₛ 0 0; 0 rₚ 0; 0 0 1] for reflection</li><li><code>E0</code>: Polarization vector before surface interaction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/PolarizedRays.jl#L72-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics._raymarch_inside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}" href="#BeamletOptics._raymarch_inside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}"><code>BeamletOptics._raymarch_inside</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_raymarch_inside(object::AbstractSDF, pos, dir; num_iter=1000, dl=0.1)</code></pre><p>Perform the ray marching algorithm if the starting pos is inside of <code>object</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics._raymarch_outside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}" href="#BeamletOptics._raymarch_outside-Union{Tuple{R}, Tuple{S}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any}, Tuple{BeamletOptics.AbstractSDF{S}, AbstractArray{R}, AbstractArray{R}, Any, Any}} where {S, R}"><code>BeamletOptics._raymarch_outside</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_raymarch_outside(shape::AbstractSDF, pos, dir; num_iter=1000, eps=1e-10)</code></pre><p>Perform the ray marching algorithm if the starting pos is outside of <code>shape</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics._world_to_sdf-Tuple{BeamletOptics.AbstractSDF, Any}" href="#BeamletOptics._world_to_sdf-Tuple{BeamletOptics.AbstractSDF, Any}"><code>BeamletOptics._world_to_sdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_world_to_sdf(sdf, point)</code></pre><p>Transforms the coordinates of <code>point</code> into a reference frame where the <code>sdf</code> lies at the origin. Useful to represent translation and rotation. If rotations are applied, the rotation is applied around the local sdf coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractMesh, Any}" href="#BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>BeamletOptics.align3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align3d!(mesh, target_axis)</code></pre><p>Aligns the local <code>mesh</code> y-axis onto the <code>target_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractShape, Any}" href="#BeamletOptics.align3d!-Tuple{BeamletOptics.AbstractShape, Any}"><code>BeamletOptics.align3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align3d!(shape, target_axis)</code></pre><p>Rotates the <code>shape</code> such that its local y-axis aligns with the <code>target_axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.align3d-Union{Tuple{B}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{B}}} where {A, B}" href="#BeamletOptics.align3d-Union{Tuple{B}, Tuple{A}, Tuple{AbstractVector{A}, AbstractVector{B}}} where {A, B}"><code>BeamletOptics.align3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align3d(start::AbstractVector, target::AbstractVector)</code></pre><p>Returns the rotation matrix R that will align the start vector to be parallel to the target vector. Based on <a href="https://gist.github.com/kevinmoran/b45980723e53edeb8a5a43c49f134724">&#39;Avoiding Trigonometry&#39;</a> by Íñigo Quílez. The resulting matrix was transposed due to column/row major issues. Vector length is maintained. This function is very fast.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L65-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.angle3d" href="#BeamletOptics.angle3d"><code>BeamletOptics.angle3d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle3d(ray::AbstractRay, intersect::Intersection=intersection(ray))</code></pre><p>Calculates the angle between a <code>ray</code> and its or some other <code>intersection</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.angle3d-Union{Tuple{R}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{R}}} where {T, R}" href="#BeamletOptics.angle3d-Union{Tuple{R}, Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{R}}} where {T, R}"><code>BeamletOptics.angle3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle3d(target::AbstractVector, reference::AbstractVector)</code></pre><p>Returns the angle between the <code>target</code> and <code>reference</code> vector in <strong>rad</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.aspheric_equation-NTuple{4, Any}" href="#BeamletOptics.aspheric_equation-NTuple{4, Any}"><code>BeamletOptics.aspheric_equation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>aspheric<em>equation(r, c, k, α</em>coeffs)</p><p>The aspheric surface equation. The asphere is defined by:</p><ul><li><code>c</code> : The curvature (1/radius) of the surface</li><li><code>k</code> : The conic constant of the surface</li><li><code>α_coeffs</code> : The (even) aspheric coefficients, starting with A4.</li></ul><p>This function returns NaN if the square root argument becomes negative.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Only even aspheres are implemented at the moment. This will change soon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L114-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.base_transform" href="#BeamletOptics.base_transform"><code>BeamletOptics.base_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">base_transform(base, base2=I(3))</code></pre><p>Return the base transformation matrix for transforming from vectors given relative to <code>base2</code> into <code>base</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.bounding_sphere-Tuple{BeamletOptics.AbstractSDF}" href="#BeamletOptics.bounding_sphere-Tuple{BeamletOptics.AbstractSDF}"><code>BeamletOptics.bounding_sphere</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounding_sphere(sdf)</code></pre><p>Returns <code>nothing</code> or a <code>center</code> point and the <code>radius</code> of a sphere which encloses the shape of the SDF. This function is currently only used for rendering SDFs but might be used in the future to optimize the raymarching algorithm, by tracing against the bounding sphere of and SDF first, instead of calling the more costly complex SDF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.children!-Union{Tuple{B}, Tuple{B, B}} where B&lt;:BeamletOptics.AbstractBeam" href="#BeamletOptics.children!-Union{Tuple{B}, Tuple{B, B}} where B&lt;:BeamletOptics.AbstractBeam"><code>BeamletOptics.children!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">children!(beam::B, child::B) where {B&lt;:AbstractBeam}</code></pre><p>Handles the inclusion of adding a single <code>child</code> to an existing <code>beam</code>. The function behaves as follows:</p><ol><li>If no previous children exist, add child</li><li>If <code>beam</code> already has a single child, modify child beam starting ray (retracing)</li><li>Else throw error</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractBeam.jl#L39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.convex_aspheric_surface_distance-NTuple{7, Any}" href="#BeamletOptics.convex_aspheric_surface_distance-NTuple{7, Any}"><code>BeamletOptics.convex_aspheric_surface_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convex_aspheric_surface_distance(r, z, c, k, d, α_coeffs)</code></pre><p>Calculates the 2D distance field for an aspheric surface at radius <code>r</code> away from the optical axis position <code>z</code>. The asphere is defined by:</p><ul><li><code>c</code> : The curvature (1/radius) of the surface</li><li><code>k</code> : The conic constant of the surface</li><li><code>d</code> : The diameter of the asphere</li><li><code>α_coeffs</code> : The (even) aspheric coefficients, starting with A2.</li></ul><p>Note that this is not just an infinite aspheric surface and also not a surface segment but a closed 2D perimeter.</p><p>It is intended to pair the SDF derived from this distance field with a cylinder SDF to build a real lens.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L166-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.countlines_in_dir-Tuple{String}" href="#BeamletOptics.countlines_in_dir-Tuple{String}"><code>BeamletOptics.countlines_in_dir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">countlines_in_dir(dir)</code></pre><p>Counts the number of lines of all <code>.jl</code> files in <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L434-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.create_spot_diagram-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}, Real}} where T" href="#BeamletOptics.create_spot_diagram-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}, Real}} where T"><code>BeamletOptics.create_spot_diagram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_spot_diagram(system, beam, aperture; n_rings, n_rays)</code></pre><p>Calculates the spot diagram for concentric rings of <strong>collimated beams</strong> within the specified <code>aperture</code> diameter. Uses retracing of an input <code>beam</code>. <strong>System must be aligned onto the global y-axis.</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The input <code>system</code> must feature <strong>one</strong> <a href="#BeamletOptics.Spotdetector"><code>Spotdetector</code></a> at the approx. focal plane.  The detector is automatically reset when calling this function.</p></div></div><p><strong>Inputs</strong></p><ul><li><code>aperture</code>: maximum aperture diamter in [m]</li><li><code>n_rings</code>: maximum number of concentric rings</li><li><code>n_rays</code>: total number of retracing runs, i.e. &quot;spawned beams&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Spotdetector.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.diameter-Tuple{BeamletOptics.AbstractLensSDF}" href="#BeamletOptics.diameter-Tuple{BeamletOptics.AbstractLensSDF}"><code>BeamletOptics.diameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the outer bounding diameter of the <code>AbstractLensSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}" href="#BeamletOptics.diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}"><code>BeamletOptics.diameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diameter(s::AbstractRotationallySymmetricSurface)</code></pre><p>Returns the clear optical diameter of the surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.edge_sag-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractSDF}" href="#BeamletOptics.edge_sag-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, BeamletOptics.AbstractSDF}"><code>BeamletOptics.edge_sag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the sagitta of the surface at it edge, i.e. at <code>diameter(s)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L56-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.electric_field" href="#BeamletOptics.electric_field"><code>BeamletOptics.electric_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electric_field(I::Real, Z=Z_vacuum, ϕ=0)</code></pre><p>Calculates the E-field phasor in [V/m] for a given intensity <code>I</code> and phase ϕ. Vacuum wave impedance is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.electric_field-Tuple{GaussianBeamlet, Any, Any}" href="#BeamletOptics.electric_field-Tuple{GaussianBeamlet, Any, Any}"><code>BeamletOptics.electric_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electric_field(gauss::GaussianBeamlet, r, z)</code></pre><p>Calculates the electric field phasor [V/m] of <code>gauss</code> at the radial and longitudinal positions <code>r</code> and <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L368-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.electric_field-Tuple{Real, Real, Vararg{Any, 6}}" href="#BeamletOptics.electric_field-Tuple{Real, Real, Vararg{Any, 6}}"><code>BeamletOptics.electric_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electric_field(r, z, E0, w0, w, k, ψ, R) -&gt; ComplexF64</code></pre><p>Computes the analytical complex electric field distribution of a stigmatic TEM₀₀ Gaussian beam which is described by:</p><p class="math-container">\[E(r,z) = {E_0}\frac{{{w_0}}}{{w(z)}}\exp\left( { - \frac{{{r^2}}}{{w{{(z)}^2}}}} \right)\exp\left(i\left[ {kz + \psi + \frac{{k{r^2}}}{2 R(z)}} \right] \right)\]</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: radial distance from beam origin</li><li><code>z</code>: axial distance from beam origin</li><li><code>E0</code>: peak electric field amplitude</li><li><code>w0</code>: waist radius</li><li><code>w</code>: local beam radius</li><li><code>k</code>: wave number, equal to <code>2π/λ</code></li><li><code>ψ</code>: Gouy phase shift (defined as <span>$-\text{atan}\left(\frac{z}{z_r}\right)$</span> !)</li><li><code>R</code>: wavefront curvature, i.e. 1/r (radius of curvature)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.find_zero_bisection-Tuple{Any, Any, Any}" href="#BeamletOptics.find_zero_bisection-Tuple{Any, Any, Any}"><code>BeamletOptics.find_zero_bisection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ToDO</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L456-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T" href="#BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T"><code>BeamletOptics.fresnel_coefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>fresnel_coefficients(θ, n)</p><p>Calculates the complex Fresnel coefficients for reflection and transmission based on the incident angle <code>θ</code> in [rad] and the refractive index ratio <code>n = n₂ / n₁</code>. Returns rₛ, rₚ, tₛ and tₚ.</p><p><strong>Signs</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The signs of rₛ, rₚ are based on the definition by Fowles (1975, 2nd Ed. p. 44) and Peatross (2015, 2023 Ed. p. 78)</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L264-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.gauss_parameters-Tuple{GaussianBeamlet, Real}" href="#BeamletOptics.gauss_parameters-Tuple{GaussianBeamlet, Real}"><code>BeamletOptics.gauss_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_parameters(gauss::GaussianBeamlet, z; hint::Union{Nothing, Tuple{Int, Vector{&lt;:Real}}}=nothing)</code></pre><p>Calculate the local waist radius and Gouy phase of an unastigmatic Gaussian beamlet at a specific distance <code>z</code> based on the method of J. Arnaud (1985) and D. DeJager (1992).</p><p><strong>Arguments</strong></p><ul><li><code>gauss</code>: the GaussianBeamlet object for which parameters are to be calculated.</li><li><code>z</code>: the position along the beam at which to calculate the parameters.</li><li><code>hint</code>: an optional hint parameter for the relevant point/index of the appropriate beam segment. If not provided, the function will automatically select the ray.</li></ul><p><strong>Returns</strong></p><ul><li><code>w</code>: local radius</li><li><code>R</code>: curvature, i.e. 1/r where r is the radius of curvature</li><li><code>ψ</code>: Gouy phase (note that -atan definition is used)</li><li><code>w0</code>: local beam waist radius</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L276-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.gauss_parameters-Union{Tuple{G}, Tuple{GaussianBeamlet{G}, AbstractArray}} where G" href="#BeamletOptics.gauss_parameters-Union{Tuple{G}, Tuple{GaussianBeamlet{G}, AbstractArray}} where G"><code>BeamletOptics.gauss_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_parameters(gauss::GaussianBeamlet, zs::AbstractArray)</code></pre><p>Return the parameters of the <code>GaussianBeamlet</code> along the specified positions in <code>zs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.height-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}" href="#BeamletOptics.height-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}"><code>BeamletOptics.height</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the cylindric height of the <code>AbstractCylindricalSurfaceSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intensity" href="#BeamletOptics.intensity"><code>BeamletOptics.intensity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the intensity in [W/m²] for a given complex electric field phasor <code>E</code>. Vacuum wave impedance is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}" href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(::AbstractSystem, pd::Photodetector, gauss::GaussianBeamlet, ray_id::Int)</code></pre><p>Implements the <a href="#BeamletOptics.Photodetector"><code>Photodetector</code></a> interaction with a <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a>. On hit, the scalar E-field of the <code>gauss</code> is added to the current PD field matrix. Tilt and tip between beam and PD surface are considered via projection factors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, ThinBeamsplitter, GaussianBeamlet, Int64}" href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, ThinBeamsplitter, GaussianBeamlet, Int64}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(::AbstractSystem, bs::ThinBeamsplitter, gauss::GaussianBeamlet, ray_id::Int)</code></pre><p>Models the interaction between a <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> and a <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a>.</p><p><strong>Reflection phase jump</strong></p><p>The reflection phase jump is modeled here as θᵣ = π for simplicity. This is since in practice it will have only a relative effect on the signal at the detector for interferometric setups. The phase jump is applied to the reflected portion of any incoming beam that faces the <a href="#BeamletOptics.ThinBeamsplitter"><code>ThinBeamsplitter</code></a> normal vector, which assumes that the splitter has an unambigous normal, i.e. a 2D mesh. This is intended to model the effect of the Fresnel equations without full polarization calculus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Beamsplitters/ThinBeamsplitter.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{RayType}, Tuple{ObjectType}, Tuple{BeamletOptics.AbstractSystem, ObjectType, BeamletOptics.AbstractBeam, RayType}} where {ObjectType&lt;:BeamletOptics.AbstractObject, RayType&lt;:BeamletOptics.AbstractRay}" href="#BeamletOptics.interact3d-Union{Tuple{RayType}, Tuple{ObjectType}, Tuple{BeamletOptics.AbstractSystem, ObjectType, BeamletOptics.AbstractBeam, RayType}} where {ObjectType&lt;:BeamletOptics.AbstractObject, RayType&lt;:BeamletOptics.AbstractRay}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(::AbstractSystem, object::AbstractObject, ::AbstractBeam)</code></pre><p>Defines the optical interaction between an incoming/outgoing beam/ray of light and an optical element, must return an <a href="#BeamletOptics.AbstractInteraction"><code>AbstractInteraction</code></a> or <code>nothing</code>. The default behavior is that no interaction occurs, i.e. return of <code>nothing</code>, which should stop the system tracing procedure. Refer to the <a href="#BeamletOptics.AbstractInteraction"><code>AbstractInteraction</code></a> typedocs for more information on the return type value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractSystem.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractObject, GaussianBeamlet{R}, Int64}} where R" href="#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractObject, GaussianBeamlet{R}, Int64}} where R"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(system::AbstractSystem, object::AbstractObject, gauss::GaussianBeamlet{R}, ray_id::Int)</code></pre><p>Generic dispatch for the <a href="#BeamletOptics.interact3d-Tuple{BeamletOptics.AbstractSystem, Photodetector, GaussianBeamlet, Int64}"><code>interact3d</code></a> method of a <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> with an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a>. Unless a more concrete implementation exists, the interaction of the Gaussian is assumed to be the interaction of the chief, waist and divergence rays with an object.</p><p><strong>Returns</strong></p><p>The <code>interact3d</code> method for the <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> must return a <code>GaussianBeamletInteraction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:PolarizedRay{T}}" href="#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:PolarizedRay{T}}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(AbstractReflectiveOptic, PolarizedRay)</code></pre><p>Implements the ideal reflection of a <a href="#BeamletOptics.PolarizedRay"><code>PolarizedRay</code></a> via the normal at the intersection point on an optical surface. A Jones matrix of [-1 0 0; 0 1 0] is assumed as per Peatross (2015, 2023 Ed. p. 154) and Yun et al. (see <a href="#BeamletOptics.PolarizedRay"><code>PolarizedRay</code></a> for more information).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:Ray{T}}" href="#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractReflectiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:Ray{T}}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(AbstractReflectiveOptic, Ray)</code></pre><p>Implements the reflection of a <a href="#BeamletOptics.Ray"><code>Ray</code></a> via the normal at the intersection point on an optical surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Mirrors.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:PolarizedRay{T}}" href="#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:PolarizedRay{T}}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(AbstractSystem, AbstractRefractiveOptic, Beam, PolarizedRay)</code></pre><p>Implements the refraction of a <a href="#BeamletOptics.PolarizedRay"><code>PolarizedRay</code></a> at an uncoated optical surface. The &quot;outside&quot; ref. index is obtained from the <code>system</code> unless specified otherwise. Reflection and transmission values are calculated via the <a href="#BeamletOptics.fresnel_coefficients-Union{Tuple{T}, Tuple{T, Number}} where T"><code>fresnel_coefficients</code></a>. Stray light is not tracked. In the case of total internal reflection, only the reflected light is traced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:Ray{T}}" href="#BeamletOptics.interact3d-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRefractiveOptic, Beam{T, R}, R}} where {T&lt;:Real, R&lt;:Ray{T}}"><code>BeamletOptics.interact3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interact3d(AbstractSystem, AbstractRefractiveOptic, Beam, Ray)</code></pre><p>Implements the refraction of a <a href="#BeamletOptics.Ray"><code>Ray</code></a> at an optical surface. The &quot;outside&quot; ref. index is obtained from the <code>system</code> unless specified otherwise. At the critical angle, total internal reflection occurs (see <a href="#BeamletOptics.refraction3d-Tuple{AbstractArray, AbstractArray, Real, Real}"><code>refraction3d</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Lenses.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractObject, BeamletOptics.AbstractRay}" href="#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractObject, BeamletOptics.AbstractRay}"><code>BeamletOptics.intersect3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect3d(object::AbstractObject, ray::AbstractRay)</code></pre><p>In general, the intersection logic between an <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a> and an <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a> depends on the <a href="#BeamletOptics.AbstractShapeTrait"><code>AbstractShapeTrait</code></a>. Refer to the respective documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractSDF, BeamletOptics.AbstractRay}" href="#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractSDF, BeamletOptics.AbstractRay}"><code>BeamletOptics.intersect3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect3d(sphere::AbstractSphere, ray::Ray)</code></pre><p>Intersection algorithm for sdf based shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}" href="#BeamletOptics.intersect3d-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}"><code>BeamletOptics.intersect3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect3d(shape::AbstractShape, ::AbstractRay)</code></pre><p>Defines the intersection between an <a href="#BeamletOptics.AbstractShape"><code>AbstractShape</code></a> and an <a href="#BeamletOptics.AbstractRay"><code>AbstractRay</code></a>, must return an <a href="#BeamletOptics.Intersection"><code>Intersection</code></a> or <code>nothing</code>. The default behavior for concrete <code>shape</code>s and rays is to indicate no intersection, that is <code>nothing</code>, which will inform the tracing algorithm to stop. Refer to the <a href="#BeamletOptics.Intersection"><code>Intersection</code></a> documentation for more information on the return type value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intersect3d-Union{Tuple{R}, Tuple{M}, Tuple{BeamletOptics.AbstractMesh{M}, BeamletOptics.AbstractRay{R}}} where {M&lt;:Real, R&lt;:Real}" href="#BeamletOptics.intersect3d-Union{Tuple{R}, Tuple{M}, Tuple{BeamletOptics.AbstractMesh{M}, BeamletOptics.AbstractRay{R}}} where {M&lt;:Real, R&lt;:Real}"><code>BeamletOptics.intersect3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect3d(mesh::Mesh, ray::Ray)</code></pre><p>This function is a generic implementation to check if a ray intersects the shape mesh.<br/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.intersect3d-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, BeamletOptics.AbstractRay{T}}} where T" href="#BeamletOptics.intersect3d-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, BeamletOptics.AbstractRay{T}}} where T"><code>BeamletOptics.intersect3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect3d(plane_position, plane_normal, ray)</code></pre><p>Returns the intersection between a <code>ray</code> and an infinitely large plane which is characterized by its <code>position</code> and <code>normal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isentering-Tuple{BeamletOptics.AbstractRay}" href="#BeamletOptics.isentering-Tuple{BeamletOptics.AbstractRay}"><code>BeamletOptics.isentering</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isentering(ray)</code></pre><p>Tests whether the ray is entering a shape based on the orientation of the <code>ray</code> direction and surface normal. If no intersection is present, default behavior is to return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isinfrontof-Tuple{AbstractVector, AbstractVector, AbstractVector}" href="#BeamletOptics.isinfrontof-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>BeamletOptics.isinfrontof</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isinfrontof(point::AbstractVector, pos::AbstractVector, dir::AbstractVector)</code></pre><p>Tests if a <code>point</code> is in front of the plane defined by the <code>pos</code>ition and <code>dir</code>ection vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isinfrontof-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}" href="#BeamletOptics.isinfrontof-Tuple{BeamletOptics.AbstractShape, BeamletOptics.AbstractRay}"><code>BeamletOptics.isinfrontof</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isinfrontof(shape::AbstractShape, ray::AbstractRay)</code></pre><p>A simple test to check if a <code>shape</code> lies &quot;in front of&quot; a <code>ray</code>. The forward direction is here defined as the ray <code>orientation</code>. Only works well if <code>ray</code> is <strong>outside</strong> of the volume of <code>shape</code>. Can be dispatched to return more accurate results for subtypes of <code>AbstractShape</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isparaxial" href="#BeamletOptics.isparaxial"><code>BeamletOptics.isparaxial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isparaxial(system, beam, threshold=π/4)</code></pre><p>Tests the angle between the <code>beam</code> direction and surface normal at each intersection. Mainly intended as a check for <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isparaxial" href="#BeamletOptics.isparaxial"><code>BeamletOptics.isparaxial</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isparaxial(system, gb::GaussianBeamlet, threshold=π/4)</code></pre><p>Tests the angle between the waist and divergence beams and refractive surfaces. A target threshold of π/4 or 45° is assumed before abberations become dominant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L385-L390">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.isparentbeam-Tuple{Beam, BeamletOptics.AbstractRay}" href="#BeamletOptics.isparentbeam-Tuple{Beam, BeamletOptics.AbstractRay}"><code>BeamletOptics.isparentbeam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isparentbeam(beam, ray)</code></pre><p>Tests if the given <code>beam</code> contains the <code>ray</code> as a part of its solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.istilted-Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet}" href="#BeamletOptics.istilted-Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet}"><code>BeamletOptics.istilted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istilted(system::System, gb::GaussianBeamlet)</code></pre><p>Tests if refractive elements are tilted with respect to the beamlet optical axis, i.e. introduce simple astigmatism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L399-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.lensmakers_eq-Tuple{Any, Any, Any}" href="#BeamletOptics.lensmakers_eq-Tuple{Any, Any, Any}"><code>BeamletOptics.lensmakers_eq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lensmakers_eq(R1, R2, n)</code></pre><p>Calculates the thin lens focal length based on the radius of curvature <code>R1</code>/<code>R2</code> and the lens refractive index <code>n</code>. If center of sphere is on left then R &lt; 0. If center of sphere is on right then R &gt; 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.line_plane_distance3d-NTuple{4, AbstractArray}" href="#BeamletOptics.line_plane_distance3d-NTuple{4, AbstractArray}"><code>BeamletOptics.line_plane_distance3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line_plane_distance3d(plane_position, plane_normal, line_position, line_direction)</code></pre><p>Returns the distance between a line and an infinitely large plane which are characterized by their <code>position</code> and <code>normal</code>/<code>direction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.line_point_distance3d-Tuple{Any, Any, Any}" href="#BeamletOptics.line_point_distance3d-Tuple{Any, Any, Any}"><code>BeamletOptics.line_point_distance3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line_point_distance3d(pos, dir, point)</code></pre><p>Computes the shortes distance between a line described by <code>pos</code>+t*<code>dir</code> and a <code>point</code> in 3D. This function is slow and should be used only for debugging purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.line_point_distance3d-Tuple{BeamletOptics.AbstractRay, Any}" href="#BeamletOptics.line_point_distance3d-Tuple{BeamletOptics.AbstractRay, Any}"><code>BeamletOptics.line_point_distance3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line_point_distance3d(ray, point)</code></pre><p>Returns value for the shortest distance between the <code>ray</code> (extended to ∞) and <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.list_subtypes" href="#BeamletOptics.list_subtypes"><code>BeamletOptics.list_subtypes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">list_subtypes(T::Type; max_depth::Int=5)</code></pre><p>Prints a tree of all subtypes, e.g. <code>list_subtypes(AbstractObject)</code>. Maximum exploration depth can be limited by passing <code>max_depth</code>. Returns the total number of types encountered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L390-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.mechanical_diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}" href="#BeamletOptics.mechanical_diameter-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}"><code>BeamletOptics.mechanical_diameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mechanical_diameter(s::AbstractRotationallySymmetricSurface)</code></pre><p>Returns the mechanical diameter of the surface.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>It is assumed that mechanical_diameter(s) &gt;= diameter(s) always holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.normal3d-Tuple{AbstractArray}" href="#BeamletOptics.normal3d-Tuple{AbstractArray}"><code>BeamletOptics.normal3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal3d(input)</code></pre><p>Returns a <strong>random</strong> vector with unit length that is perpendicular to the <code>input</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.normal3d-Tuple{Any, Any}" href="#BeamletOptics.normal3d-Tuple{Any, Any}"><code>BeamletOptics.normal3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal3d(target, reference)</code></pre><p>Returns a vector with unit length that is perpendicular to the target and an additional reference vector. Vector orientation is determined according to right-hand rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.normal3d-Tuple{BeamletOptics.AbstractSDF, Any}" href="#BeamletOptics.normal3d-Tuple{BeamletOptics.AbstractSDF, Any}"><code>BeamletOptics.normal3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal3d(s::AbstractSDF, pos)</code></pre><p>Computes the normal vector of <code>s</code> at <code>pos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.normal3d-Union{Tuple{T}, Tuple{BeamletOptics.AbstractMesh{T}, Int64}} where T" href="#BeamletOptics.normal3d-Union{Tuple{T}, Tuple{BeamletOptics.AbstractMesh{T}, Int64}} where T"><code>BeamletOptics.normal3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal3d(mesh::AbstractMesh, fID::Int)</code></pre><p>Returns a vector with unit length that is perpendicular to the target <code>face</code>` according to the right-hand rule. The vertices must be listed row-wise within the face matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.objects-Tuple{ObjectGroup}" href="#BeamletOptics.objects-Tuple{ObjectGroup}"><code>BeamletOptics.objects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objects(group::ObjectGroup)</code></pre><p>Exposes all objects/subgroups stored within the group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Groups.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.objects-Tuple{System}" href="#BeamletOptics.objects-Tuple{System}"><code>BeamletOptics.objects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objects(system::System)</code></pre><p>Exposes all objects stored within the system. By exposing the <code>Leaves</code> of the tree only, it is ensured that <code>AbstractObjectGroup</code>s are flattened into a regular vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.op_extrude_x-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T&lt;:Real" href="#BeamletOptics.op_extrude_x-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T&lt;:Real"><code>BeamletOptics.op_extrude_x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">op_extrude_x(p, sdf2d::Function, height)</code></pre><p>Calculates the SDF at point <code>p</code> for the given 2D-SDF function and extrudes the shape to <code>height</code> along the x-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L237-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.op_extrude_z-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T&lt;:Real" href="#BeamletOptics.op_extrude_z-Union{Tuple{T}, Tuple{Point3{T}, Function, Real}} where T&lt;:Real"><code>BeamletOptics.op_extrude_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">op_extrude_z(p, sdf2d::Function, height)</code></pre><p>Calculates the SDF at point <code>p</code> for the given 2D-SDF function and extrudes the shape to <code>height</code> along the z-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.op_revolve_y-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T&lt;:Real" href="#BeamletOptics.op_revolve_y-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T&lt;:Real"><code>BeamletOptics.op_revolve_y</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">op_revolve_y(p, sdf2d::Function, offset)</code></pre><p>Calculates the SDF at point <code>p</code> for the given 2D-SDF function with <code>offset</code> by revolving the 2D shape around the y-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.op_revolve_z-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T&lt;:Real" href="#BeamletOptics.op_revolve_z-Union{Tuple{T}, Tuple{Point3{T}, Function}, Tuple{Point3{T}, Function, Any}} where T&lt;:Real"><code>BeamletOptics.op_revolve_z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">op_revolve_z(p, sdf2d::Function, offset)</code></pre><p>Calculates the SDF at point <code>p</code> for the given 2D-SDF function with <code>offset</code> by revolving the 2D shape around the z-axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.optical_path_length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T" href="#BeamletOptics.optical_path_length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T"><code>BeamletOptics.optical_path_length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optical_path_length(ray::AbstractRay{T}) where {T}</code></pre><p>Calculate the <code>o</code>ptical <code>p</code>ath <code>l</code>ength, i.e. <span>$OPL = n \cdot l$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.optical_path_length-Union{Tuple{Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T" href="#BeamletOptics.optical_path_length-Union{Tuple{Beam{T, R} where R&lt;:BeamletOptics.AbstractRay{T}}, Tuple{T}} where T"><code>BeamletOptics.optical_path_length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optical_path_length(beam::Beam)</code></pre><p>Calculate the <code>o</code>ptical <code>p</code>ath <code>l</code>ength, i.e. <span>$OPL = n \cdot l$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.optical_power-Tuple{Photodetector}" href="#BeamletOptics.optical_power-Tuple{Photodetector}"><code>BeamletOptics.optical_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optical_power(pd::Photodetector)</code></pre><p>Calculates the total optical power on <code>pd</code> in [W] by integration over the local intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.orientation-Tuple{BeamletOptics.AbstractObject}" href="#BeamletOptics.orientation-Tuple{BeamletOptics.AbstractObject}"><code>BeamletOptics.orientation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Enforces that <code>object</code> has to have the field <code>dir</code> or implement <code>orientation()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.orientation-Tuple{BeamletOptics.AbstractShape}" href="#BeamletOptics.orientation-Tuple{BeamletOptics.AbstractShape}"><code>BeamletOptics.orientation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Enforces that <code>shape</code> has to have the field <code>dir</code> or implement <code>orientation()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.parent!-Tuple{GaussianBeamlet, GaussianBeamlet}" href="#BeamletOptics.parent!-Tuple{GaussianBeamlet, GaussianBeamlet}"><code>BeamletOptics.parent!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parent!(beam::GaussianBeamlet, parent::GaussianBeamlet)</code></pre><p>Ensures that the GaussianBeamlet knows about its parent beam. In addition, links the chief beams of child and parent. Important for correct functioning of <a href="#BeamletOptics.point_on_beam-Union{Tuple{B}, Tuple{R}, Tuple{T}, Tuple{B, Real}} where {T, R&lt;:BeamletOptics.AbstractRay{T}, B&lt;:Beam{T, R}}"><code>point_on_beam</code></a> and <a href="#Base.length-Union{Tuple{BeamletOptics.AbstractRay{T}}, Tuple{T}} where T"><code>length</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.photodetector_resolution!-Union{Tuple{S}, Tuple{T}, Tuple{Photodetector{T, S}, Int64}} where {T, S}" href="#BeamletOptics.photodetector_resolution!-Union{Tuple{S}, Tuple{T}, Tuple{Photodetector{T, S}, Int64}} where {T, S}"><code>BeamletOptics.photodetector_resolution!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">photodetector_resolution!(pd::Photodetector, n::Int)</code></pre><p>Sets the resolution of <code>pd</code> to <code>n</code> × <code>n</code>. Note that this resets the current <code>pd.field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.point_on_beam-Union{Tuple{B}, Tuple{R}, Tuple{T}, Tuple{B, Real}} where {T, R&lt;:BeamletOptics.AbstractRay{T}, B&lt;:Beam{T, R}}" href="#BeamletOptics.point_on_beam-Union{Tuple{B}, Tuple{R}, Tuple{T}, Tuple{B, Real}} where {T, R&lt;:BeamletOptics.AbstractRay{T}, B&lt;:Beam{T, R}}"><code>BeamletOptics.point_on_beam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_on_beam(beam::Beam, t::Real)</code></pre><p>Function to find a point given a specific distance <code>t</code> along the beam. Return the ray <code>index</code> aswell. For negative distances, assume first ray backwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Beam.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.position-Tuple{BeamletOptics.AbstractObject}" href="#BeamletOptics.position-Tuple{BeamletOptics.AbstractObject}"><code>BeamletOptics.position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Enforces that <code>object</code> has to have the field <code>pos</code> or implement <code>position()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.position-Tuple{BeamletOptics.AbstractShape}" href="#BeamletOptics.position-Tuple{BeamletOptics.AbstractShape}"><code>BeamletOptics.position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Enforces that <code>shape</code> has to have the field <code>pos</code> or implement <code>position()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.radius-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}" href="#BeamletOptics.radius-Tuple{BeamletOptics.AbstractCylindricalSurfaceSDF}"><code>BeamletOptics.radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the radius of the <code>AbstractCylindricalSurfaceSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/CylindricalSDF.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.radius-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}" href="#BeamletOptics.radius-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface}"><code>BeamletOptics.radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(s::AbstractRotationallySymmetricSurface)</code></pre><p>Returns the radius of curvature of the surface. This might return <code>Inf</code> for planar surfaces or surfaces which cannot be described by just one curvature radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.radius-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}" href="#BeamletOptics.radius-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}"><code>BeamletOptics.radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the radius of curvature of the <code>AbstractSphericalSurfaceSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.rayleigh_range-Tuple{GaussianBeamlet}" href="#BeamletOptics.rayleigh_range-Tuple{GaussianBeamlet}"><code>BeamletOptics.rayleigh_range</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rayleigh_range(g::GaussianBeamlet; M2=1)</code></pre><p>Returns the Rayleigh range for the <strong>first</strong> beam section of the <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> <code>g</code>. Note: <code>M2</code> is not stored in <code>g</code> during construction and must be specified by the user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Gaussian.jl#L413-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reflection3d-Tuple{Any, Any}" href="#BeamletOptics.reflection3d-Tuple{Any, Any}"><code>BeamletOptics.reflection3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflection3d(dir, normal)</code></pre><p>Calculates the reflection between an input vector <code>dir</code> and surface <code>normal</code> vector in R³. Vectors <code>dir</code> and <code>normal</code> must have <strong>unit length</strong>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.refraction3d-Tuple{AbstractArray, AbstractArray, Real, Real}" href="#BeamletOptics.refraction3d-Tuple{AbstractArray, AbstractArray, Real, Real}"><code>BeamletOptics.refraction3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refraction3d(dir, normal, n1, n2)</code></pre><p>Calculates the refraction between an input vector <code>dir</code> and surface <code>normal</code> vector in R³. <code>n1</code> is the &quot;outside&quot; refractive index and <code>n2</code> is the &quot;inside&quot; refractive index. The function returns the new direction of propagation and a boolean flag to indicate if internal refraction has occured.</p><p>Vectors <code>dir</code> and <code>normal</code> must have <strong>unit length</strong>!</p><p><strong>Total internal reflection</strong></p><p>If the critical angle for n1, n2 and the incident angle is reached, the ray is reflected internally instead!</p><p><strong>Arguments</strong></p><ul><li><code>dir</code>: direction vector of incoming ray</li><li><code>normal</code>: surface normal at point of intersection</li><li><code>n1</code>: index of ref. before refraction</li><li><code>n2</code>: index of ref. after refraction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L160-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.refraction3d-Tuple{BeamletOptics.AbstractRay, Any}" href="#BeamletOptics.refraction3d-Tuple{BeamletOptics.AbstractRay, Any}"><code>BeamletOptics.refraction3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refraction3d(ray, n2)</code></pre><p>Calculates the new direction of a <code>ray</code> entering into a new medium with ref. index <code>n2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractRay.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_beam!-Tuple{Any, Beam}" href="#BeamletOptics.render_beam!-Tuple{Any, Beam}"><code>BeamletOptics.render_beam!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_beam!(axis, beam::Beam; color=:blue, flen=1.0, show_pos=false)</code></pre><p>Render the entire <code>beam</code> into the specified 3D-<code>axis</code>. A <code>color</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_beam!-Union{Tuple{T}, Tuple{Any, GaussianBeamlet{T}}} where T" href="#BeamletOptics.render_beam!-Union{Tuple{T}, Tuple{Any, GaussianBeamlet{T}}} where T"><code>BeamletOptics.render_beam!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_beam!(axis, gauss::GaussianBeamlet; color=:red, flen=0.1, show_beams=false)</code></pre><p>Render the surface of a <code>GaussianBeamlet</code> as <code>color</code>. With <code>show_beams</code> the generating rays are plotted as follows:</p><ul><li><code>chief</code> ray: red</li><li><code>divergence</code> ray: green</li><li><code>waist</code> ray: blue</li></ul><p><strong>Keyword args</strong></p><ul><li><code>color = :red</code>: color of the beam as per the Makie syntax, i.e. :blue</li><li><code>flen = 0.1</code>: length of the final beam in case of no intersection</li><li><code>show_beams = false</code>: plot the generating rays of the <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a></li><li><code>r_res::Int = 50</code>: radial resolution of the beam</li><li><code>z_res::Int = 100</code>: resolution along the optical axis of the beam</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_object!-Tuple{Any, BeamletOptics.AbstractMesh}" href="#BeamletOptics.render_object!-Tuple{Any, BeamletOptics.AbstractMesh}"><code>BeamletOptics.render_object!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_object!(axis, mesh::AbstractMesh)</code></pre><p>Render <code>mesh</code> into the specified 3D-<code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_object!-Tuple{Any, BeamletOptics.AbstractSDF}" href="#BeamletOptics.render_object!-Tuple{Any, BeamletOptics.AbstractSDF}"><code>BeamletOptics.render_object!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_object!(axis, s::AbstractSDF)</code></pre><p>Render the surface of <code>s</code> based on the marching cubes algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSDF.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_object_normals!-Tuple{Any, BeamletOptics.Mesh}" href="#BeamletOptics.render_object_normals!-Tuple{Any, BeamletOptics.Mesh}"><code>BeamletOptics.render_object_normals!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_object_normals!(axis, mesh::Mesh; l=0.01)</code></pre><p>Helper function to visualize the <code>mesh</code> normals of an object. The normals are displayed with a standard <code>l</code>ength of 0.01</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_ray!-Tuple{Any, BeamletOptics.AbstractRay}" href="#BeamletOptics.render_ray!-Tuple{Any, BeamletOptics.AbstractRay}"><code>BeamletOptics.render_ray!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_ray!(axis, ray::AbstractRay; color=:blue, flen=1.0)</code></pre><p>Renders a <code>ray</code> as a 3D line. If the ray has no intersection, the substitute length <code>flen</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.render_system!-Tuple{Any, BeamletOptics.AbstractSystem}" href="#BeamletOptics.render_system!-Tuple{Any, BeamletOptics.AbstractSystem}"><code>BeamletOptics.render_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">render_system!(axis, system::AbstractSystem)</code></pre><p>Render all objects contained in the <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Render.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_detector!-Tuple{D} where D&lt;:BeamletOptics.AbstractDetector" href="#BeamletOptics.reset_detector!-Tuple{D} where D&lt;:BeamletOptics.AbstractDetector"><code>BeamletOptics.reset_detector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_detector!(detector)</code></pre><p>Resets the field data of the <code>detector</code>. Must be implemented for each concrete subtype of <a href="#BeamletOptics.AbstractDetector"><code>AbstractDetector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Detectors.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_detector!-Union{Tuple{Photodetector{T, S}}, Tuple{S}, Tuple{T}} where {T, S}" href="#BeamletOptics.reset_detector!-Union{Tuple{Photodetector{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>BeamletOptics.reset_detector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Resets the values currently stored in <code>pd.field</code> to zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Photodetector.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_detector!-Union{Tuple{Spotdetector{T}}, Tuple{T}} where T" href="#BeamletOptics.reset_detector!-Union{Tuple{Spotdetector{T}}, Tuple{T}} where T"><code>BeamletOptics.reset_detector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Resets the stored spot diagram data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/OpticalComponents/Detectors/Spotdetector.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T" href="#BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T"><code>BeamletOptics.reset_rotation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_rotation3d!(mesh::AbstractMesh)</code></pre><p>Resets all previous rotations around the current offset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T" href="#BeamletOptics.reset_rotation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T"><code>BeamletOptics.reset_rotation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Resets the <code>shape</code> rotation angles to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_rotation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S&lt;:BeamletOptics.AbstractShape{T}}} where T" href="#BeamletOptics.reset_rotation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S&lt;:BeamletOptics.AbstractShape{T}}} where T"><code>BeamletOptics.reset_rotation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_rotation3d!(::MultiShape, object)</code></pre><p>Reset all applied rotations of the <code>object</code>, i.e. resets the local coordinate system to the standard base.</p><div class="admonition is-info"><header class="admonition-header">Parts within parts</header><div class="admonition-body"><p>Sub-part relative rotations are not reset!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T" href="#BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T"><code>BeamletOptics.reset_translation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_translation3d!(mesh::AbstractMesh)</code></pre><p>Resets all previous translations and returns the mesh back to the global origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T" href="#BeamletOptics.reset_translation3d!-Union{Tuple{BeamletOptics.AbstractShape{T}}, Tuple{T}} where T"><code>BeamletOptics.reset_translation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the <code>shape</code> to the global origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.reset_translation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S&lt;:BeamletOptics.AbstractShape{T}}} where T" href="#BeamletOptics.reset_translation3d!-Union{Tuple{T}, Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject{T, S} where S&lt;:BeamletOptics.AbstractShape{T}}} where T"><code>BeamletOptics.reset_translation3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_translation3d!(::MultiShape, object)</code></pre><p>Resets all applied translations of the <code>object</code>, i.e. moves the center back to the origin.</p><div class="admonition is-info"><header class="admonition-header">Parts within parts</header><div class="admonition-body"><p>Sub-part relative translations are not reset!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.retrace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T&lt;:Real, R&lt;:BeamletOptics.AbstractRay{T}}" href="#BeamletOptics.retrace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T&lt;:Real, R&lt;:BeamletOptics.AbstractRay{T}}"><code>BeamletOptics.retrace_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retrace_system!(system, beam)</code></pre><p>This function tries to reuse data from a previous solution in order to solve the <code>system</code> using a sequential approach.</p><p><strong>Retracing</strong></p><p>The retracing logic for an already solved <code>beam</code> loops over the rays and children and is as follows:</p><p><code>Begin</code></p><ol><li>Test if current <code>ray</code> has a valid <code>intersection</code><ul><li>If not, mark beam tail for cleanup and go to <code>End</code></li></ul></li><li>Recalculate the <code>intersection</code><ul><li>If a hint was provided by a previous interaction, use hinted object</li><li>Else, test against previous <code>intersection</code></li></ul></li><li>Test if the <code>ray</code> still has a valid <code>intersection</code> after recalculation<ul><li>If no object is hit, mark beam tail for cleanup and go to <code>End</code></li></ul></li></ol><p><code>Interact</code></p><ol><li>Recalculate the optical <code>interaction</code><ul><li>Catch hints provided for next <code>ray</code></li><li>If no <code>interaction</code> occurs, mark beam tail for conditional cleanup and go to <code>End</code></li></ul></li><li>Add the interaction to the current <code>beam</code><ul><li>If another <code>ray</code> follows, modify the next starting position     - Go to <code>Begin</code></li><li>Else mark children for cleanup, push new ray to <code>beam</code> tail     - Go to <code>End</code></li></ul></li></ol><p><code>End</code></p><ol><li>If cleanup is required, do conditionally<ul><li>remove all beam tail rays after current <code>ray</code></li><li>remove all beam children</li><li>reset beam tail ray intersection to nothing</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L156-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.retrace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T&lt;:Real" href="#BeamletOptics.retrace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T&lt;:Real"><code>BeamletOptics.retrace_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retrace_system!(system::System, gauss::GaussianBeamlet{T}) where {T &lt;: Real}</code></pre><p>Retrace the beam stored in <code>GaussianBeamlet</code> through the optical <code>system</code>. Chief, waist and divergence ray intersections and interactions are recalculated. All rays must hit the same object, or the retracing step is aborted. If retracing is stopped before the end of the beam is reached, further rays are dropped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L320-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractMesh, Any, Any}" href="#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractMesh, Any, Any}"><code>BeamletOptics.rotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate3d!(mesh, axis, θ)</code></pre><p>Mutating function that rotates the <code>mesh</code> around the specified rotation <code>axis</code> by the angle <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractShape, Any, Any}" href="#BeamletOptics.rotate3d!-Tuple{BeamletOptics.AbstractShape, Any, Any}"><code>BeamletOptics.rotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate3d!(shape::AbstractShape, axis, θ)</code></pre><p>Rotates the <code>dir</code>-matrix of <code>shape</code> around the reference-<code>axis</code> by an angle of <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.rotate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any, Any}" href="#BeamletOptics.rotate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any, Any}"><code>BeamletOptics.rotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate3d!(::MultiShape, object, axis, θ)</code></pre><p>All parts of the <a href="#BeamletOptics.MultiShape"><code>MultiShape</code></a> <code>object</code> are rotated around the pivot center via the specified angle <code>θ</code> and <code>axis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.rotate3d-Tuple{AbstractVector, Any}" href="#BeamletOptics.rotate3d-Tuple{AbstractVector, Any}"><code>BeamletOptics.rotate3d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate3d(reference::Vector, θ)</code></pre><p>Returns the rotation matrix that will rotate a vector around the reference axis at an angle θ in radians. Vector length is maintained. Rotation in clockwise direction?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.sag-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}" href="#BeamletOptics.sag-Tuple{BeamletOptics.AbstractSphericalSurfaceSDF}"><code>BeamletOptics.sag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the sagitta of the <code>AbstractSphericalSurfaceSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.sag-Tuple{Real, Real}" href="#BeamletOptics.sag-Tuple{Real, Real}"><code>BeamletOptics.sag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sag(r::Real, l::Real)</code></pre><p>Calculates the sag of a cut circle with radius <code>r</code> and chord length <code>l</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.scale3d!-Tuple{BeamletOptics.AbstractMesh, Any}" href="#BeamletOptics.scale3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>BeamletOptics.scale3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale3d!(mesh::AbstractMesh, scale)</code></pre><p>Allows rescaling of mesh data around &quot;center of gravity&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.sd_line_segment-Tuple{Any, Any, Any}" href="#BeamletOptics.sd_line_segment-Tuple{Any, Any, Any}"><code>BeamletOptics.sd_line_segment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sd_line_segment(p, a, b)</code></pre><p>Returns the signed distance from point <code>p</code> to the line segment described by the points <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AsphericalLensSDF.jl#L153-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.sdf-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, Union{Nothing, BeamletOptics.AbstractOrientationType}}" href="#BeamletOptics.sdf-Tuple{BeamletOptics.AbstractRotationallySymmetricSurface, Union{Nothing, BeamletOptics.AbstractOrientationType}}"><code>BeamletOptics.sdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sdf(::AbstractRotationallySymmetricSurface, ::Union{Nothing, AbstractOrientationType})</code></pre><p>Takes the surface specification and an optional <code>AbstractOrientationType</code> as trait parameter and returns a corresponding <code>AbstractSDF</code> type.</p><p><strong>Surface vs. volume based tracing</strong></p><p>This function is a mere convenience provider for users coming from other optic simulations frameworks which are surface oriented. The goal of this function is to return the best matching closed volume SDF which posesses a surface with the given specs on one side and most often a boundary and planar surface on the other side.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Always keep in mind that this package performs closed-volume baced ray tracing using either SDFs or meshes. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/AbstractSurface.jl#L72-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.set_new_origin3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T" href="#BeamletOptics.set_new_origin3d!-Union{Tuple{BeamletOptics.AbstractMesh{T}}, Tuple{T}} where T"><code>BeamletOptics.set_new_origin3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_new_origin3d!(mesh::AbstractMesh)</code></pre><p>Resets the mesh <code>dir</code>ectional matrix and <code>pos</code>ition vector to their initial values.<br/><strong>Warning: this operation is non-reversible!</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.shape-Tuple{BeamletOptics.AbstractObject}" href="#BeamletOptics.shape-Tuple{BeamletOptics.AbstractObject}"><code>BeamletOptics.shape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Dispatch the shape function based on the <a href="#BeamletOptics.AbstractShapeTrait"><code>AbstractShapeTrait</code></a> of the <a href="#BeamletOptics.AbstractObject"><code>AbstractObject</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.shape_trait_of-Tuple{BeamletOptics.AbstractObject}" href="#BeamletOptics.shape_trait_of-Tuple{BeamletOptics.AbstractObject}"><code>BeamletOptics.shape_trait_of</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Default trait</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractObject.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.solve_system!-Union{Tuple{B}, Tuple{BeamletOptics.AbstractSystem, B}} where B&lt;:BeamletOptics.AbstractBeam" href="#BeamletOptics.solve_system!-Union{Tuple{B}, Tuple{BeamletOptics.AbstractSystem, B}} where B&lt;:BeamletOptics.AbstractBeam"><code>BeamletOptics.solve_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_system!(system::System, beam::AbstractBeam; r_max=100, retrace=true)</code></pre><p>Manage the tracing of an <code>AbstractBeam</code> through an optical <code>system</code>. The function retraces the <code>beam</code> if possible and then proceeds to trace each leaf of the beam tree through the system. The condition to stop ray tracing is that the last <code>beam</code> intersection is <code>nothing</code> or the beam interaction is <code>nothing</code>. Then, the system is considered to be solved. A maximum number of rays per <code>beam</code> (<code>r_max</code>) can be specified in order to avoid infinite calculations under resonant conditions, i.e. two facing mirrors.</p><p><strong>Arguments</strong></p><ul><li><code>system::System</code>: The optical system in which the beam will be traced.</li><li><code>beam::AbstractBeam</code>: The beam object to be traced through the system.</li><li><code>r_max::Int=100</code> (optional): Maximum number of tracing iterations for each leaf. Default is 100.</li><li><code>retrace::Bool=true</code> (optional): Flag to indicate if the system should be retraced. Default is true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.test_refractive_index_function-Tuple{Any}" href="#BeamletOptics.test_refractive_index_function-Tuple{Any}"><code>BeamletOptics.test_refractive_index_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_refractive_index_function(input)</code></pre><p>Tests if <code>input</code> is callable with a single <code>Real</code> argument for the wavelength <code>λ</code> and returns a single <code>Real</code> value for the refractive index <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.test_refractive_index_function-Tuple{DiscreteRefractiveIndex}" href="#BeamletOptics.test_refractive_index_function-Tuple{DiscreteRefractiveIndex}"><code>BeamletOptics.test_refractive_index_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><a href="#BeamletOptics.DiscreteRefractiveIndex"><code>DiscreteRefractiveIndex</code></a> passes test by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Utils.jl#L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.thickness-Tuple{BeamletOptics.AbstractLensSDF}" href="#BeamletOptics.thickness-Tuple{BeamletOptics.AbstractLensSDF}"><code>BeamletOptics.thickness</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the on-axis thickness of the <code>AbstractLensSDF</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/SphericalLensSDF.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.thickness-Union{Tuple{BeamletOptics.UnionSDF{T, TT} where TT&lt;:Tuple{Vararg{BeamletOptics.AbstractSDF{T}}}}, Tuple{T}} where T" href="#BeamletOptics.thickness-Union{Tuple{BeamletOptics.UnionSDF{T, TT} where TT&lt;:Tuple{Vararg{BeamletOptics.AbstractSDF{T}}}}, Tuple{T}} where T"><code>BeamletOptics.thickness</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thickness(union)</code></pre><p>Calculates the thickness of a union of <a href="#BeamletOptics.AbstractLensSDF"><code>AbstractLensSDF</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/SDFs/UnionSDF.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.trace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T&lt;:Real, R&lt;:BeamletOptics.AbstractRay{T}}" href="#BeamletOptics.trace_system!-Union{Tuple{R}, Tuple{T}, Tuple{BeamletOptics.AbstractSystem, Beam{T, R}}} where {T&lt;:Real, R&lt;:BeamletOptics.AbstractRay{T}}"><code>BeamletOptics.trace_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_system!(system::AbstractSystem, beam::Beam{T}; r_max::Int = 20) where {T &lt;: Real}</code></pre><p>Trace a <a href="#BeamletOptics.Beam"><code>Beam</code></a> through an optical <code>system</code>. Maximum number of tracing steps can be capped by <code>r_max</code>.</p><p><strong>Tracing logic</strong></p><p>The intersection of the last ray of the <code>beam</code> with any objects in the <code>system</code> is tested. If an object is hit, the optical interaction is analyzed and tracing continues. Else the tracing procedure is stopped.</p><p><strong>Arguments</strong></p><ul><li><code>system:</code>: The optical system through which the <a href="#BeamletOptics.Beam"><code>Beam</code></a> is traced.</li><li><code>beam</code>: The <a href="#BeamletOptics.Beam"><code>Beam</code></a> object to be traced.</li><li><code>r_max</code>: Maximum number of tracing iterations. Default is 20.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L113-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.trace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T&lt;:Real" href="#BeamletOptics.trace_system!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractSystem, GaussianBeamlet{T}}} where T&lt;:Real"><code>BeamletOptics.trace_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trace_system!(system::System, gauss::GaussianBeamlet{T}; r_max::Int = 20) where {T &lt;: Real}</code></pre><p>Trace a <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> through an optical <code>system</code>. Maximum number of tracing steps can be capped by <code>r_max</code>.</p><p><strong>Tracing logic</strong></p><p>The chief, waist and divergence beams are traced step-by-step through the <code>system</code>. For each intersection after a <a href="#BeamletOptics.tracing_step!-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRay{R}, BeamletOptics.Hint}} where R&lt;:Real"><code>tracing_step!</code></a>, the intersections are compared. If all rays hit the same target, the optical interaction is analyzed, else the tracing stops.</p><p><strong>Arguments</strong></p><ul><li><code>system</code>: The optical system through which the <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> is traced.</li><li><code>gauss</code>: The <a href="#BeamletOptics.GaussianBeamlet"><code>GaussianBeamlet</code></a> object to be traced.</li><li><code>r_max</code>: Maximum number of tracing iterations. Default is 20.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L257-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.tracing_step!-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRay{R}, BeamletOptics.Hint}} where R&lt;:Real" href="#BeamletOptics.tracing_step!-Union{Tuple{R}, Tuple{BeamletOptics.AbstractSystem, BeamletOptics.AbstractRay{R}, BeamletOptics.Hint}} where R&lt;:Real"><code>BeamletOptics.tracing_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tracing_step!(system::AbstractSystem, ray::AbstractRay{R}, hint::Hint)</code></pre><p>Tests if the <code>ray</code> intersects an <code>object</code> in the optical <code>system</code>. Returns the closest intersection.</p><p><strong>Hint</strong></p><p>An optional <a href="#BeamletOptics.Hint"><code>Hint</code></a> can be provided to test against a specific object (and shape) in the <code>system</code> first.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If a hint is provided and the object intersection is valid, the intersection will be returned immediately. However, it is not guaranteed that this is the true closest intersection.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/System.jl#L87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}" href="#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractMesh, Any}"><code>BeamletOptics.translate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate3d!(mesh::AbstractMesh, offset)</code></pre><p>Mutating function that translates the vertices of an mesh in relation to the offset vector. In addition, the mesh position vector is overwritten to reflect the new &quot;center of gravity&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/Mesh.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractShape, Any}" href="#BeamletOptics.translate3d!-Tuple{BeamletOptics.AbstractShape, Any}"><code>BeamletOptics.translate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate3d!(shape::AbstractShape, offset)</code></pre><p>Translates the <code>pos</code>ition of <code>shape</code> by the <code>offset</code>-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.translate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}" href="#BeamletOptics.translate3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}"><code>BeamletOptics.translate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate3d!(::MultiShape, object, offset)</code></pre><p>Moves all parts of the <a href="#BeamletOptics.MultiShape"><code>MultiShape</code></a> <code>object</code> along the specified <code>offset</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.translate_to3d!-Tuple{BeamletOptics.AbstractShape, Any}" href="#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.AbstractShape, Any}"><code>BeamletOptics.translate_to3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_to3d!(shape::AbstractShape, target)</code></pre><p>Translates the <code>shape</code> to the <code>target</code> position. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.translate_to3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}" href="#BeamletOptics.translate_to3d!-Tuple{BeamletOptics.MultiShape, BeamletOptics.AbstractObject, Any}"><code>BeamletOptics.translate_to3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_to3d!(::MultiShape, object, target)</code></pre><p>Translates all parts of the <a href="#BeamletOptics.MultiShape"><code>MultiShape</code></a> <code>object</code> in parallel to the specified <code>target</code> position. The <code>object</code> center point will be equal to the <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShapeTrait.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.xrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T" href="#BeamletOptics.xrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>BeamletOptics.xrotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rotates the <code>dir</code>-matrix of <code>shape</code> around the global x-axis by an angle of <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.yrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T" href="#BeamletOptics.yrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>BeamletOptics.yrotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rotates the <code>dir</code>-matrix of <code>shape</code> around the global y-axis by an angle of <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BeamletOptics.zrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T" href="#BeamletOptics.zrotate3d!-Union{Tuple{T}, Tuple{BeamletOptics.AbstractShape{T}, Any}} where T"><code>BeamletOptics.zrotate3d!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rotates the <code>dir</code>-matrix of <code>shape</code> around the global z-axis by an angle of <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/StackEnjoyer/BeamletOptics.jl/blob/237ca641de49c5051138f4b22feb80b1a947d574/src/AbstractTypes/AbstractShape.jl#L92">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« API design</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 2 April 2025 16:10">Wednesday 2 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
